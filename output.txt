================================================
File: README.md
================================================
# üöÄ Blueprint File Explorer

A modern, technical file system navigator built with **Wails v2**, **Go**, and **Preact**. Features a retro minimalist blueprint design inspired by technical diagrams and engineering schematics.

![Blueprint File Explorer](https://img.shields.io/badge/Wails-v2.10.1-blue) ![Go](https://img.shields.io/badge/Go-1.21+-00ADD8) ![Preact](https://img.shields.io/badge/Preact-10.10+-673AB8)

## ‚ú® Features

### üé® **Blueprint Design System**
- **Retro minimalist UI** inspired by technical blueprints
- **Grid-based background** with subtle technical overlay
- **Monospace typography** (JetBrains Mono) for technical aesthetics
- **Color-coded file types** with intuitive icons
- **Responsive design** with proper scaling

### üìÅ **File System Navigation**
- **Full directory browsing** with real-time updates
- **Breadcrumb navigation** with clickable segments
- **Quick access sidebar** with common locations
- **Drive detection** (Windows) with easy switching
- **File type recognition** with proper icons and colors
- **File size formatting** in human-readable units

### ‚ö° **Performance & UX**
- **Fast navigation** with minimal loading times
- **Keyboard shortcuts** (F5 refresh, Backspace/Alt+‚Üê navigate up)
- **Double-click to open** files in system default applications
- **Open in Explorer** functionality
- **Error handling** with user-friendly messages
- **Loading states** with blueprint-styled spinners

### üîß **Technical Features**
- **Cross-platform** support (Windows, macOS, Linux)
- **Go backend** with robust file system operations
- **Preact frontend** for efficient rendering
- **TypeScript bindings** auto-generated by Wails
- **Development hot-reload** with Vite

## üöÄ Getting Started

### Prerequisites
- **Go 1.21+**
- **Node.js 18+** or **Bun** (preferred)
- **Wails CLI v2**

### Installation

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd blueprint-file-explorer
   ```

2. **Install Wails CLI** (if not already installed)
   ```bash
   go install github.com/wailsapp/wails/v2/cmd/wails@latest
   ```

3. **Install frontend dependencies**
   ```bash
   cd frontend
   bun install  # or npm install
   cd ..
   ```

4. **Run in development mode**
   ```bash
   wails dev
   ```

5. **Build for production**
   ```bash
   wails build
   ```

## üéØ Usage

### Navigation
- **Click folders** to navigate into directories
- **Click breadcrumb segments** to jump to parent directories
- **Use sidebar** for quick access to common locations
- **Double-click files** to open with system default application

### Keyboard Shortcuts
- **F5** - Refresh current directory
- **Backspace** - Navigate to parent directory
- **Alt + ‚Üê** - Navigate to parent directory

### File Operations
- **View file details** including size, modification date, and permissions
- **Open in system explorer** using the toolbar button
- **Color-coded file types** for easy identification

## üèóÔ∏è Architecture

### Backend (Go)
- **File system operations** with proper error handling
- **Cross-platform path handling** for Windows/Unix systems
- **Drive detection** and system information
- **File metadata extraction** (size, permissions, timestamps)

### Frontend (Preact)
- **Component-based architecture** with hooks
- **Responsive design** with CSS Grid and Flexbox
- **State management** with React hooks
- **Event handling** for navigation and user interactions

### Design System
- **CSS Custom Properties** for theming
- **Blueprint color palette** with technical aesthetics
- **Typography hierarchy** using JetBrains Mono throughout
- **Grid patterns** and technical overlays

## üé® Design Philosophy

The Blueprint File Explorer embraces a **retro minimalist** aesthetic inspired by:
- **Technical blueprints** and engineering diagrams
- **Monospace typography** for precision and clarity
- **Grid-based layouts** with mathematical precision
- **Subtle animations** and hover effects
- **Color coding** for functional differentiation

## üîß Development

### Project Structure
```
blueprint-file-explorer/
‚îú‚îÄ‚îÄ app.go                 # Main Go application
‚îú‚îÄ‚îÄ main.go               # Application entry point
‚îú‚îÄ‚îÄ frontend/             # Preact frontend
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.jsx      # Main application component
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ style.css    # Blueprint design system
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.jsx     # Application bootstrap
‚îÇ   ‚îî‚îÄ‚îÄ package.json     # Frontend dependencies
‚îú‚îÄ‚îÄ build/               # Built application
‚îî‚îÄ‚îÄ wails.json          # Wails configuration
```

### Adding Features
1. **Backend methods** - Add new methods to `app.go`
2. **Frontend components** - Create new components in `src/`
3. **Styling** - Extend the design system in `style.css`
4. **Regenerate bindings** - Run `wails dev` to update TypeScript bindings

## üìù License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- **Wails** - For the excellent Go + Web framework
- **Preact** - For the lightweight React alternative
- **JetBrains Mono** - For the beautiful monospace typography
- **Blueprint design** - Inspired by technical diagram aesthetics

---

Built with ‚ù§Ô∏è using **Wails v2** & **Go**


================================================
File: .cursor/rules/project-overview.mdc
================================================
---
description: 
globs: 
alwaysApply: true
---
This Project is a Wails V2 Project (App) that uses Preact to build an alternative File Explorer for Windows 11 Systems. The UI Design is Retro and 8-bit styled yet also very zen and minimalist

================================================
File: frontend/package.json.md5
================================================
c3da20351cdc630bf29b545cce8f1b8d

================================================
File: backend/app.go
================================================
package backend

import (
	"context"
	"log"
)

// NewApp creates a new App application struct with dependency injection
func NewApp() *App {
	// Create all manager instances
	platform := NewPlatformManager()
	filesystem := NewFileSystemManager(platform)
	fileOps := NewFileOperationsManager(platform)
	drives := NewDriveManager()
	terminal := NewTerminalManager()

	return &App{
		filesystem: filesystem,
		fileOps:    fileOps,
		platform:   platform,
		drives:     drives,
		terminal:   terminal,
	}
}

// Startup is called when the app starts. The context is saved
// so we can call the runtime methods
func (a *App) Startup(ctx context.Context) {
	a.ctx = ctx

	// Set context on filesystem manager for event emission
	if fsManager, ok := a.filesystem.(*FileSystemManager); ok {
		fsManager.SetContext(ctx)
	}

	log.Println("üöÄ Blueprint File Explorer backend started with modular architecture")
}

// API Methods for Wails Frontend

// GetHomeDirectory returns the user's home directory
func (a *App) GetHomeDirectory() string {
	return a.platform.GetHomeDirectory()
}

// GetCurrentWorkingDirectory returns the current working directory
func (a *App) GetCurrentWorkingDirectory() string {
	return a.platform.GetCurrentWorkingDirectory()
}

// GetSystemRoots returns system root paths (drives on Windows, / on Unix)
func (a *App) GetSystemRoots() []string {
	return a.platform.GetSystemRoots()
}

// NavigateToPath navigates to a specific path
func (a *App) NavigateToPath(path string) NavigationResponse {
	return a.filesystem.NavigateToPath(path)
}

// NavigateUp navigates to the parent directory
func (a *App) NavigateUp(currentPath string) NavigationResponse {
	return a.filesystem.NavigateUp(currentPath)
}

// ListDirectory lists the contents of a directory
func (a *App) ListDirectory(path string) NavigationResponse {
	return a.filesystem.ListDirectory(path)
}

// GetFileDetails returns detailed information about a file
func (a *App) GetFileDetails(filePath string) FileInfo {
	fileInfo, err := a.filesystem.GetFileInfo(filePath)
	if err != nil {
		log.Printf("Error getting file details: %v", err)
		return FileInfo{}
	}
	return fileInfo
}

// OpenFile opens a file with its default application
func (a *App) OpenFile(filePath string) bool {
	return a.fileOps.OpenFile(filePath)
}

// OpenInSystemExplorer opens the given path in the system's default file manager
func (a *App) OpenInSystemExplorer(path string) bool {
	return a.platform.OpenInSystemExplorer(path)
}

// CopyFiles copies files from source paths to destination directory
func (a *App) CopyFiles(sourcePaths []string, destDir string) bool {
	return a.fileOps.CopyFiles(sourcePaths, destDir)
}

// MoveFiles moves files from source paths to destination directory
func (a *App) MoveFiles(sourcePaths []string, destDir string) bool {
	return a.fileOps.MoveFiles(sourcePaths, destDir)
}

// DeleteFiles permanently deletes the specified files and directories
func (a *App) DeleteFiles(filePaths []string) bool {
	return a.fileOps.DeleteFiles(filePaths)
}

// MoveFilesToRecycleBin moves files to the system recycle bin/trash
func (a *App) MoveFilesToRecycleBin(filePaths []string) bool {
	return a.fileOps.MoveFilesToRecycleBin(filePaths)
}

// RenameFile renames a file or directory
func (a *App) RenameFile(oldPath, newName string) bool {
	return a.fileOps.RenameFile(oldPath, newName)
}

// HideFiles sets the hidden attribute on the specified files
func (a *App) HideFiles(filePaths []string) bool {
	return a.fileOps.HideFiles(filePaths)
}

// CreateDirectory creates a new directory
func (a *App) CreateDirectory(path, name string) NavigationResponse {
	return a.filesystem.CreateDirectory(path, name)
}

// DeletePath deletes a file or directory (alias for compatibility)
func (a *App) DeletePath(path string) NavigationResponse {
	success := a.fileOps.DeleteFiles([]string{path})
	if success {
		return NavigationResponse{
			Success: true,
			Message: "Item deleted successfully",
		}
	}
	return NavigationResponse{
		Success: false,
		Message: "Failed to delete item",
	}
}

// GetDriveInfo returns information about available drives
func (a *App) GetDriveInfo() []map[string]interface{} {
	drives := a.drives.GetDriveInfo()

	// Convert to the expected format for backward compatibility
	var result []map[string]interface{}
	for _, drive := range drives {
		result = append(result, map[string]interface{}{
			"path":   drive.Path,
			"letter": drive.Letter,
			"name":   drive.Name,
		})
	}

	return result
}

// OpenPowerShellHere opens PowerShell 7 in the specified directory
func (a *App) OpenPowerShellHere(directoryPath string) bool {
	return a.terminal.OpenPowerShellHere(directoryPath)
}

// FormatFileSize formats file size in human readable format
func (a *App) FormatFileSize(size int64) string {
	return a.platform.FormatFileSize(size)
}

// Additional API methods for enhanced functionality

// GetQuickAccessPaths returns commonly accessed directories for quick navigation
func (a *App) GetQuickAccessPaths() []map[string]interface{} {
	paths := a.drives.GetQuickAccessPaths()

	var result []map[string]interface{}
	for _, path := range paths {
		result = append(result, map[string]interface{}{
			"path":   path.Path,
			"letter": path.Letter,
			"name":   path.Name,
		})
	}

	return result
}

// OpenTerminalHere opens the system's default terminal in the specified directory
func (a *App) OpenTerminalHere(directoryPath string) bool {
	return a.terminal.OpenTerminalHere(directoryPath)
}

// GetAvailableTerminals returns a list of available terminal applications
func (a *App) GetAvailableTerminals() []string {
	return a.terminal.GetAvailableTerminals()
}

// ValidatePath checks if a path is valid and accessible
func (a *App) ValidatePath(path string) bool {
	err := a.filesystem.ValidatePath(path)
	return err == nil
}

// FileExists checks if a file exists
func (a *App) FileExists(path string) bool {
	return a.filesystem.FileExists(path)
}

// IsHidden checks if a file/directory is hidden
func (a *App) IsHidden(path string) bool {
	return a.platform.IsHidden(path)
}

// ExecuteCommand executes a command in the background (useful for scripts)
func (a *App) ExecuteCommand(command string, workingDir string) bool {
	err := a.terminal.ExecuteCommand(command, workingDir)
	return err == nil
}

// Health check method for monitoring
func (a *App) HealthCheck() map[string]interface{} {
	return map[string]interface{}{
		"status":  "healthy",
		"modules": []string{"filesystem", "fileops", "platform", "drives", "terminal"},
	}
}

// PrefetchDirectory pre-loads directory contents for faster navigation
// This method is called when hovering over folders to improve perceived performance
func (a *App) PrefetchDirectory(path string) NavigationResponse {
	// Use the same method as NavigateToPath but mark it as prefetch for logging
	log.Printf("üîÑ Prefetching directory: %s", path)

	response := a.filesystem.ListDirectory(path)

	if response.Success {
		log.Printf("‚úÖ Prefetched directory %s: %d files, %d dirs",
			path, response.Data.TotalFiles, response.Data.TotalDirs)
	} else {
		log.Printf("‚ùå Failed to prefetch directory %s: %s", path, response.Message)
	}

	return response
}


================================================
File: frontend/package.json
================================================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "preact": "^10.10.1"
  },
  "devDependencies": {
    "@preact/preset-vite": "^2.3.0",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.4",
    "tailwindcss": "3",
    "vite": "^3.0.7"
  }
}

================================================
File: backend/events.go
================================================
package backend

import (
	"context"
	"log"

	"github.com/wailsapp/wails/v2/pkg/runtime"
)

// EventEmitter handles Wails runtime events
type EventEmitter struct {
	ctx context.Context
}

// NewEventEmitter creates a new event emitter
func NewEventEmitter(ctx context.Context) *EventEmitter {
	return &EventEmitter{ctx: ctx}
}

// EmitDirectoryHydrate emits a directory hydration event to the frontend
func (e *EventEmitter) EmitDirectoryHydrate(fileInfo FileInfo) {
	if e.ctx != nil {
		runtime.EventsEmit(e.ctx, "DirectoryHydrate", fileInfo)
		log.Printf("üì° Emitted hydration event for: %s", fileInfo.Name)
	}
}

// EmitDirectoryBatch emits a batch of directory entries to the frontend
func (e *EventEmitter) EmitDirectoryBatch(entries []FileInfo) {
	if e.ctx != nil {
		runtime.EventsEmit(e.ctx, "DirectoryBatch", entries)
		log.Printf("üì° Emitted batch of %d entries", len(entries))
	}
}

// EmitDirectoryComplete signals that directory loading is complete
func (e *EventEmitter) EmitDirectoryComplete(path string, totalFiles, totalDirs int) {
	if e.ctx != nil {
		runtime.EventsEmit(e.ctx, "DirectoryComplete", map[string]interface{}{
			"path":       path,
			"totalFiles": totalFiles,
			"totalDirs":  totalDirs,
		})
		log.Printf("üì° Emitted directory complete for: %s (%d files, %d dirs)", path, totalFiles, totalDirs)
	}
}


================================================
File: frontend/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


================================================
File: backend/filesystem_stream_fallback.go
================================================
//go:build !windows

package backend

import (
	"os"
	"path/filepath"
	"strings"
)

// BasicEntry holds minimal info for instant UI rendering
type BasicEntry struct {
	Name      string `json:"name"`
	Path      string `json:"path"`
	IsDir     bool   `json:"isDir"`
	Extension string `json:"extension"`
	IsHidden  bool   `json:"isHidden"`
}

// HydratedEntry holds complete file information for background processing
type HydratedEntry struct {
	BasicEntry
	Size        int64  `json:"size"`
	ModTime     int64  `json:"modTime"` // Unix timestamp for faster JSON serialization
	Permissions string `json:"permissions"`
}

// listDirectoryBasic provides the same interface as Windows version but uses standard Go calls
func listDirectoryBasic(dir string) ([]BasicEntry, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	basic := make([]BasicEntry, 0, len(entries))
	for _, entry := range entries {
		name := entry.Name()
		fullPath := filepath.Join(dir, name)

		// Use entry.Info() to get file info
		info, err := entry.Info()
		if err != nil {
			continue // Skip files we can't stat
		}

		isDir := info.IsDir()

		// Basic hidden file detection for Unix systems
		isHidden := strings.HasPrefix(name, ".")

		var ext string
		if !isDir && len(name) > 0 {
			ext = strings.ToLower(strings.TrimPrefix(filepath.Ext(name), "."))
		}

		basic = append(basic, BasicEntry{
			Name:      name,
			Path:      fullPath,
			IsDir:     isDir,
			IsHidden:  isHidden,
			Extension: ext,
		})
	}

	return basic, nil
}


================================================
File: frontend/src/app.jsx
================================================
import './components/FastNavigation.css';
import { useState, useEffect, useCallback, useMemo } from "preact/hooks";
import { 
    GetHomeDirectory, 
    GetDriveInfo,
    OpenInSystemExplorer
} from "../wailsjs/go/backend/App";

// Import optimized utilities
import { log, warn, error } from "./utils/logger";
import { 
    HEADER_STATS_STYLE,
    PERFORMANCE_INDICATOR_STYLE,
    CURRENT_PATH_INDICATOR_STYLE,
    ERROR_DISMISS_BUTTON_STYLE,
    STATUS_BAR_RIGHT_STYLE,
    LOADING_OVERLAY_STYLE,
    LARGE_ICON_STYLE,
    LOADING_SPINNER_LARGE_STYLE,
    EMPTY_DIRECTORY_STYLE
} from "./utils/styleConstants";

// Import our custom components
import {
    Breadcrumb,
    Sidebar,
    FileItem,
    ContextMenu,
    EmptySpaceContextMenu,
    RetroDialog,
    VirtualizedFileList,
    InlineFolderEditor
} from "./components";

// Import our custom hooks
import {
    useFileOperations,
    useSelection,
    useClipboard,
    useNavigation,
    useDialogs,
    useContextMenus,
    usePerformanceMonitoring,
    useKeyboardShortcuts,
    useDragAndDrop,
    useFolderCreation
} from "./hooks";

// Import our utilities
import { filterFiles } from "./utils/fileUtils";



// Main App component
export function App() {
    // Basic UI state
    const [error, setError] = useState('');
    const [drives, setDrives] = useState([]);
    const [showHiddenFiles, setShowHiddenFiles] = useState(false);

    // Custom hooks
    const { navigationStats, setNavigationStats } = usePerformanceMonitoring();
    

    
    const {
        currentPath,
        directoryContents,
        showLoadingIndicator,
        navigateToPath,
        handleNavigateUp,
        handleRefresh
    } = useNavigation(setError, setNavigationStats);

    const { dialog, showDialog, closeDialog } = useDialogs();

    const {
        selectedFiles,
        handleFileSelect,
        clearSelection,
        selectAll,
        handleArrowNavigation
    } = useSelection();

    const {
        clipboardFiles,
        clipboardOperation,
        handleCopy,
        handleCut,
        clearClipboard,
        isPasteAvailable
    } = useClipboard();

    // Initialize file operations hook
    const fileOperations = useFileOperations(
        currentPath, 
        setError, 
        clearSelection, 
        () => navigateToPath(currentPath), 
        showDialog
    );

    // Folder creation hook
    const {
        creatingFolder,
        tempFolderName,
        editInputRef,
        startFolderCreation,
        cancelFolderCreation,
        confirmFolderCreation,
        handleKeyDown,
        handleInputChange,
        handleInputBlur
    } = useFolderCreation(currentPath, handleRefresh, setError);

    // Computed values
    const filteredDirectories = useMemo(() => 
        directoryContents ? filterFiles(directoryContents.directories, showHiddenFiles) : [], 
        [directoryContents, showHiddenFiles]
    );
    
    const filteredFiles = useMemo(() => 
        directoryContents ? filterFiles(directoryContents.files, showHiddenFiles) : [], 
        [directoryContents, showHiddenFiles]
    );
    
    const allFiles = useMemo(() => 
        [...filteredDirectories, ...filteredFiles], 
        [filteredDirectories, filteredFiles]
    );

    // Context menus hook
    const {
        contextMenu,
        emptySpaceContextMenu,
        handleContextMenu,
        closeContextMenu,
        handleEmptySpaceContextMenu,
        closeEmptySpaceContextMenu,
        handleContextCopy,
        handleContextCut,
        handleContextRename,
        handleContextHide,
        handlePermanentDelete,
        handleOpenPowerShell,
        handleCreateFolder
    } = useContextMenus(
        selectedFiles, 
        allFiles, 
        handleCopy, 
        handleCut, 
        showDialog, 
        fileOperations, 
        currentPath, 
        startFolderCreation
    );

    // Drag and drop hook
    const {
        dragState,
        handleDragStart,
        handleDragOver,
        handleDragEnter,
        handleDragLeave,
        handleDrop,
        handleDragEnd
    } = useDragAndDrop(
        currentPath,
        selectedFiles,
        allFiles,
        setError,
        clearSelection,
        handleRefresh
    );

    // File operation handlers
    const handleFileOpen = useCallback((file) => {
        const result = fileOperations.handleFileOpen(file);
        if (result && result.type === 'navigate') {
            // Use direct navigation for file opens (immediate response)
            navigateToPath(result.path, 'file-open');
        }
    }, [fileOperations, navigateToPath]);

    const handleOpenInExplorer = useCallback(() => {
        if (currentPath) {
            OpenInSystemExplorer(currentPath);
        }
    }, [currentPath]);

    // Clipboard operations
    const handleCopySelected = useCallback(() => {
        const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
        const filePaths = selectedFileObjects.map(file => file.path);
        handleCopy(filePaths);
    }, [selectedFiles, allFiles, handleCopy]);

    const handleCutSelected = useCallback(() => {
        const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
        const filePaths = selectedFileObjects.map(file => file.path);
        handleCut(filePaths);
    }, [selectedFiles, allFiles, handleCut]);

    const handlePaste = useCallback(async () => {
        if (!isPasteAvailable() || !currentPath) return;
        
        try {
            log(`üì• Pasting ${clipboardFiles.length} items to:`, currentPath);
            
            let success = false;
            if (clipboardOperation === 'copy') {
                success = await fileOperations.handleCopyFiles(clipboardFiles);
            } else if (clipboardOperation === 'cut') {
                success = await fileOperations.handleMoveFiles(clipboardFiles);
                if (success) {
                    clearClipboard();
                }
            }
            
            if (!success) {
                setError('Paste operation failed');
            } else {
                // Refresh the directory to show the pasted files immediately
                handleRefresh();
            }
        } catch (err) {
            error('‚ùå Error during paste operation:', err);
            setError('Failed to paste files: ' + err.message);
        }
    }, [isPasteAvailable, currentPath, clipboardFiles, clipboardOperation, fileOperations, clearClipboard]);

    // Keyboard shortcuts
    useKeyboardShortcuts({
        handleRefresh,
        handleNavigateUp,
        selectedFiles,
        allFiles,
        handleFileOpen,
        selectAll,
        handleCopySelected,
        handleCutSelected,
        handlePaste,
        isPasteAvailable,
        handleArrowNavigation,
        clearSelection,
        closeContextMenu,
        closeEmptySpaceContextMenu
    });

    // Initialize app
    useEffect(() => {
        log('üöÄ Zen File Explorer initializing...');
        initializeApp();
    }, []);

    const initializeApp = async () => {
        try {
            setError('');
            
            const homeDir = await GetHomeDirectory();
            if (homeDir) {
                await navigateToPath(homeDir, 'init');
            } else {
                setError('Unable to determine starting directory');
            }
        } catch (err) {
            error('‚ùå Error initializing app:', err);
            setError('Failed to initialize file explorer: ' + err.message);
        }
    };

    // Load drives
    useEffect(() => {
        GetDriveInfo().then(driveList => {
            setDrives(driveList);
        });
    }, []);

    // Clear selection when path changes
    useEffect(() => {
        clearSelection();
        closeContextMenu();
    }, [currentPath, clearSelection, closeContextMenu]);

    return (
        <div 
            className={`file-explorer ${dragState.isDragging ? 'dragging-active' : ''}`}
            onSelectStart={(e) => e.preventDefault()}
            onDragEnd={handleDragEnd}
            onContextMenu={(e) => {
                // Global fallback to prevent browser context menu
                if (!e.target.closest('.file-item') && !e.target.closest('.context-menu')) {
                    e.preventDefault();
                }
            }}
        >
            {/* Header */}
            <header className="app-header">
                <div className="app-title">Files</div>
                <div style={HEADER_STATS_STYLE}>
                    {showLoadingIndicator && <div className="loading-spinner"></div>}
                    <span className="text-technical">
                        {directoryContents ? 
                            `${filteredDirectories.length} dirs ‚Ä¢ ${filteredFiles.length} files${!showHiddenFiles ? ' (hidden filtered)' : ''}${selectedFiles.size > 0 ? ` ‚Ä¢ ${selectedFiles.size} selected` : ''}` : 
                            'Ready'
                        }
                    </span>
                    {/* Performance indicator - Complete UI render timing */}
                    {navigationStats.totalNavigations > 0 && (
                        <span className="text-technical" style={PERFORMANCE_INDICATOR_STYLE}>
                            {navigationStats.lastNavigationTime === 0 ? 
                                'Measuring...' : 
                                `${Math.round(navigationStats.lastNavigationTime)}ms fresh data`
                            }
                            {` (${navigationStats.totalNavigations} real-time loads)`}
                        </span>
                    )}
                </div>
            </header>
            
            {/* Error display */}
            {error && (
                <div className="error-message">
                    <strong>‚ö†Ô∏è Error:</strong> {error}
                    <button onClick={() => setError('')} style={ERROR_DISMISS_BUTTON_STYLE}>
                        Dismiss
                    </button>
                </div>
            )}
            
            {/* Main content */}
            <div className="main-content">
                <Sidebar 
                    currentPath={currentPath}
                    onNavigate={(path) => navigateToPath(path, 'sidebar')}
                    drives={drives}
                />
                
                <div className="content-area">
                    {/* Toolbar */}
                    <div className="toolbar">
                        <button className="toolbar-btn" onClick={handleNavigateUp} disabled={!currentPath}>
                            ‚¨ÜÔ∏è Up
                        </button>
                        <button className="toolbar-btn" onClick={handleRefresh} disabled={!currentPath}>
                            üîÑ Refresh
                        </button>
                        <button className="toolbar-btn" onClick={handleOpenInExplorer} disabled={!currentPath}>
                            üñ•Ô∏è Open in Explorer
                        </button>
                        <button 
                            className={`toolbar-btn ${showHiddenFiles ? 'active' : ''}`}
                            onClick={() => setShowHiddenFiles(!showHiddenFiles)}
                        >
                            {showHiddenFiles ? 'üëÅÔ∏è' : 'üôà'} Hidden
                        </button>
                    </div>
                    
                    {/* Breadcrumb navigation */}
                    {currentPath && (
                        <Breadcrumb 
                            currentPath={currentPath}
                            onNavigate={(path) => navigateToPath(path, 'breadcrumb')}
                        />
                    )}
                    
                    {/* File list - Use virtual scrolling for better performance */}
                    <div 
                        className="file-list-container"
                        onClick={(e) => {
                            // Check if clicking on empty space (not on a file item)
                            if (e.target === e.currentTarget || e.target.classList.contains('file-list') || e.target.classList.contains('file-list-container')) {
                                clearSelection();
                                closeContextMenu();
                                closeEmptySpaceContextMenu();
                            }
                        }}
                        onContextMenu={(e) => {
                            // Prevent default browser context menu and show our custom one
                            e.preventDefault();
                            
                            // Check if right-clicking on empty space (not on a file item)
                            const isEmptySpace = e.target === e.currentTarget || 
                                                e.target.classList.contains('file-list') || 
                                                e.target.classList.contains('file-list-container') ||
                                                e.target.classList.contains('virtualized-file-list') ||
                                                (!e.target.closest('.file-item'));
                            
                            if (isEmptySpace) {
                                closeContextMenu();
                                closeEmptySpaceContextMenu();
                                handleEmptySpaceContextMenu(e);
                            }
                        }}
                    >
                        {showLoadingIndicator ? (
                            <div className="loading-overlay">
                                <div style={LOADING_OVERLAY_STYLE}>
                                    <div className="loading-spinner" style={LOADING_SPINNER_LARGE_STYLE}></div>
                                    <div className="text-technical">Loading directory...</div>
                                </div>
                            </div>
                        ) : directoryContents ? (
                            allFiles.length > 20 ? (
                                // Use virtual scrolling for large directories
                                <VirtualizedFileList
                                    files={allFiles}
                                    selectedFiles={selectedFiles}
                                    onFileSelect={handleFileSelect}
                                    onFileOpen={handleFileOpen}
                                    onContextMenu={handleContextMenu}
                                    isLoading={false} // Never show loading in file items
                                    clipboardFiles={clipboardFiles}
                                    clipboardOperation={clipboardOperation}
                                    dragState={dragState}
                                    onDragStart={handleDragStart}
                                    onDragOver={handleDragOver}
                                    onDragEnter={handleDragEnter}
                                    onDragLeave={handleDragLeave}
                                    onDrop={handleDrop}
                                    creatingFolder={creatingFolder}
                                    tempFolderName={tempFolderName}
                                    editInputRef={editInputRef}
                                    onFolderKeyDown={handleKeyDown}
                                    onFolderInputChange={handleInputChange}
                                    onFolderInputBlur={handleInputBlur}
                                    onEmptySpaceContextMenu={handleEmptySpaceContextMenu}
                                />
                            ) : (
                                // Use normal rendering for small directories
                                <div 
                                    className="file-list custom-scrollbar"
                                    onContextMenu={(e) => {
                                        // Check if right-clicking on the file list itself (empty space)
                                        if (e.target === e.currentTarget || !e.target.closest('.file-item')) {
                                            e.preventDefault();
                                            closeContextMenu();
                                            closeEmptySpaceContextMenu();
                                            handleEmptySpaceContextMenu(e);
                                        }
                                    }}
                                >
                                    {/* Show inline folder editor if creating folder */}
                                    {creatingFolder && (
                                        <InlineFolderEditor
                                            tempFolderName={tempFolderName}
                                            editInputRef={editInputRef}
                                            onKeyDown={handleKeyDown}
                                            onChange={handleInputChange}
                                            onBlur={handleInputBlur}
                                        />
                                    )}
                                    
                                    {allFiles.map((file, index) => (
                                        <FileItem
                                            key={file.path}
                                            file={file}
                                            fileIndex={index}
                                            onSelect={handleFileSelect}
                                            onOpen={handleFileOpen}
                                            onContextMenu={handleContextMenu}
                                            isLoading={false} // Never show loading in file items
                                            isSelected={selectedFiles.has(index)}
                                            isCut={clipboardOperation === 'cut' && clipboardFiles.includes(file.path)}
                                            isDragOver={dragState.dragOverFolder === file.path}
                                            onDragStart={handleDragStart}
                                            onDragOver={handleDragOver}
                                            onDragEnter={handleDragEnter}
                                            onDragLeave={handleDragLeave}
                                            onDrop={handleDrop}
                                        />
                                    ))}
                                    
                                    {allFiles.length === 0 && !creatingFolder && (
                                        <div style={EMPTY_DIRECTORY_STYLE}>
                                            <div style={LARGE_ICON_STYLE}>üìÅ</div>
                                            <div className="text-technical">Directory is empty</div>
                                        </div>
                                    )}
                                </div>
                            )
                        ) : (
                            <div style={EMPTY_DIRECTORY_STYLE}>
                                <div style={LARGE_ICON_STYLE}>üìÅ</div>
                                <div className="text-technical">Ready</div>
                            </div>
                        )}
                    </div>
                </div>
            </div>
            
            {/* Context Menus and Dialog */}
            <ContextMenu
                visible={contextMenu.visible}
                x={contextMenu.x}
                y={contextMenu.y}
                files={contextMenu.files}
                onClose={closeContextMenu}
                onCopy={handleContextCopy}
                onCut={handleContextCut}
                onRename={handleContextRename}
                onHide={handleContextHide}
                onPermanentDelete={handlePermanentDelete}
            />
            
            <EmptySpaceContextMenu
                visible={emptySpaceContextMenu.visible}
                x={emptySpaceContextMenu.x}
                y={emptySpaceContextMenu.y}
                onClose={closeEmptySpaceContextMenu}
                onOpenPowerShell={handleOpenPowerShell}
                onCreateFolder={handleCreateFolder}
            />
            
            <RetroDialog
                isOpen={dialog.isOpen}
                type={dialog.type}
                title={dialog.title}
                message={dialog.message}
                defaultValue={dialog.defaultValue}
                onConfirm={dialog.onConfirm}
                onCancel={dialog.onCancel}
                onClose={closeDialog}
            />
            
            {/* Status bar */}
            <div className="status-bar">
                <span>
                    Path: {currentPath || 'Not selected'} 
                    {selectedFiles.size > 0 && ` ‚Ä¢ ${selectedFiles.size} item${selectedFiles.size === 1 ? '' : 's'} selected`}
                    {clipboardFiles.length > 0 && ` ‚Ä¢ ${clipboardFiles.length} item${clipboardFiles.length === 1 ? '' : 's'} ${clipboardOperation === 'cut' ? 'cut' : 'copied'}`}
                    {dragState.isDragging && ` ‚Ä¢ Dragging ${dragState.draggedFiles.length} item${dragState.draggedFiles.length === 1 ? '' : 's'} (${dragState.dragOperation === 'copy' ? 'Hold Ctrl to copy' : 'Release Ctrl to move'})`}
                </span>
                <span style={STATUS_BAR_RIGHT_STYLE}>
                    File Explorer ‚Ä¢ Real-time updates ‚Ä¢ Drag to folders to move/copy
                </span>
            </div>
        </div>
    );
} 

================================================
File: backend/filesystem.go
================================================
package backend

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"
)

// NewFileSystemManager creates a new filesystem manager instance
func NewFileSystemManager(platform PlatformManagerInterface) *FileSystemManager {
	return &FileSystemManager{
		platform: platform,
	}
}

// SetContext sets the Wails context for event emission
func (fs *FileSystemManager) SetContext(ctx context.Context) {
	fs.ctx = ctx
	fs.eventEmitter = NewEventEmitter(ctx)
}

// ListDirectory lists the contents of a directory with streaming optimization
func (fs *FileSystemManager) ListDirectory(path string) NavigationResponse {
	startTime := time.Now()
	log.Printf("üìÇ Listing directory with streaming: %s", path)

	if path == "" {
		path = fs.platform.GetHomeDirectory()
	}

	// Clean and validate path
	path = filepath.Clean(path)

	// Quick existence check first
	info, err := os.Stat(path)
	if err != nil {
		return NavigationResponse{
			Success: false,
			Message: fmt.Sprintf("Cannot access path: %v", err),
		}
	}

	if !info.IsDir() {
		return NavigationResponse{
			Success: false,
			Message: "Path is not a directory",
		}
	}

	// Use optimized enumeration
	basicEntries, err := listDirectoryBasic(path)
	if err != nil {
		return NavigationResponse{
			Success: false,
			Message: fmt.Sprintf("Cannot read directory: %v", err),
		}
	}

	// Filter out skipped files
	var filteredEntries []BasicEntry
	for _, entry := range basicEntries {
		if !fs.shouldSkipFile(entry.Name) {
			filteredEntries = append(filteredEntries, entry)
		}
	}

	// Split into first page and rest for background processing
	const pageSize = 100
	firstPage := filteredEntries
	var rest []BasicEntry

	if len(filteredEntries) > pageSize {
		firstPage = filteredEntries[:pageSize]
		rest = filteredEntries[pageSize:]
	}

	// Convert first page to FileInfo with minimal data
	files := make([]FileInfo, 0, pageSize/2)
	directories := make([]FileInfo, 0, pageSize/2)

	for _, entry := range firstPage {
		// Create minimal FileInfo for immediate display
		fileInfo := FileInfo{
			Name:        entry.Name,
			Path:        entry.Path,
			IsDir:       entry.IsDir,
			Extension:   entry.Extension,
			IsHidden:    entry.IsHidden,
			Size:        0,           // Defer size calculation
			ModTime:     time.Time{}, // Defer mod time
			Permissions: "",          // Defer permissions
		}

		if entry.IsDir {
			directories = append(directories, fileInfo)
		} else {
			files = append(files, fileInfo)
		}
	}

	// Sort first page for immediate display
	sort.Slice(directories, func(i, j int) bool {
		return strings.ToLower(directories[i].Name) < strings.ToLower(directories[j].Name)
	})
	sort.Slice(files, func(i, j int) bool {
		return strings.ToLower(files[i].Name) < strings.ToLower(files[j].Name)
	})

	// Get parent path
	parentPath := filepath.Dir(path)
	if parentPath == path {
		parentPath = ""
	}

	// Build immediate response
	contents := DirectoryContents{
		CurrentPath: path,
		ParentPath:  parentPath,
		Files:       files,
		Directories: directories,
		TotalFiles:  len(files),
		TotalDirs:   len(directories),
	}

	// Start background hydration if we have remaining entries
	if len(rest) > 0 {
		go fs.hydrateRemainingEntries(path, rest)
	}

	processingTime := time.Since(startTime)
	log.Printf("‚úÖ First page listed in %v: %s (%d dirs, %d files, %d deferred)",
		processingTime, path, len(directories), len(files), len(rest))

	return NavigationResponse{
		Success: true,
		Message: fmt.Sprintf("Directory listed (first page) in %v", processingTime),
		Data:    contents,
	}
}

// hydrateRemainingEntries processes remaining entries in background
func (fs *FileSystemManager) hydrateRemainingEntries(basePath string, entries []BasicEntry) {
	log.Printf("üîÑ Starting background hydration for %d entries", len(entries))

	for _, entry := range entries {
		// Get full file info with stat data
		info, err := os.Stat(entry.Path)
		if err != nil {
			log.Printf("‚ö†Ô∏è Failed to stat %s: %v", entry.Path, err)
			continue
		}

		// Create complete FileInfo
		fileInfo := FileInfo{
			Name:        entry.Name,
			Path:        entry.Path,
			IsDir:       entry.IsDir,
			Size:        info.Size(),
			ModTime:     info.ModTime(),
			Permissions: info.Mode().String(),
			Extension:   entry.Extension,
			IsHidden:    entry.IsHidden,
		}

		// Emit hydration event to frontend
		if fs.eventEmitter != nil {
			fs.eventEmitter.EmitDirectoryHydrate(fileInfo)
		}
	}

	// Emit completion event
	if fs.eventEmitter != nil {
		fs.eventEmitter.EmitDirectoryComplete(basePath, len(entries), 0)
	}

	log.Printf("‚úÖ Background hydration completed for %s", basePath)
}

// processEntriesSync processes directory entries synchronously with optimizations
func (fs *FileSystemManager) processEntriesSync(path string, entries []os.DirEntry, files, directories []FileInfo) ([]FileInfo, []FileInfo) {
	for _, entry := range entries {
		// Skip processing certain system files early for performance
		name := entry.Name()
		if fs.shouldSkipFile(name) {
			continue
		}

		fileInfo := fs.CreateFileInfoOptimized(path, name, entry)

		if fileInfo.IsDir {
			directories = append(directories, fileInfo)
		} else {
			files = append(files, fileInfo)
		}
	}
	return files, directories
}

// processEntriesConcurrent processes directory entries concurrently with worker pool
func (fs *FileSystemManager) processEntriesConcurrent(path string, entries []os.DirEntry) ([]FileInfo, []FileInfo) {
	// Optimized worker pool size based on entry count and CPU cores
	numWorkers := 6 // Sweet spot for most systems
	if len(entries) < 200 {
		numWorkers = 3
	}

	type workItem struct {
		entry os.DirEntry
		index int
	}

	type result struct {
		fileInfo FileInfo
		isDir    bool
		index    int
	}

	entryChan := make(chan workItem, len(entries))
	resultChan := make(chan result, len(entries))

	// Start worker goroutines
	var wg sync.WaitGroup
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for item := range entryChan {
				// Skip certain files early
				if fs.shouldSkipFile(item.entry.Name()) {
					continue
				}

				fileInfo := fs.CreateFileInfoOptimized(path, item.entry.Name(), item.entry)
				resultChan <- result{
					fileInfo: fileInfo,
					isDir:    fileInfo.IsDir,
					index:    item.index,
				}
			}
		}()
	}

	// Send work items
	go func() {
		defer close(entryChan)
		for i, entry := range entries {
			entryChan <- workItem{entry: entry, index: i}
		}
	}()

	// Close result channel when all workers are done
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Collect results
	files := make([]FileInfo, 0, len(entries)/2)
	directories := make([]FileInfo, 0, len(entries)/2)

	for res := range resultChan {
		if res.isDir {
			directories = append(directories, res.fileInfo)
		} else {
			files = append(files, res.fileInfo)
		}
	}

	return files, directories
}

// shouldSkipFile determines if a file should be skipped for performance
func (fs *FileSystemManager) shouldSkipFile(name string) bool {
	// Skip certain system files that are typically not needed
	skipPatterns := []string{
		"$RECYCLE.BIN",
		"System Volume Information",
		"pagefile.sys",
		"hiberfil.sys",
		"swapfile.sys",
		".DS_Store",
		".Trashes",
		".Spotlight-V100",
	}

	for _, pattern := range skipPatterns {
		if strings.EqualFold(name, pattern) {
			return true
		}
	}

	return false
}

// CreateFileInfoOptimized creates FileInfo with performance optimizations
func (fs *FileSystemManager) CreateFileInfoOptimized(basePath string, name string, entry os.DirEntry) FileInfo {
	fullPath := filepath.Join(basePath, name)

	// Use DirEntry info when possible to avoid extra stat calls
	var info os.FileInfo
	var err error

	if entry != nil {
		info, err = entry.Info()
	} else {
		info, err = os.Stat(fullPath)
	}

	if err != nil {
		log.Printf("Warning: Error getting file info for %s: %v", fullPath, err)
		// Return basic info even on error
		return FileInfo{
			Name:     name,
			Path:     fullPath,
			IsDir:    entry != nil && entry.IsDir(),
			IsHidden: fs.platform.IsHidden(fullPath),
		}
	}

	return FileInfo{
		Name:        name,
		Path:        fullPath,
		IsDir:       info.IsDir(),
		Size:        info.Size(),
		ModTime:     info.ModTime(),
		Permissions: info.Mode().String(),
		Extension:   fs.platform.GetExtension(name),
		IsHidden:    fs.platform.IsHidden(fullPath),
	}
}

// CreateFileInfo creates FileInfo from file path and name (backward compatibility)
func (fs *FileSystemManager) CreateFileInfo(basePath string, name string) FileInfo {
	return fs.CreateFileInfoOptimized(basePath, name, nil)
}

// GetFileInfo returns detailed information about a specific file
func (fs *FileSystemManager) GetFileInfo(filePath string) (FileInfo, error) {
	log.Printf("Getting file details for: %s", filePath)

	info, err := os.Stat(filePath)
	if err != nil {
		log.Printf("Error getting file details: %v", err)
		return FileInfo{}, err
	}

	return FileInfo{
		Name:        filepath.Base(filePath),
		Path:        filePath,
		IsDir:       info.IsDir(),
		Size:        info.Size(),
		ModTime:     info.ModTime(),
		Permissions: info.Mode().String(),
		Extension:   fs.platform.GetExtension(filepath.Base(filePath)),
		IsHidden:    fs.platform.IsHidden(filePath),
	}, nil
}

// IsHidden checks if a file/directory is hidden
func (fs *FileSystemManager) IsHidden(path string) bool {
	return fs.platform.IsHidden(path)
}

// GetExtension returns the file extension
func (fs *FileSystemManager) GetExtension(name string) string {
	return fs.platform.GetExtension(name)
}

// NavigateToPath navigates to a specific path with enhanced logging
func (fs *FileSystemManager) NavigateToPath(path string) NavigationResponse {
	log.Printf("üß≠ Navigation request: %s", path)
	return fs.ListDirectory(path)
}

// NavigateUp navigates to the parent directory with path validation
func (fs *FileSystemManager) NavigateUp(currentPath string) NavigationResponse {
	if currentPath == "" {
		return NavigationResponse{
			Success: false,
			Message: "No current path provided",
		}
	}

	parentPath := filepath.Dir(currentPath)
	if parentPath == currentPath {
		// Already at root
		return NavigationResponse{
			Success: false,
			Message: "Already at root directory",
		}
	}

	log.Printf("‚¨ÜÔ∏è Navigate up: %s -> %s", currentPath, parentPath)
	return fs.ListDirectory(parentPath)
}

// FileExists checks if a file exists
func (fs *FileSystemManager) FileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

// CreateDirectory creates a new directory
func (fs *FileSystemManager) CreateDirectory(path, name string) NavigationResponse {
	fullPath := filepath.Join(path, name)

	err := os.MkdirAll(fullPath, 0755)
	if err != nil {
		return NavigationResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to create directory: %v", err),
		}
	}

	log.Printf("üìÅ Directory created: %s", fullPath)
	return NavigationResponse{
		Success: true,
		Message: "Directory created successfully",
	}
}

// ValidatePath checks if a path is valid and accessible with optimized validation
func (fs *FileSystemManager) ValidatePath(path string) error {
	if path == "" {
		return fmt.Errorf("path cannot be empty")
	}

	info, err := os.Stat(path)
	if err != nil {
		return fmt.Errorf("cannot access path: %v", err)
	}

	if !info.IsDir() {
		return fmt.Errorf("path is not a directory")
	}

	return nil
}


================================================
File: frontend/src/components/FastNavigation.css
================================================
/* Fast Navigation CSS Optimizations - Zen Theme */

/* Disable text selection for all fast navigation elements */
.file-list-container,
.file-list,
.loading-overlay,
.app-header,
.loading-spinner,
.nav-segment,
.sidebar-item,
.file-item,
.toolbar-btn,
.context-menu,
.status-bar,
.error-message {
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    -webkit-touch-callout: none !important;
    -webkit-tap-highlight-color: transparent !important;
}

.file-list-container {
    position: relative;
    flex: 1;
    overflow: hidden;
    contain: layout style paint;
    /* Fix height calculation issues */
    min-height: 0;
    background: var(--zen-surface);
    border-radius: var(--zen-radius-md);
}

.file-list {
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
    
    /* Optimize scrolling performance */
    scroll-behavior: smooth;
    overscroll-behavior: contain;
    
    /* GPU acceleration */
    transform: translateZ(0);
    will-change: scroll-position;
    
    /* Prevent horizontal scrollbar issues */
    max-width: 100%;
    
    /* Zen spacing */
    padding: var(--zen-space-xl);
    gap: var(--zen-space-xs);
}

/* Instant loading feedback with zen styling */
.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(250, 250, 250, 0.9);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: var(--zen-space-lg);
    z-index: 100;
    color: var(--zen-text-tertiary);
    
    /* Instant appearance */
    animation: fadeInFast 150ms ease-out;
}

@keyframes fadeInFast {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Responsive header elements */
.app-header {
    transition: background-color 150ms ease;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}

.app-header.loading {
    background-color: rgba(248, 249, 250, 0.95);
}

/* Fast loading spinner with zen design */
.loading-spinner {
    width: 1.5rem;
    height: 1.5rem;
    border: 2px solid var(--zen-border);
    border-top: 2px solid var(--zen-primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    
    /* Smooth animation */
    transform-origin: center;
    will-change: transform;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Instant visual feedback for navigation */
.nav-segment, .sidebar-item {
    transition: all 150ms ease;
    cursor: pointer;
    border-radius: var(--zen-radius);
}

.nav-segment:hover, .sidebar-item:hover:not(.active) {
    background-color: var(--zen-surface-hover);
    color: var(--zen-text-primary);
    transform: translateX(2px);
}

.nav-segment:active, .sidebar-item:active:not(.active) {
    transform: translateX(1px);
    background-color: var(--zen-surface-active);
}

/* Enhanced active sidebar item hover feedback */
.sidebar-item.active:hover {
    background-color: var(--zen-primary-alpha-hover);
    transform: translateX(2px);
}

.sidebar-item.active:active {
    background-color: var(--zen-primary-alpha);
    transform: translateX(1px);
}

/* File item hover effects for instant feedback */
.file-item {
    transition: all 150ms ease;
    cursor: pointer;
    border-radius: var(--zen-radius-md);
    min-height: 3.5rem;
    padding: var(--zen-space-lg);
    border: 1px solid transparent;
}

.file-item:hover:not(.selected) {
    background-color: var(--zen-surface-hover);
    border-color: var(--zen-border);
    transform: translateY(-1px);
    box-shadow: var(--zen-shadow-sm);
}

.file-item:active:not(.selected) {
    background-color: var(--zen-surface-active);
    transform: translateY(0);
    box-shadow: none;
}

/* Selected state with zen styling */
.file-item.selected {
    background-color: var(--zen-primary-alpha);
    border-color: var(--zen-primary);
    color: var(--zen-primary);
    transform: translateY(-1px);
    box-shadow: var(--zen-shadow);
}

/* Enhanced selected state hover feedback */
.file-item.selected:hover {
    background-color: var(--zen-primary-alpha-hover);
    border-color: var(--zen-primary);
    transform: translateY(-2px);
    box-shadow: var(--zen-shadow-md);
}

.file-item.selected:active {
    background-color: var(--zen-primary-alpha);
    border-color: var(--zen-primary);
    transform: scale(0.98);
}

/* Optimized breadcrumb transitions */
.nav-breadcrumb {
    /* Smooth scrolling for long paths */
    scroll-behavior: smooth;
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;
    scrollbar-width: none;
    -ms-overflow-style: none;
    
    /* Zen spacing */
    padding: var(--zen-space-lg) var(--zen-space-xl);
    background: var(--zen-surface);
    border-bottom: 1px solid var(--zen-border-light);
}

.nav-breadcrumb::-webkit-scrollbar {
    display: none;
}

/* Toolbar button responsiveness */
.toolbar-btn {
    transition: all 150ms ease;
    border-radius: var(--zen-radius);
    padding: var(--zen-space-sm) var(--zen-space-lg);
    border: 1px solid var(--zen-border);
    background: transparent;
    color: var(--zen-text-secondary);
    min-height: 2.25rem;
}

.toolbar-btn:hover:not(:disabled) {
    background-color: var(--zen-surface-hover);
    border-color: var(--zen-border-focus);
    color: var(--zen-text-primary);
    transform: translateY(-1px);
    box-shadow: var(--zen-shadow-sm);
}

.toolbar-btn:active:not(:disabled) {
    transform: translateY(0);
    background-color: var(--zen-surface-active);
    box-shadow: none;
}

.toolbar-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Context menu instant appearance with zen styling */
.context-menu {
    animation: contextMenuAppear 150ms ease-out;
    transform-origin: top left;
    background: var(--zen-surface);
    border: 1px solid var(--zen-border);
    border-radius: var(--zen-radius-md);
    box-shadow: var(--zen-shadow-lg);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    padding: var(--zen-space-sm);
}

@keyframes contextMenuAppear {
    from {
        opacity: 0;
        transform: scale(0.95) translateY(-5px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

/* Status bar with zen styling */
.status-bar {
    transition: background-color 150ms ease;
    background: var(--zen-surface);
    border-top: 1px solid var(--zen-border-light);
    color: var(--zen-text-secondary);
    font-size: var(--zen-text-xs);
    padding: var(--zen-space-md) var(--zen-space-xl);
}

/* Error message with zen styling */
.error-message {
    animation: slideInFromTop 200ms ease-out;
    background: rgba(220, 38, 38, 0.1);
    border-left: 4px solid var(--zen-error);
    color: var(--zen-error);
    border-radius: var(--zen-radius);
    margin: var(--zen-space-lg);
    padding: var(--zen-space-lg) var(--zen-space-xl);
}

@keyframes slideInFromTop {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
    .loading-overlay {
        background: rgba(26, 35, 50, 0.9);
    }
    
    .app-header.loading {
        background-color: rgba(26, 35, 50, 0.95);
    }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
    }
    
    .loading-spinner {
        animation: none;
    }
} 

================================================
File: backend/filesystem_stream.go
================================================
//go:build windows

package backend

import (
	"os"
	"path/filepath"
	"strings"
	"syscall"
)

// BasicEntry holds minimal info for instant UI rendering
type BasicEntry struct {
	Name      string `json:"name"`
	Path      string `json:"path"`
	IsDir     bool   `json:"isDir"`
	Extension string `json:"extension"`
	IsHidden  bool   `json:"isHidden"`
}

// HydratedEntry holds complete file information for background processing
type HydratedEntry struct {
	BasicEntry
	Size        int64  `json:"size"`
	ModTime     int64  `json:"modTime"` // Unix timestamp for faster JSON serialization
	Permissions string `json:"permissions"`
}

// listDirectoryBasic uses Win32 FindFirstFileExW to get Name+Attrs in one syscall
// This is significantly faster than os.ReadDir + per-file stat calls
func listDirectoryBasic(dir string) ([]BasicEntry, error) {
	search := filepath.Join(dir, "*")
	searchPtr, err := syscall.UTF16PtrFromString(search)
	if err != nil {
		return nil, err
	}

	var fd syscall.Win32finddata
	handle, err := syscall.FindFirstFile(searchPtr, &fd)
	if err != nil {
		return nil, err
	}
	defer syscall.FindClose(handle)

	// Pre-allocate with reasonable capacity
	entries := make([]BasicEntry, 0, 64)

	for {
		name := syscall.UTF16ToString(fd.FileName[:])

		// Skip current and parent directory entries
		if name == "." || name == ".." {
			err = syscall.FindNextFile(handle, &fd)
			if err != nil {
				if err == syscall.ERROR_NO_MORE_FILES {
					break
				}
				return entries, err // Return partial results on error
			}
			continue
		}

		// Extract file attributes from Win32 data
		attr := fd.FileAttributes
		isDir := attr&syscall.FILE_ATTRIBUTE_DIRECTORY != 0
		isHidden := attr&syscall.FILE_ATTRIBUTE_HIDDEN != 0 ||
			attr&syscall.FILE_ATTRIBUTE_SYSTEM != 0

		// Get extension for files only
		var ext string
		if !isDir {
			ext = strings.ToLower(strings.TrimPrefix(filepath.Ext(name), "."))
		}

		entry := BasicEntry{
			Name:      name,
			Path:      filepath.Join(dir, name),
			IsDir:     isDir,
			IsHidden:  isHidden,
			Extension: ext,
		}

		entries = append(entries, entry)

		err = syscall.FindNextFile(handle, &fd)
		if err != nil {
			if err == syscall.ERROR_NO_MORE_FILES {
				break
			}
			return entries, err // Return partial results on error
		}
	}

	return entries, nil
}

// listDirectoryBasicFallback provides fallback for non-Windows systems
func listDirectoryBasicFallback(dir string, platform PlatformManagerInterface) ([]BasicEntry, error) {
	// Use os package for cross-platform compatibility
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	basic := make([]BasicEntry, 0, len(entries))
	for _, entry := range entries {
		name := entry.Name()
		fullPath := filepath.Join(dir, name)

		// Use entry.Info() to get file info
		info, err := entry.Info()
		if err != nil {
			continue // Skip files we can't stat
		}

		isDir := info.IsDir()
		isHidden := platform.IsHidden(fullPath)

		var ext string
		if !isDir && len(name) > 0 {
			ext = strings.ToLower(strings.TrimPrefix(filepath.Ext(name), "."))
		}

		basic = append(basic, BasicEntry{
			Name:      name,
			Path:      fullPath,
			IsDir:     isDir,
			IsHidden:  isHidden,
			Extension: ext,
		})
	}

	return basic, nil
}


================================================
File: backend/drives.go
================================================
package backend

import (
	"fmt"
	"log"
	"os"
	"runtime"
)

// NewDriveManager creates a new drive manager instance
func NewDriveManager() *DriveManager {
	return &DriveManager{}
}

// GetDriveInfo returns information about available drives
func (d *DriveManager) GetDriveInfo() []DriveInfo {
	var drives []DriveInfo

	switch runtime.GOOS {
	case "windows":
		drives = d.getWindowsDrives()
	case "darwin":
		drives = d.getMacVolumes()
	case "linux":
		drives = d.getLinuxMountPoints()
	default:
		log.Printf("Drive enumeration not supported on %s", runtime.GOOS)
	}

	return drives
}

// getWindowsDrives returns Windows drive information
func (d *DriveManager) getWindowsDrives() []DriveInfo {
	var drives []DriveInfo

	for i := 'A'; i <= 'Z'; i++ {
		drive := fmt.Sprintf("%c:\\", i)
		if _, err := os.Stat(drive); err == nil {
			driveInfo := DriveInfo{
				Path:   drive,
				Letter: string(i),
				Name:   fmt.Sprintf("Drive %c:", i),
			}

			// Try to get more detailed drive information
			if driveType := d.getWindowsDriveType(drive); driveType != "" {
				driveInfo.Name = fmt.Sprintf("%s (%s)", driveInfo.Name, driveType)
			}

			drives = append(drives, driveInfo)
		}
	}

	return drives
}

// getWindowsDriveType gets the type of Windows drive (if possible)
func (d *DriveManager) getWindowsDriveType(drive string) string {
	// This is a simplified implementation
	// In a more advanced version, you could use Windows API calls
	// to get detailed drive information like volume labels, types, etc.

	// For now, we'll just return empty string
	// Future enhancement: Use syscalls to get actual drive type
	return ""
}

// getMacVolumes returns macOS volume information
func (d *DriveManager) getMacVolumes() []DriveInfo {
	var drives []DriveInfo

	// Add root volume
	drives = append(drives, DriveInfo{
		Path:   "/",
		Letter: "",
		Name:   "Macintosh HD",
	})

	// Add /Volumes if it exists
	if _, err := os.Stat("/Volumes"); err == nil {
		if entries, err := os.ReadDir("/Volumes"); err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					volumePath := fmt.Sprintf("/Volumes/%s", entry.Name())
					drives = append(drives, DriveInfo{
						Path:   volumePath,
						Letter: "",
						Name:   entry.Name(),
					})
				}
			}
		}
	}

	return drives
}

// getLinuxMountPoints returns Linux mount point information
func (d *DriveManager) getLinuxMountPoints() []DriveInfo {
	var drives []DriveInfo

	// Add root filesystem
	drives = append(drives, DriveInfo{
		Path:   "/",
		Letter: "",
		Name:   "Root Filesystem",
	})

	// Add common mount points
	commonMounts := []struct {
		path string
		name string
	}{
		{"/home", "Home"},
		{"/media", "Media"},
		{"/mnt", "Mount"},
		{"/opt", "Optional"},
		{"/usr", "User Programs"},
		{"/var", "Variable Data"},
	}

	for _, mount := range commonMounts {
		if _, err := os.Stat(mount.path); err == nil {
			drives = append(drives, DriveInfo{
				Path:   mount.path,
				Letter: "",
				Name:   mount.name,
			})
		}
	}

	return drives
}

// GetSystemRoots returns system root paths for quick navigation
func (d *DriveManager) GetSystemRoots() []string {
	var roots []string

	switch runtime.GOOS {
	case "windows":
		// Get all available drive letters
		for i := 'A'; i <= 'Z'; i++ {
			drive := fmt.Sprintf("%c:\\", i)
			if _, err := os.Stat(drive); err == nil {
				roots = append(roots, drive)
			}
		}
	default:
		// Unix-like systems start from root
		roots = append(roots, "/")
	}

	return roots
}

// GetQuickAccessPaths returns commonly accessed directories for quick navigation
func (d *DriveManager) GetQuickAccessPaths() []DriveInfo {
	var quickPaths []DriveInfo

	switch runtime.GOOS {
	case "windows":
		quickPaths = d.getWindowsQuickAccess()
	case "darwin":
		quickPaths = d.getMacQuickAccess()
	case "linux":
		quickPaths = d.getLinuxQuickAccess()
	}

	return quickPaths
}

// getWindowsQuickAccess returns Windows quick access paths
func (d *DriveManager) getWindowsQuickAccess() []DriveInfo {
	var quickPaths []DriveInfo

	// Get common Windows directories
	homeDir, _ := os.UserHomeDir()

	commonPaths := []struct {
		path string
		name string
	}{
		{homeDir, "Home"},
		{fmt.Sprintf("%s\\Desktop", homeDir), "Desktop"},
		{fmt.Sprintf("%s\\Documents", homeDir), "Documents"},
		{fmt.Sprintf("%s\\Downloads", homeDir), "Downloads"},
		{fmt.Sprintf("%s\\Pictures", homeDir), "Pictures"},
		{fmt.Sprintf("%s\\Music", homeDir), "Music"},
		{fmt.Sprintf("%s\\Videos", homeDir), "Videos"},
		{"C:\\Program Files", "Program Files"},
		{"C:\\Program Files (x86)", "Program Files (x86)"},
		{"C:\\Windows", "Windows"},
	}

	for _, path := range commonPaths {
		if _, err := os.Stat(path.path); err == nil {
			quickPaths = append(quickPaths, DriveInfo{
				Path:   path.path,
				Letter: "",
				Name:   path.name,
			})
		}
	}

	return quickPaths
}

// getMacQuickAccess returns macOS quick access paths
func (d *DriveManager) getMacQuickAccess() []DriveInfo {
	var quickPaths []DriveInfo

	homeDir, _ := os.UserHomeDir()

	commonPaths := []struct {
		path string
		name string
	}{
		{homeDir, "Home"},
		{fmt.Sprintf("%s/Desktop", homeDir), "Desktop"},
		{fmt.Sprintf("%s/Documents", homeDir), "Documents"},
		{fmt.Sprintf("%s/Downloads", homeDir), "Downloads"},
		{fmt.Sprintf("%s/Pictures", homeDir), "Pictures"},
		{fmt.Sprintf("%s/Music", homeDir), "Music"},
		{fmt.Sprintf("%s/Movies", homeDir), "Movies"},
		{"/Applications", "Applications"},
		{"/System", "System"},
		{"/Users", "Users"},
	}

	for _, path := range commonPaths {
		if _, err := os.Stat(path.path); err == nil {
			quickPaths = append(quickPaths, DriveInfo{
				Path:   path.path,
				Letter: "",
				Name:   path.name,
			})
		}
	}

	return quickPaths
}

// getLinuxQuickAccess returns Linux quick access paths
func (d *DriveManager) getLinuxQuickAccess() []DriveInfo {
	var quickPaths []DriveInfo

	homeDir, _ := os.UserHomeDir()

	commonPaths := []struct {
		path string
		name string
	}{
		{homeDir, "Home"},
		{fmt.Sprintf("%s/Desktop", homeDir), "Desktop"},
		{fmt.Sprintf("%s/Documents", homeDir), "Documents"},
		{fmt.Sprintf("%s/Downloads", homeDir), "Downloads"},
		{fmt.Sprintf("%s/Pictures", homeDir), "Pictures"},
		{fmt.Sprintf("%s/Music", homeDir), "Music"},
		{fmt.Sprintf("%s/Videos", homeDir), "Videos"},
		{"/usr", "User Programs"},
		{"/opt", "Optional Software"},
		{"/etc", "Configuration"},
		{"/var", "Variable Data"},
	}

	for _, path := range commonPaths {
		if _, err := os.Stat(path.path); err == nil {
			quickPaths = append(quickPaths, DriveInfo{
				Path:   path.path,
				Letter: "",
				Name:   path.name,
			})
		}
	}

	return quickPaths
}


================================================
File: frontend/src/components/FileIcon.jsx
================================================
import { useState, useEffect } from 'preact/hooks';

const FileIcon = ({ file, className = "" }) => {
    const [iconType, setIconType] = useState('file');
    
    useEffect(() => {
        if (file.isDir) {
            setIconType('folder');
        } else {
            const ext = file.extension?.toLowerCase();
            
            // Image files
            if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp', 'ico'].includes(ext)) {
                setIconType('image');
            }
            // Code files
            else if (['js', 'jsx', 'ts', 'tsx', 'py', 'go', 'java', 'cpp', 'c', 'h', 'css', 'html', 'json', 'xml', 'yaml', 'yml'].includes(ext)) {
                setIconType('code');
            }
            // Text files
            else if (['txt', 'md', 'rst', 'log', 'csv'].includes(ext)) {
                setIconType('text');
            }
            // Archive files
            else if (['zip', 'rar', '7z', 'tar', 'gz', 'bz2'].includes(ext)) {
                setIconType('archive');
            }
            // Executable files
            else if (['exe', 'msi', 'app', 'deb', 'rpm'].includes(ext)) {
                setIconType('executable');
            }
            else {
                setIconType('file');
            }
        }
    }, [file]);
    
    const getIconSymbol = () => {
        switch (iconType) {
            case 'folder':
                return 'üìÅ';
            case 'image':
                return 'üñºÔ∏è';
            case 'code':
                return '‚ö°';
            case 'text':
                return 'üìÑ';
            case 'archive':
                return 'üì¶';
            case 'executable':
                return '‚öôÔ∏è';
            default:
                return 'üìÑ';
        }
    };
    
    const getFileTypeLabel = () => {
        if (file.isDir) return 'DIR';
        if (file.extension) return file.extension.toUpperCase();
        return 'FILE';
    };
    
    return (
        <div className={`file-icon ${iconType} ${className}`} title={file.name}>
            <span className="text-xs">{getFileTypeLabel()}</span>
        </div>
    );
};

export default FileIcon; 

================================================
File: backend/terminal.go
================================================
package backend

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"syscall"
)

// NewTerminalManager creates a new terminal manager instance
func NewTerminalManager() *TerminalManager {
	return &TerminalManager{}
}

// OpenPowerShellHere opens PowerShell 7 in the specified directory
func (t *TerminalManager) OpenPowerShellHere(directoryPath string) bool {
	log.Printf("Opening PowerShell 7 in directory: %s", directoryPath)

	// Validate the directory path
	if directoryPath == "" {
		log.Printf("Error: Empty directory path provided")
		return false
	}

	// Check if directory exists
	if _, err := os.Stat(directoryPath); os.IsNotExist(err) {
		log.Printf("Error: Directory does not exist: %s", directoryPath)
		return false
	}

	return t.openWindowsTerminal(directoryPath)
}

// OpenTerminalHere opens the system's default terminal in the specified directory
func (t *TerminalManager) OpenTerminalHere(directoryPath string) bool {
	log.Printf("Opening terminal in directory: %s", directoryPath)

	// Validate the directory path
	if directoryPath == "" {
		log.Printf("Error: Empty directory path provided")
		return false
	}

	// Check if directory exists
	if _, err := os.Stat(directoryPath); os.IsNotExist(err) {
		log.Printf("Error: Directory does not exist: %s", directoryPath)
		return false
	}

	switch runtime.GOOS {
	case "windows":
		return t.openWindowsTerminal(directoryPath)
	case "darwin":
		return t.openMacTerminal(directoryPath)
	case "linux":
		return t.openLinuxTerminal(directoryPath)
	default:
		log.Printf("Unsupported operating system: %s", runtime.GOOS)
		return false
	}
}

// openWindowsTerminal opens PowerShell in Windows
func (t *TerminalManager) openWindowsTerminal(directoryPath string) bool {
	// PowerShell 7 executable path
	pwshPath := "C:\\Program Files\\PowerShell\\7\\pwsh.exe"

	// Check if PowerShell 7 exists, fallback to Windows PowerShell if not
	if _, err := os.Stat(pwshPath); os.IsNotExist(err) {
		log.Printf("PowerShell 7 not found, falling back to Windows PowerShell")
		pwshPath = "powershell.exe"
	}

	log.Printf("Using PowerShell executable: %s", pwshPath)

	// Use the most reliable method: -NoExit without -Command, just set working directory
	cmd := exec.Command(pwshPath, "-NoExit")

	// Set the working directory for the process - this is the key!
	cmd.Dir = directoryPath

	// Create new console window that stays open
	cmd.SysProcAttr = &syscall.SysProcAttr{
		HideWindow:    false,      // We want to show PowerShell window
		CreationFlags: 0x00000010, // CREATE_NEW_CONSOLE - create new console window
	}

	log.Printf("PowerShell command: %s %v in directory: %s", pwshPath, cmd.Args[1:], directoryPath)

	// Start the command
	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening PowerShell: %v", err)
		return false
	}

	log.Printf("Successfully opened PowerShell in directory: %s", directoryPath)
	return true
}

// openMacTerminal opens Terminal in macOS
func (t *TerminalManager) openMacTerminal(directoryPath string) bool {
	// macOS: Open Terminal with the specified directory
	cmd := exec.Command("osascript", "-e", fmt.Sprintf(`tell app "Terminal" to do script "cd '%s'"`, directoryPath))

	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening macOS Terminal: %v", err)
		return false
	}

	log.Printf("Successfully opened Terminal in directory: %s", directoryPath)
	return true
}

// openLinuxTerminal opens terminal in Linux
func (t *TerminalManager) openLinuxTerminal(directoryPath string) bool {
	// Linux: Try to open terminal in the directory
	// Try different terminal emulators in order of preference
	terminals := [][]string{
		{"gnome-terminal", "--working-directory", directoryPath},
		{"konsole", "--workdir", directoryPath},
		{"xfce4-terminal", "--working-directory", directoryPath},
		{"xterm", "-e", fmt.Sprintf("cd '%s' && bash", directoryPath)},
		{"urxvt", "-e", fmt.Sprintf("bash -c 'cd \"%s\" && bash'", directoryPath)},
		{"terminator", "--working-directory", directoryPath},
	}

	for _, terminalCmd := range terminals {
		if _, err := exec.LookPath(terminalCmd[0]); err == nil {
			cmd := exec.Command(terminalCmd[0], terminalCmd[1:]...)
			err := cmd.Start()
			if err == nil {
				log.Printf("Successfully opened %s in directory: %s", terminalCmd[0], directoryPath)
				return true
			}
			log.Printf("Failed to open %s: %v", terminalCmd[0], err)
		}
	}

	log.Printf("No suitable terminal emulator found")
	return false
}

// OpenCommandPromptHere opens Command Prompt in Windows (alternative to PowerShell)
func (t *TerminalManager) OpenCommandPromptHere(directoryPath string) bool {
	if runtime.GOOS != "windows" {
		log.Printf("Command Prompt is only available on Windows")
		return false
	}

	log.Printf("Opening Command Prompt in directory: %s", directoryPath)

	// Validate the directory path
	if directoryPath == "" {
		log.Printf("Error: Empty directory path provided")
		return false
	}

	// Check if directory exists
	if _, err := os.Stat(directoryPath); os.IsNotExist(err) {
		log.Printf("Error: Directory does not exist: %s", directoryPath)
		return false
	}

	// Open Command Prompt with specific directory
	cmd := exec.Command("cmd.exe", "/K", fmt.Sprintf("cd /d \"%s\"", directoryPath))

	// Create new console window
	cmd.SysProcAttr = &syscall.SysProcAttr{
		HideWindow:    false,
		CreationFlags: 0x00000010, // CREATE_NEW_CONSOLE
	}

	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening Command Prompt: %v", err)
		return false
	}

	log.Printf("Successfully opened Command Prompt in directory: %s", directoryPath)
	return true
}

// OpenWindowsTerminalApp opens Windows Terminal app (if available)
func (t *TerminalManager) OpenWindowsTerminalApp(directoryPath string) bool {
	if runtime.GOOS != "windows" {
		log.Printf("Windows Terminal is only available on Windows")
		return false
	}

	log.Printf("Opening Windows Terminal app in directory: %s", directoryPath)

	// Check if Windows Terminal is available
	cmd := exec.Command("wt.exe", "-d", directoryPath)

	err := cmd.Start()
	if err != nil {
		log.Printf("Windows Terminal not available, error: %v", err)
		// Fallback to PowerShell
		return t.openWindowsTerminal(directoryPath)
	}

	log.Printf("Successfully opened Windows Terminal app in directory: %s", directoryPath)
	return true
}

// GetAvailableTerminals returns a list of available terminal applications
func (t *TerminalManager) GetAvailableTerminals() []string {
	var terminals []string

	switch runtime.GOOS {
	case "windows":
		// Check for Windows terminals
		windowsTerminals := []struct {
			path string
			name string
		}{
			{"C:\\Program Files\\PowerShell\\7\\pwsh.exe", "PowerShell 7"},
			{"powershell.exe", "Windows PowerShell"},
			{"cmd.exe", "Command Prompt"},
			{"wt.exe", "Windows Terminal"},
		}

		for _, term := range windowsTerminals {
			if term.name == "Windows Terminal" {
				// Special check for Windows Terminal using wt.exe
				if _, err := exec.LookPath("wt.exe"); err == nil {
					terminals = append(terminals, term.name)
				}
			} else if _, err := os.Stat(term.path); err == nil || term.name == "Windows PowerShell" || term.name == "Command Prompt" {
				terminals = append(terminals, term.name)
			}
		}

	case "darwin":
		// macOS terminals
		terminals = append(terminals, "Terminal")

		// Check for additional terminals
		macTerminals := []string{"iTerm", "Hyper", "Alacritty"}
		for _, term := range macTerminals {
			if _, err := exec.LookPath(strings.ToLower(term)); err == nil {
				terminals = append(terminals, term)
			}
		}

	case "linux":
		// Linux terminals
		linuxTerminals := []string{
			"gnome-terminal", "konsole", "xfce4-terminal", "xterm",
			"urxvt", "terminator", "alacritty", "kitty", "tilix",
		}

		for _, term := range linuxTerminals {
			if _, err := exec.LookPath(term); err == nil {
				terminals = append(terminals, term)
			}
		}
	}

	return terminals
}

// ExecuteCommand executes a command in the background (useful for scripts)
func (t *TerminalManager) ExecuteCommand(command string, workingDir string) error {
	log.Printf("Executing command: %s in directory: %s", command, workingDir)

	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "windows":
		cmd = exec.Command("cmd", "/C", command)
	default:
		cmd = exec.Command("sh", "-c", command)
	}

	if workingDir != "" {
		cmd.Dir = workingDir
	}

	// Run the command and capture output
	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("Command execution failed: %v, output: %s", err, string(output))
		return err
	}

	log.Printf("Command executed successfully, output: %s", string(output))
	return nil
}


================================================
File: .gitignore
================================================
build/*
node_modules
frontend/dist
frontend/bun.lock
frontend/package-lock.json

================================================
File: frontend/src/components/FileItem.jsx
================================================
import { useMemo, useCallback, useRef, useEffect } from "preact/hooks";
import { memo } from "preact/compat";
import { getFileIcon, getFileType } from "../utils/fileUtils.js";
import { formatDate, formatFileSize } from "../utils/formatUtils.js";
import { log, error } from "../utils/logger";

// Memoized File item component
const FileItem = memo(({ 
    file, 
    onSelect, 
    onOpen, 
    isLoading, 
    isSelected, 
    fileIndex, 
    isCut, 
    onContextMenu, 
    onDragStart, 
    onDragOver, 
    onDragEnter, 
    onDragLeave, 
    onDrop, 
    isDragOver,

}) => {
    const icon = useMemo(() => getFileIcon(file.name, file.isDir), [file.name, file.isDir]);
    const type = useMemo(() => getFileType(file.name, file.isDir), [file.name, file.isDir]);
    
    // Refs for click timing and debouncing
    const clickTimeoutRef = useRef(null);
    const lastOpenTimeRef = useRef(0);
    const clickCountRef = useRef(0);
    
    // Configuration for click timing - Made configurable for performance tuning
    const INSTANT_MODE = false; // Set to true for zero-latency mode (disables double-click protection)
    const DOUBLE_CLICK_DELAY = INSTANT_MODE ? 0 : 300; // ms to wait for potential double-click (Windows standard)
    const OPEN_COOLDOWN = INSTANT_MODE ? 100 : 500; // ms cooldown between opens to prevent rapid-fire
    const PERFORMANCE_LOGGING = false; // Set to true to enable performance logs
    
    const handleClick = useCallback((event) => {
        const clickStartTime = PERFORMANCE_LOGGING ? performance.now() : 0;
        log('üìã File clicked:', file.name, 'Path:', file.path, 'IsDir:', file.isDir, 'IsSelected:', isSelected);
        
        if (isLoading) return;
        
        const now = Date.now();
        clickCountRef.current += 1;
        
        // Clear any existing timeout
        if (clickTimeoutRef.current) {
            clearTimeout(clickTimeoutRef.current);
            clickTimeoutRef.current = null;
        }
        
        // Check if this is too soon after last open (cooldown protection)
        if (now - lastOpenTimeRef.current < OPEN_COOLDOWN) {
            log('üõ°Ô∏è Open cooldown active, ignoring click');
            clickCountRef.current = 0;
            return;
        }
        
        // Handle immediate actions (with modifier keys or unselected files)
        if (event.shiftKey || event.ctrlKey || event.metaKey || !isSelected) {
            log('üñ±Ô∏è Processing selection for:', file.name);
            if (PERFORMANCE_LOGGING) {
                log(`‚ö° Immediate response: ${(performance.now() - clickStartTime).toFixed(2)}ms`);
            }
            onSelect(fileIndex, event.shiftKey, event.ctrlKey || event.metaKey);
            clickCountRef.current = 0;
            return;
        }
        
        // For selected files without modifier keys, wait to see if it's a double-click
        if (PERFORMANCE_LOGGING) {
            log(`‚è±Ô∏è Delaying open by ${DOUBLE_CLICK_DELAY}ms to detect double-click`);
        }
        
        clickTimeoutRef.current = setTimeout(() => {
            if (clickCountRef.current === 1) {
                // Single click on selected file - open it
                log('üöÄ Single click confirmed, opening:', file.name);
                if (PERFORMANCE_LOGGING) {
                    log(`‚ö° Delayed open executed: ${(performance.now() - clickStartTime).toFixed(2)}ms total`);
                }
                lastOpenTimeRef.current = Date.now();
                onOpen(file);
            }
            clickCountRef.current = 0;
        }, DOUBLE_CLICK_DELAY);
    }, [file, isLoading, isSelected, fileIndex, onOpen, onSelect]);
    
    const handleDoubleClick = useCallback((event) => {
        log('üîç File double-clicked:', file.name, 'Path:', file.path, 'IsDir:', file.isDir);
        
        if (isLoading) return;
        
        const now = Date.now();
        
        // Clear single-click timeout since this is a double-click
        if (clickTimeoutRef.current) {
            clearTimeout(clickTimeoutRef.current);
            clickTimeoutRef.current = null;
        }
        
        // Check cooldown
        if (now - lastOpenTimeRef.current < OPEN_COOLDOWN) {
            log('üõ°Ô∏è Open cooldown active, ignoring double-click');
            clickCountRef.current = 0;
            return;
        }
        
        // Double click always opens, regardless of selection state
        log('üöÄ Double-click confirmed, opening:', file.name);
        lastOpenTimeRef.current = now;
        clickCountRef.current = 0;
        onOpen(file);
    }, [file, isLoading, onOpen]);
    
    // Cleanup timeout on unmount
    useEffect(() => {
        return () => {
            if (clickTimeoutRef.current) {
                clearTimeout(clickTimeoutRef.current);
            }
        };
    }, []);
    
    const handleRightClick = useCallback((event) => {
        event.preventDefault();
        log('üñ±Ô∏è Right-click on:', file.name, 'IsSelected:', isSelected);
        
        if (!isLoading) {
            // If file is not selected, select it first
            if (!isSelected) {
                onSelect(fileIndex, false, false);
            }
            
            // Show context menu
            onContextMenu(event, file);
        }
    }, [file, isLoading, isSelected, fileIndex, onSelect, onContextMenu]);
    
    const handleDragStart = useCallback((event) => {
        if (isLoading) {
            event.preventDefault();
            return;
        }
        
        // If the dragged item is not selected, select it first
        if (!isSelected) {
            onSelect(fileIndex, false, false);
        }
        
        if (onDragStart) {
            onDragStart(event, file);
        }
    }, [isLoading, isSelected, fileIndex, file, onSelect, onDragStart]);
    
    const handleDragOver = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        event.preventDefault();
        event.dataTransfer.dropEffect = event.ctrlKey ? 'copy' : 'move';
        
        if (onDragOver) {
            onDragOver(event, file);
        }
    }, [file.isDir, isLoading, onDragOver, file]);
    
    const handleDragEnter = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        event.preventDefault();
        if (onDragEnter) {
            onDragEnter(event, file);
        }
    }, [file.isDir, isLoading, onDragEnter, file]);
    
    const handleDragLeave = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        if (onDragLeave) {
            onDragLeave(event, file);
        }
    }, [file.isDir, isLoading, onDragLeave, file]);
    
    const handleDrop = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        event.preventDefault();
        
        try {
            const dragData = JSON.parse(event.dataTransfer.getData('application/json'));
            log('üìÇ Drop on folder:', file.name, 'Items:', dragData.files?.length, 'Operation:', dragData.operation);
            
            if (onDrop) {
                onDrop(event, file, dragData);
            }
        } catch (err) {
            error('‚ùå Error parsing drag data:', err);
        }
    }, [file, isLoading, onDrop]);
    

    
    return (
        <div 
            className={`file-item ${isSelected ? 'selected' : ''} ${isLoading ? 'disabled' : ''} ${isCut ? 'cut' : ''} ${isDragOver ? 'drag-over' : ''}`}
            onClick={handleClick}
            onDoubleClick={handleDoubleClick}
            onContextMenu={handleRightClick}
            onSelectStart={(e) => e.preventDefault()}
            draggable={!isLoading}
            onDragStart={handleDragStart}
            onDragOver={handleDragOver}
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
            style={{ 
                cursor: isLoading ? 'wait' : 'pointer',
                opacity: isLoading ? 0.7 : (isCut ? 0.5 : 1) 
            }}
        >
            <div className={`file-icon ${type}`}>
                {icon}
            </div>
            <div className="file-details">
                <div className="file-name">{file.name}</div>
                <div className="file-meta">
                    {file.isDir ? (
                        <span>DIR</span>
                    ) : (
                        <>
                            <span>{formatFileSize(file.size)}</span>
                            <span>{formatDate(file.modTime)}</span>
                        </>
                    )}
                </div>
            </div>
        </div>
    );
});

export { FileItem };
export default FileItem; 

================================================
File: frontend/src/components/RetroDialog.jsx
================================================
import { useState, useRef, useEffect, useCallback } from "preact/hooks";
import { memo } from "preact/compat";

// Memoized 8-bit Dialog Component
const RetroDialog = memo(({ isOpen, type, title, message, defaultValue, onConfirm, onCancel, onClose }) => {
    const [inputValue, setInputValue] = useState(defaultValue || '');
    const inputRef = useRef(null);
    
    useEffect(() => {
        setInputValue(defaultValue || '');
    }, [defaultValue]);
    
    useEffect(() => {
        if (isOpen && type === 'prompt' && inputRef.current) {
            inputRef.current.focus();
            inputRef.current.select();
        }
    }, [isOpen, type]);
    
    useEffect(() => {
        const handleKeyDown = (e) => {
            if (!isOpen) return;
            
            if (e.key === 'Escape') {
                onCancel();
            } else if (e.key === 'Enter') {
                if (type === 'prompt') {
                    onConfirm(inputValue);
                } else {
                    onConfirm();
                }
            }
        };
        
        if (isOpen) {
            document.addEventListener('keydown', handleKeyDown);
            return () => document.removeEventListener('keydown', handleKeyDown);
        }
    }, [isOpen, type, inputValue, onConfirm, onCancel]);
    
    const handleInputChange = useCallback((e) => {
        setInputValue(e.target.value);
    }, []);
    
    const handleConfirm = useCallback(() => {
        if (type === 'prompt') {
            onConfirm(inputValue);
        } else {
            onConfirm();
        }
    }, [type, inputValue, onConfirm]);
    
    if (!isOpen) return null;
    
    return (
        <div className="retro-dialog-overlay" onSelectStart={(e) => e.preventDefault()}>
            <div className={`retro-dialog ${type === 'prompt' ? 'prompt-type' : ''} ${type === 'delete' ? 'delete-type' : ''}`} onSelectStart={(e) => e.preventDefault()}>
                {/* Dialog header */}
                <div className="retro-dialog-header">
                    <div className="retro-dialog-title">{title || 'SYSTEM MESSAGE'}</div>
                    <button 
                        className="retro-dialog-close"
                        onClick={onCancel}
                        title="CLOSE [ESC]"
                    >
                        ‚úï
                    </button>
                </div>
                
                {/* Dialog content */}
                <div className="retro-dialog-content">
                    <div className="retro-dialog-icon">
                        {type === 'confirm' && '‚ö†Ô∏è'}
                        {type === 'prompt' && '‚úèÔ∏è'}
                        {type === 'alert' && '‚ÑπÔ∏è'}
                        {type === 'error' && '‚ùå'}
                        {type === 'success' && '‚úÖ'}
                        {type === 'delete' && 'üóëÔ∏è'}
                    </div>
                    <div className="retro-dialog-message">
                        {message.split('\n').map((line, index) => (
                            <div key={index}>{line}</div>
                        ))}
                    </div>
                    
                    {type === 'prompt' && (
                        <div className="retro-dialog-input-container">
                            <input
                                ref={inputRef}
                                type="text"
                                value={inputValue}
                                onChange={handleInputChange}
                                className="retro-dialog-input"
                                placeholder="ENTER VALUE..."
                            />
                        </div>
                    )}
                </div>
                
                {/* Dialog buttons */}
                <div className="retro-dialog-buttons">
                    {type === 'prompt' ? (
                        <>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-primary"
                                onClick={handleConfirm}
                            >
                                [ENTER] CONFIRM
                            </button>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-secondary"
                                onClick={onCancel}
                            >
                                [ESC] CANCEL
                            </button>
                        </>
                    ) : type === 'confirm' || type === 'delete' ? (
                        <>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-primary"
                                onClick={handleConfirm}
                            >
                                [ENTER] YES
                            </button>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-secondary"
                                onClick={onCancel}
                            >
                                [ESC] NO
                            </button>
                        </>
                    ) : (
                        <button 
                            className="retro-dialog-btn retro-dialog-btn-primary"
                            onClick={handleConfirm}
                        >
                            [ENTER] OK
                        </button>
                    )}
                </div>
            </div>
        </div>
    );
});

export { RetroDialog };
export default RetroDialog; 

================================================
File: frontend/src/components/FileList.jsx
================================================
import { useState } from 'preact/hooks';
import FileIcon from './FileIcon';

const FileList = ({ contents, onNavigate, isLoading }) => {
    const [selectedFile, setSelectedFile] = useState(null);
    
    const formatFileSize = (size) => {
        if (size === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(size) / Math.log(k));
        return `${parseFloat((size / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
    };
    
    const formatDate = (dateString) => {
        const date = new Date(dateString);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    };
    
    const handleFileClick = (file) => {
        setSelectedFile(file);
        if (file.isDir) {
            onNavigate(file.path);
        }
    };
    
    const handleDoubleClick = (file) => {
        if (file.isDir) {
            onNavigate(file.path);
        }
    };
    
    if (isLoading) {
        return (
            <div className="blueprint-panel flex-1">
                <div className="blueprint-panel-header">
                    <span>Loading Directory...</span>
                </div>
                <div className="p-8 text-center">
                    <div className="blueprint-loading text-blue-300">
                        <div className="inline-block w-6 h-6 border-2 border-blue-300 border-t-transparent rounded-full animate-spin"></div>
                    </div>
                    <p className="mt-4 text-gray-400">Scanning files...</p>
                </div>
            </div>
        );
    }
    
    const allItems = [...contents.directories, ...contents.files];
    
    return (
        <div className="blueprint-panel flex-1 flex flex-col">
            <div className="blueprint-panel-header flex justify-between items-center">
                <span>Directory Contents</span>
                <div className="text-xs opacity-75">
                    {contents.totalDirs} folders, {contents.totalFiles} files
                </div>
            </div>
            
            <div className="flex-1 overflow-auto custom-scrollbar">
                {allItems.length === 0 ? (
                    <div className="p-8 text-center text-gray-400">
                        <div className="text-4xl mb-4">üìÇ</div>
                        <p>This directory is empty</p>
                    </div>
                ) : (
                    <div className="p-2">
                        {/* Header row */}
                        <div className="grid grid-cols-12 gap-2 px-3 py-2 text-xs font-semibold text-gray-400 border-b border-gray-600 uppercase tracking-wider">
                            <div className="col-span-5">Name</div>
                            <div className="col-span-2">Size</div>
                            <div className="col-span-3">Modified</div>
                            <div className="col-span-2">Type</div>
                        </div>
                        
                        {/* File/folder rows */}
                        {allItems.map((file, index) => (
                            <div
                                key={`${file.path}-${index}`}
                                onClick={() => handleFileClick(file)}
                                onDoubleClick={() => handleDoubleClick(file)}
                                className={`
                                    grid grid-cols-12 gap-2 px-3 py-2 mx-1 my-1 rounded-md cursor-pointer
                                    transition-all duration-200 ease-in-out
                                    hover:bg-blue-900/30 hover:border-blue-400/30 border border-transparent
                                    ${selectedFile?.path === file.path ? 'bg-blue-800/40 border-blue-400/50' : ''}
                                    ${file.isHidden ? 'opacity-60' : ''}
                                `}
                            >
                                {/* Name column */}
                                <div className="col-span-5 flex items-center space-x-3 min-w-0">
                                    <FileIcon file={file} />
                                    <span className={`truncate text-sm ${file.isDir ? 'text-blue-300 font-medium' : 'text-gray-200'}`}>
                                        {file.name}
                                    </span>
                                </div>
                                
                                {/* Size column */}
                                <div className="col-span-2 flex items-center text-xs text-gray-400">
                                    {file.isDir ? '‚Äî' : formatFileSize(file.size)}
                                </div>
                                
                                {/* Modified column */}
                                <div className="col-span-3 flex items-center text-xs text-gray-400">
                                    {file.modTime ? formatDate(file.modTime) : '‚Äî'}
                                </div>
                                
                                {/* Type column */}
                                <div className="col-span-2 flex items-center text-xs text-gray-400">
                                    {file.isDir ? 'Folder' : (file.extension || 'File')}
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>
            
            {/* Status bar */}
            <div className="border-t border-gray-600 px-4 py-2 bg-gray-800/50">
                <div className="flex justify-between items-center text-xs text-gray-400">
                    <span>{contents.currentPath}</span>
                    <span>
                        {selectedFile ? (
                            <>Selected: {selectedFile.name}</>
                        ) : (
                            <>{contents.totalDirs + contents.totalFiles} items</>
                        )}
                    </span>
                </div>
            </div>
        </div>
    );
};

export default FileList; 

================================================
File: frontend/src/components/InlineFolderEditor.jsx
================================================
import { memo } from "preact/compat";

// Inline folder editor component with 8-bit retro styling
const InlineFolderEditor = memo(({ 
    tempFolderName,
    editInputRef,
    onKeyDown,
    onChange,
    onBlur
}) => {
    return (
        <div className="file-item creating-folder">
            <div className="file-icon folder">
                üìÅ
            </div>
            <div className="file-details">
                <div className="file-name">
                    <input
                        ref={editInputRef}
                        type="text"
                        value={tempFolderName}
                        onChange={onChange}
                        onKeyDown={onKeyDown}
                        onBlur={onBlur}
                        className="folder-name-input"
                        maxLength={255}
                        spellCheck={false}
                        autoComplete="off"
                    />
                </div>
                <div className="file-meta">
                    <span>DIR ‚Ä¢ Creating...</span>
                </div>
            </div>
        </div>
    );
});

export { InlineFolderEditor };
export default InlineFolderEditor; 

================================================
File: frontend/src/components/NavigationBar.jsx
================================================
import { useState, useEffect } from 'preact/hooks';

const NavigationBar = ({ currentPath, onNavigate, onNavigateUp, onNavigateHome }) => {
    const [pathParts, setPathParts] = useState([]);
    const [inputPath, setInputPath] = useState('');
    const [isEditing, setIsEditing] = useState(false);
    
    useEffect(() => {
        if (currentPath) {
            setInputPath(currentPath);
            // Split path into parts for breadcrumb navigation
            const parts = currentPath.split(/[\\/]/).filter(part => part.length > 0);
            setPathParts(parts);
        }
    }, [currentPath]);
    
    const handlePathInputSubmit = (e) => {
        e.preventDefault();
        if (inputPath.trim()) {
            onNavigate(inputPath.trim());
        }
        setIsEditing(false);
    };
    
    const handleBreadcrumbClick = (index) => {
        if (index === -1) {
            // Root click
            const isWindows = currentPath.includes(':\\');
            if (isWindows) {
                // Go to drive root (e.g., C:\)
                const driveLetter = currentPath.charAt(0);
                onNavigate(`${driveLetter}:\\`);
            } else {
                onNavigate('/');
            }
        } else {
            // Build path up to clicked part
            const isWindows = currentPath.includes(':\\');
            let pathUpTo;
            
            if (isWindows && index === 0) {
                // First part is drive letter
                pathUpTo = pathParts[0];
            } else if (isWindows) {
                pathUpTo = pathParts.slice(0, index + 1).join('\\');
            } else {
                pathUpTo = '/' + pathParts.slice(0, index + 1).join('/');
            }
            
            onNavigate(pathUpTo);
        }
    };
    
    const canNavigateUp = () => {
        if (!currentPath) return false;
        const isRoot = currentPath === '/' || /^[A-Z]:\\?$/.test(currentPath);
        return !isRoot;
    };
    
    return (
        <div className="blueprint-panel">
            <div className="blueprint-panel-header">
                <span>File Explorer Navigation</span>
            </div>
            
            <div className="p-4 space-y-4">
                {/* Quick navigation buttons */}
                <div className="flex space-x-2">
                    <button
                        onClick={onNavigateUp}
                        disabled={!canNavigateUp()}
                        className="blueprint-button disabled:opacity-50 disabled:cursor-not-allowed"
                        title="Go up one level"
                    >
                        ‚Üë Up
                    </button>
                    
                    <button
                        onClick={onNavigateHome}
                        className="blueprint-button"
                        title="Go to home directory"
                    >
                        üè† Home
                    </button>
                    
                    <button
                        onClick={() => setIsEditing(!isEditing)}
                        className="blueprint-button"
                        title="Edit path directly"
                    >
                        ‚úèÔ∏è Edit
                    </button>
                </div>
                
                {/* Path display/input */}
                <div className="space-y-2">
                    {isEditing ? (
                        <form onSubmit={handlePathInputSubmit} className="flex space-x-2">
                            <input
                                type="text"
                                value={inputPath}
                                onChange={(e) => setInputPath(e.target.value)}
                                onBlur={() => setIsEditing(false)}
                                className="flex-1 blueprint-input text-sm"
                                placeholder="Enter path..."
                                autoFocus
                            />
                            <button type="submit" className="blueprint-button">
                                Go
                            </button>
                        </form>
                    ) : (
                        /* Breadcrumb navigation */
                        <div className="flex items-center space-x-1 text-sm">
                            <span className="text-gray-400">Path:</span>
                            
                            {/* Root indicator */}
                            <button
                                onClick={() => handleBreadcrumbClick(-1)}
                                className="px-2 py-1 rounded text-blue-300 hover:bg-blue-900/30 transition-colors"
                                title="Go to root"
                            >
                                {currentPath?.includes(':\\') ? 'üíª' : '/'}
                            </button>
                            
                            {/* Path parts */}
                            {pathParts.map((part, index) => (
                                <div key={index} className="flex items-center space-x-1">
                                    <span className="text-gray-500">/</span>
                                    <button
                                        onClick={() => handleBreadcrumbClick(index)}
                                        className="px-2 py-1 rounded text-blue-300 hover:bg-blue-900/30 transition-colors max-w-32 truncate"
                                        title={part}
                                    >
                                        {part}
                                    </button>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
                
                {/* Current path display (always visible) */}
                <div className="text-xs text-gray-500 bg-gray-800/30 p-2 rounded border border-gray-600 font-mono">
                    <span className="text-gray-400">Current: </span>
                    <span className="break-all">{currentPath || 'No path selected'}</span>
                </div>
            </div>
        </div>
    );
};

export default NavigationBar; 

================================================
File: frontend/src/components/VirtualizedFileList.css
================================================
/* Virtualized File List Performance Optimizations - Zen Theme */

.virtualized-file-list {
    /* Use GPU acceleration for smooth scrolling */
    transform: translateZ(0);
    will-change: scroll-position;
    
    /* Optimize rendering */
    contain: layout style paint;
    
    /* Prevent layout thrashing */
    overflow-anchor: none;
    
    /* Enhanced spacing for zen design */
    padding: var(--zen-space-xl);
    gap: var(--zen-space-xs);
}

.virtualized-file-list .file-item {
    /* Optimize positioning for virtual scrolling */
    contain: layout style paint;
    
    /* Prevent unnecessary reflows */
    box-sizing: border-box;
    
    /* Use transform instead of top/left for better performance */
    will-change: transform;
    
    /* Zen spacing and design */
    margin-bottom: var(--zen-space-xs);
    border-radius: var(--zen-radius-md);
    min-height: 3.5rem;
}

/* Optimize scrollbar for zen theme */
.virtualized-file-list::-webkit-scrollbar {
    width: 6px;
    background-color: transparent;
}

.virtualized-file-list::-webkit-scrollbar-track {
    background-color: transparent;
    border-radius: 3px;
}

.virtualized-file-list::-webkit-scrollbar-thumb {
    background-color: var(--zen-border);
    border-radius: 3px;
}

.virtualized-file-list::-webkit-scrollbar-thumb:hover {
    background-color: var(--zen-border-focus);
}

/* Prevent horizontal scrollbar from appearing */
.virtualized-file-list::-webkit-scrollbar-horizontal {
    display: none;
}

/* Optimize file items for virtual scrolling */
.virtual-file-item {
    position: absolute;
    width: 100%;
    
    /* Prevent text selection during fast scrolling */
    user-select: none;
    
    /* Optimize for frequent updates */
    contain: layout style paint;
    
    /* Prevent subpixel rendering issues */
    transform: translateZ(0);
    
    /* Zen design spacing */
    padding: var(--zen-space-lg);
    border-radius: var(--zen-radius-md);
}

/* Loading state optimizations */
.virtualized-file-list .loading-overlay {
    /* Use backdrop-filter for better performance */
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    
    /* Optimize positioning */
    position: absolute;
    inset: 0;
    
    /* Prevent interaction during loading */
    pointer-events: none;
    
    /* Use flexbox for centering with zen spacing */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: var(--zen-space-lg);
    
    /* Zen theme background */
    background: rgba(250, 250, 250, 0.8);
    color: var(--zen-text-tertiary);
}

/* Memory-efficient animations with zen timing */
@media (prefers-reduced-motion: no-preference) {
    .virtual-file-item {
        transition: opacity 150ms ease-out, transform 150ms ease-out;
    }
    
    .virtual-file-item:hover {
        transform: translateY(-1px) translateZ(0);
    }
}

/* High DPI optimizations */
@media (-webkit-min-device-pixel-ratio: 2) {
    .virtualized-file-list {
        /* Optimize for high DPI displays */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }
}

/* Dark mode support for loading overlay */
@media (prefers-color-scheme: dark) {
    .virtualized-file-list .loading-overlay {
        background: rgba(26, 35, 50, 0.8);
    }
} 

================================================
File: frontend/src/hooks/index.js
================================================
// Custom hooks for the File Explorer
export { useNavigation } from './useNavigation';
export { useDialogs } from './useDialogs';
export { useContextMenus } from './useContextMenus';
export { usePerformanceMonitoring } from './usePerformanceMonitoring';
export { useKeyboardShortcuts } from './useKeyboardShortcuts';
export { useDragAndDrop } from './useDragAndDrop';
export { useFolderCreation } from './useFolderCreation';


// Re-export existing hooks
export { useFileOperations } from './useFileOperations';
export { useSelection } from './useSelection';
export { useClipboard } from './useClipboard'; 

================================================
File: frontend/src/components/Sidebar.jsx
================================================
import { useState, useEffect, useMemo, useCallback } from "preact/hooks";
import { memo } from "preact/compat";
import { GetHomeDirectory } from "../../wailsjs/go/backend/App";

// Memoized Sidebar component
const Sidebar = memo(({ currentPath, onNavigate, drives = [] }) => {
    const [homeDir, setHomeDir] = useState('');
    
    useEffect(() => {
        GetHomeDirectory().then(setHomeDir);
    }, []);
    
    // Use proper path separators for the current OS
    const pathSep = homeDir.includes('\\') ? '\\' : '/';
    
    const quickAccess = useMemo(() => [
        { name: 'Home', path: homeDir, icon: 'üè†' },
        { name: 'Desktop', path: homeDir + pathSep + 'Desktop', icon: 'üñ•Ô∏è' },
        { name: 'Documents', path: homeDir + pathSep + 'Documents', icon: 'üìÅ' },
        { name: 'Downloads', path: homeDir + pathSep + 'Downloads', icon: '‚¨áÔ∏è' },
    ].filter(item => item.path), [homeDir, pathSep]);
    
    const handleQuickAccessClick = useCallback((path) => {
        onNavigate(path);
    }, [onNavigate]);
    
    const handleDriveClick = useCallback((path) => {
        onNavigate(path);
    }, [onNavigate]);
    
    return (
        <div className="sidebar" onSelectStart={(e) => e.preventDefault()}>
            <div className="sidebar-section">
                <div className="sidebar-title">Quick Access</div>
                {quickAccess.map((item) => (
                    <div 
                        key={item.path}
                        className={`sidebar-item ${currentPath === item.path ? 'active' : ''}`}
                        onClick={() => handleQuickAccessClick(item.path)}
                    >
                        <span className="sidebar-icon">{item.icon}</span>
                        {item.name}
                    </div>
                ))}
            </div>
            
            {drives.length > 0 && (
                <div className="sidebar-section">
                    <div className="sidebar-title">Drives</div>
                    {drives.map((drive) => (
                        <div 
                            key={drive.path}
                            className={`sidebar-item ${currentPath === drive.path ? 'active' : ''}`}
                            onClick={() => handleDriveClick(drive.path)}
                        >
                            <span className="sidebar-icon">üíΩ</span>
                            {drive.name}
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
});

export { Sidebar };
export default Sidebar; 

================================================
File: frontend/src/hooks/useClipboard.js
================================================
import { useState, useCallback } from "preact/hooks";

export const useClipboard = () => {
    const [clipboardFiles, setClipboardFiles] = useState([]);
    const [clipboardOperation, setClipboardOperation] = useState(''); // 'copy' or 'cut'

    const handleCopy = useCallback((filePaths) => {
        setClipboardFiles(filePaths);
        setClipboardOperation('copy');
        
        console.log('üìã Copied to clipboard:', filePaths);
        console.log(`üìÑ ${filePaths.length} item${filePaths.length === 1 ? '' : 's'} copied`);
    }, []);

    const handleCut = useCallback((filePaths) => {
        setClipboardFiles(filePaths);
        setClipboardOperation('cut');
        
        console.log('‚úÇÔ∏è Cut to clipboard:', filePaths);
        console.log(`‚úÇÔ∏è ${filePaths.length} item${filePaths.length === 1 ? '' : 's'} cut`);
    }, []);

    const clearClipboard = useCallback(() => {
        setClipboardFiles([]);
        setClipboardOperation('');
    }, []);

    const isPasteAvailable = useCallback(() => {
        return clipboardFiles.length > 0 && clipboardOperation !== '';
    }, [clipboardFiles.length, clipboardOperation]);

    return {
        clipboardFiles,
        clipboardOperation,
        handleCopy,
        handleCut,
        clearClipboard,
        isPasteAvailable
    };
}; 

================================================
File: frontend/src/components/index.js
================================================
// Component exports for cleaner imports
export { Breadcrumb } from './Breadcrumb';
export { Sidebar } from './Sidebar';
export { FileItem } from './FileItem';
export { ContextMenu } from './ContextMenu';
export { EmptySpaceContextMenu } from './EmptySpaceContextMenu';
export { RetroDialog } from './RetroDialog';
export { VirtualizedFileList } from './VirtualizedFileList';
export { InlineFolderEditor } from './InlineFolderEditor'; 

================================================
File: frontend/src/hooks/useDialogs.js
================================================
import { useState, useCallback } from "preact/hooks";

export function useDialogs() {
    const [dialog, setDialog] = useState({
        isOpen: false,
        type: 'alert',
        title: '',
        message: '',
        defaultValue: '',
        onConfirm: () => {},
        onCancel: () => {}
    });

    const showDialog = useCallback((type, title, message, defaultValue = '', onConfirm = () => {}, onCancel = () => {}) => {
        setDialog({
            isOpen: true,
            type,
            title,
            message,
            defaultValue,
            onConfirm: (value) => {
                setDialog(prev => ({ ...prev, isOpen: false }));
                onConfirm(value);
            },
            onCancel: () => {
                setDialog(prev => ({ ...prev, isOpen: false }));
                onCancel();
            }
        });
    }, []);

    const closeDialog = useCallback(() => {
        setDialog(prev => ({ ...prev, isOpen: false }));
    }, []);

    return {
        dialog,
        showDialog,
        closeDialog
    };
} 

================================================
File: frontend/src/components/VirtualizedFileList.jsx
================================================
import { useState, useEffect, useCallback, useMemo, useRef, useLayoutEffect } from "preact/hooks";
import { memo } from "preact/compat";
import { FileItem } from "./FileItem";
import { InlineFolderEditor } from "./InlineFolderEditor";
import { rafThrottle } from "../utils/debounce";
import { log } from "../utils/logger";
import { 
    EMPTY_DIRECTORY_STYLE, 
    LARGE_ICON_STYLE,
    FLEX_COLUMN_STYLE,
    FLEX_CENTER_STYLE
} from "../utils/styleConstants";

// Virtual scrolling configuration
const ITEM_HEIGHT = 48; // Height of each file item in pixels
const BUFFER_SIZE = 5; // Number of items to render outside visible area
const CONTAINER_HEIGHT = 400; // Default container height

// Pre-compiled styles for optimal performance
const CONTAINER_STYLE = {
    overflowY: 'auto',
    overflowX: 'hidden',
    position: 'relative'
};

const VIRTUAL_CONTAINER_STYLE = {
    position: 'relative'
};

const VIRTUAL_ITEM_STYLE_BASE = {
    position: 'absolute',
    left: 0,
    right: 0,
    height: ITEM_HEIGHT
};

const EMPTY_STATE_CONTAINER_STYLE = {
    ...FLEX_COLUMN_STYLE,
    ...FLEX_CENTER_STYLE,
    height: '100%',
    color: 'var(--blueprint-text-muted)'
};

const VirtualizedFileList = memo(({ 
    files, 
    selectedFiles,
    onFileSelect,
    onFileOpen,
    onContextMenu,
    isLoading,
    clipboardFiles,
    clipboardOperation,
    containerHeight,
    dragState,
    onDragStart,
    onDragOver,
    onDragEnter,
    onDragLeave,
    onDrop,
    // Folder creation props
    creatingFolder,
    tempFolderName,
    editInputRef,
    onFolderKeyDown,
    onFolderInputChange,
    onFolderInputBlur,
    // Empty space context menu props
    onEmptySpaceContextMenu,

}) => {
    const [scrollTop, setScrollTop] = useState(0);
    const [measuredHeight, setMeasuredHeight] = useState(CONTAINER_HEIGHT);
    const containerRef = useRef(null);
    
    // Measure container height once with useLayoutEffect
    useLayoutEffect(() => {
        if (containerRef.current) {
            const height = containerRef.current.clientHeight;
            if (height !== measuredHeight) {
                setMeasuredHeight(height);
                log('üìè VirtualizedFileList: Measured container height:', height);
            }
        }
    }, [measuredHeight]);
    
    // Calculate visible range - memoized for performance
    const visibleRange = useMemo(() => {
        const effectiveHeight = containerHeight || measuredHeight;
        const visibleStart = Math.floor(scrollTop / ITEM_HEIGHT);
        const visibleEnd = Math.min(
            files.length - 1,
            Math.ceil((scrollTop + effectiveHeight) / ITEM_HEIGHT)
        );
        
        // Add buffer for smooth scrolling
        const startIndex = Math.max(0, visibleStart - BUFFER_SIZE);
        const endIndex = Math.min(files.length - 1, visibleEnd + BUFFER_SIZE);
        
        return { startIndex, endIndex, visibleStart, visibleEnd };
    }, [scrollTop, containerHeight, measuredHeight, files.length]);
    
    // Get visible items
    const visibleItems = useMemo(() => {
        const { startIndex, endIndex } = visibleRange;
        return files.slice(startIndex, endIndex + 1).map((file, index) => ({
            file,
            index: startIndex + index,
            offsetTop: (startIndex + index) * ITEM_HEIGHT
        }));
    }, [files, visibleRange]);
    
    // RAF-throttled scroll handler for smooth performance
    const handleScroll = useCallback(rafThrottle((event) => {
        // Use requestAnimationFrame to batch layout reads
        requestAnimationFrame(() => {
            const newScrollTop = event.target.scrollTop;
            setScrollTop(newScrollTop);
        });
    }), []);
    
    // Scroll to item (for keyboard navigation) - optimized with measured height
    const scrollToItem = useCallback((index) => {
        if (containerRef.current) {
            const effectiveHeight = containerHeight || measuredHeight;
            const targetScrollTop = index * ITEM_HEIGHT;
            const containerScrollTop = containerRef.current.scrollTop;
            const containerBottom = containerScrollTop + effectiveHeight;
            
            // Only scroll if item is not visible
            if (targetScrollTop < containerScrollTop) {
                containerRef.current.scrollTop = targetScrollTop;
            } else if (targetScrollTop + ITEM_HEIGHT > containerBottom) {
                containerRef.current.scrollTop = targetScrollTop - effectiveHeight + ITEM_HEIGHT;
            }
        }
    }, [containerHeight, measuredHeight]);
    
    // Total height for scrollbar (including inline folder editor if creating)
    const totalHeight = (files.length + (creatingFolder ? 1 : 0)) * ITEM_HEIGHT;
    
        // Optimize file item click handlers - Fixed to prevent double-opens
    const handleFileClick = useCallback((fileIndex, event) => {
        // Always handle selection for virtualized list - FileItem will handle opening logic
        onFileSelect(fileIndex, event.shiftKey, event.ctrlKey || event.metaKey);
        
        // Scroll to item if needed
        if (event.shiftKey || event.ctrlKey || event.metaKey) {
            scrollToItem(fileIndex);
        }
    }, [onFileSelect, scrollToItem]);

    const handleFileDoubleClick = useCallback((file) => {
        onFileOpen(file);
    }, [onFileOpen]);
    
    const handleFileContextMenu = useCallback((event, file) => {
        onContextMenu(event, file);
    }, [onContextMenu]);
    
    // Compute container style once
    const containerStyle = useMemo(() => ({
        ...CONTAINER_STYLE,
        height: containerHeight || '100%'
    }), [containerHeight]);
    
    // Compute virtual container style once
    const virtualContainerStyle = useMemo(() => ({
        ...VIRTUAL_CONTAINER_STYLE,
        height: totalHeight
    }), [totalHeight]);

    return (
        <div 
            ref={containerRef}
            className="virtualized-file-list custom-scrollbar"
            style={containerStyle}
            onScroll={handleScroll}
            onContextMenu={(e) => {
                // Check if right-clicking on empty space in virtual list
                if (e.target === e.currentTarget || !e.target.closest('.file-item')) {
                    e.preventDefault();
                    if (onEmptySpaceContextMenu) {
                        onEmptySpaceContextMenu(e);
                    }
                }
            }}
        >
            {/* Virtual container with total height */}
            <div style={virtualContainerStyle}>
                {/* Show inline folder editor if creating folder */}
                {creatingFolder && (
                    <div style={{
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        right: 0,
                        height: ITEM_HEIGHT
                    }}>
                        <InlineFolderEditor
                            tempFolderName={tempFolderName}
                            editInputRef={editInputRef}
                            onKeyDown={onFolderKeyDown}
                            onChange={onFolderInputChange}
                            onBlur={onFolderInputBlur}
                        />
                    </div>
                )}
                
                {/* Render only visible items */}
                {visibleItems.map(({ file, index, offsetTop }) => {
                    // Compute item style once per item (offset by folder editor if creating)
                    const itemStyle = useMemo(() => ({
                        ...VIRTUAL_ITEM_STYLE_BASE,
                        top: offsetTop + (creatingFolder ? ITEM_HEIGHT : 0)
                    }), [offsetTop, creatingFolder]);
                    
                    return (
                        <div
                            key={`${file.path}-${index}`}
                            style={itemStyle}
                        >
                            <FileItem
                                file={file}
                                fileIndex={index}
                                onSelect={handleFileClick}
                                onOpen={handleFileDoubleClick}
                                onContextMenu={handleFileContextMenu}
                                isLoading={isLoading}
                                isSelected={selectedFiles.has(index)}
                                isCut={clipboardOperation === 'cut' && clipboardFiles.includes(file.path)}
                                isDragOver={dragState?.dragOverFolder === file.path}
                                onDragStart={onDragStart}
                                onDragOver={onDragOver}
                                onDragEnter={onDragEnter}
                                onDragLeave={onDragLeave}
                                onDrop={onDrop}
                            />
                        </div>
                    );
                })}
            </div>
            
            {/* Empty state */}
            {files.length === 0 && !creatingFolder && (
                <div style={EMPTY_STATE_CONTAINER_STYLE}>
                    <div style={LARGE_ICON_STYLE}>üìÅ</div>
                    <div className="text-technical">Directory is empty</div>
                </div>
            )}
        </div>
    );
});

export { VirtualizedFileList }; 

================================================
File: frontend/src/hooks/useContextMenus.js
================================================
import { useState, useCallback } from "preact/hooks";

export function useContextMenus(selectedFiles, allFiles, handleCopy, handleCut, showDialog, fileOperations, currentPath, onCreateFolder) {
    // Context menu states
    const [contextMenu, setContextMenu] = useState({ visible: false, x: 0, y: 0, files: [] });
    const [emptySpaceContextMenu, setEmptySpaceContextMenu] = useState({ visible: false, x: 0, y: 0 });

    // Context menu handlers
    const handleContextMenu = useCallback((event, file) => {
        const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
        
        const contextFiles = selectedFiles.size > 0 && selectedFileObjects.some(f => f.path === file.path) 
            ? selectedFileObjects 
            : [file];
        
        setContextMenu({
            visible: true,
            x: event.clientX,
            y: event.clientY,
            files: contextFiles
        });
    }, [selectedFiles, allFiles]);

    const closeContextMenu = useCallback(() => {
        setContextMenu({ visible: false, x: 0, y: 0, files: [] });
    }, []);

    const handleEmptySpaceContextMenu = useCallback((event) => {
        event.preventDefault();
        setEmptySpaceContextMenu({
            visible: true,
            x: event.clientX,
            y: event.clientY
        });
    }, []);

    const closeEmptySpaceContextMenu = useCallback(() => {
        setEmptySpaceContextMenu({ visible: false, x: 0, y: 0 });
    }, []);

    // Context menu actions
    const handleContextCopy = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        handleCopy(filePaths);
        closeContextMenu();
    }, [contextMenu.files, handleCopy, closeContextMenu]);

    const handleContextCut = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        handleCut(filePaths);
        closeContextMenu();
    }, [contextMenu.files, handleCut, closeContextMenu]);

    const handleContextRename = useCallback(() => {
        if (contextMenu.files.length !== 1) {
            closeContextMenu();
            return;
        }
        
        const file = contextMenu.files[0];
        closeContextMenu();
        
        showDialog(
            'prompt',
            'RENAME FILE',
            `RENAME "${file.name}" TO:`,
            file.name,
            (newName) => {
                if (newName && newName !== file.name && newName.trim() !== '') {
                    fileOperations.handleRename(file.path, newName.trim());
                }
            }
        );
    }, [contextMenu.files, closeContextMenu, showDialog, fileOperations]);

    const handleContextHide = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        closeContextMenu();
        
        showDialog(
            'confirm',
            'HIDE FILES',
            `HIDE ${filePaths.length} ITEM${filePaths.length === 1 ? '' : 'S'}?\n\nHidden files will not be visible unless "Show Hidden Files" is enabled.`,
            '',
            () => {
                fileOperations.handleHideFiles(filePaths);
            }
        );
    }, [contextMenu.files, closeContextMenu, showDialog, fileOperations]);

    const handlePermanentDelete = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        closeContextMenu();
        showDialog('delete', '‚ö†Ô∏è PERMANENT DELETE WARNING', `Permanently delete ${filePaths.length} items? This cannot be undone!`, '', 
            () => {
                fileOperations.handlePermanentDelete(filePaths);
            });
    }, [contextMenu.files, closeContextMenu, showDialog, fileOperations]);

    const handleOpenPowerShell = useCallback(() => {
        closeEmptySpaceContextMenu();
        fileOperations.handleOpenPowerShell();
    }, [closeEmptySpaceContextMenu, fileOperations]);

    const handleCreateFolder = useCallback(() => {
        closeEmptySpaceContextMenu();
        if (onCreateFolder) {
            onCreateFolder();
        }
    }, [closeEmptySpaceContextMenu, onCreateFolder]);

    return {
        contextMenu,
        emptySpaceContextMenu,
        handleContextMenu,
        closeContextMenu,
        handleEmptySpaceContextMenu,
        closeEmptySpaceContextMenu,
        handleContextCopy,
        handleContextCut,
        handleContextRename,
        handleContextHide,
        handlePermanentDelete,
        handleOpenPowerShell,
        handleCreateFolder
    };
} 

================================================
File: frontend/src/hooks/useFolderCreation.js
================================================
import { useState, useCallback, useRef } from "preact/hooks";
import { CreateDirectory } from "../../wailsjs/go/backend/App";
import { log, error } from "../utils/logger";

export function useFolderCreation(currentPath, onRefresh, setError) {
    const [creatingFolder, setCreatingFolder] = useState(false);
    const [tempFolderName, setTempFolderName] = useState("New folder");
    const editInputRef = useRef(null);

    const startFolderCreation = useCallback(() => {
        if (!currentPath) return;
        
        setCreatingFolder(true);
        setTempFolderName("New folder");
        
        // Focus the input in the next tick
        setTimeout(() => {
            if (editInputRef.current) {
                editInputRef.current.focus();
                editInputRef.current.select();
            }
        }, 100);
    }, [currentPath]);

    const cancelFolderCreation = useCallback(() => {
        setCreatingFolder(false);
        setTempFolderName("New folder");
    }, []);

    const confirmFolderCreation = useCallback(async () => {
        if (!currentPath || !tempFolderName.trim()) {
            cancelFolderCreation();
            return;
        }

        const folderName = tempFolderName.trim();
        
        try {
            log(`üìÅ Creating folder: "${folderName}" in ${currentPath}`);
            
            const response = await CreateDirectory(currentPath, folderName);
            
            if (response && response.success) {
                log(`‚úÖ Folder created successfully: ${folderName}`);
                
                // Refresh directory to show the new folder
                onRefresh();
                
                setCreatingFolder(false);
                setTempFolderName("New folder");
            } else {
                const errorMsg = response?.message || 'Failed to create folder';
                error('‚ùå Folder creation failed:', errorMsg);
                setError(`Failed to create folder: ${errorMsg}`);
                cancelFolderCreation();
            }
        } catch (err) {
            error('‚ùå Error creating folder:', err);
            setError(`Error creating folder: ${err.message}`);
            cancelFolderCreation();
        }
    }, [currentPath, tempFolderName, onRefresh, setError, cancelFolderCreation]);

    const handleKeyDown = useCallback((e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            confirmFolderCreation();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            cancelFolderCreation();
        }
    }, [confirmFolderCreation, cancelFolderCreation]);

    const handleInputChange = useCallback((e) => {
        setTempFolderName(e.target.value);
    }, []);

    const handleInputBlur = useCallback(() => {
        // Delay to allow for clicks on other elements
        setTimeout(() => {
            if (creatingFolder) {
                confirmFolderCreation();
            }
        }, 100);
    }, [creatingFolder, confirmFolderCreation]);

    return {
        creatingFolder,
        tempFolderName,
        editInputRef,
        startFolderCreation,
        cancelFolderCreation,
        confirmFolderCreation,
        handleKeyDown,
        handleInputChange,
        handleInputBlur
    };
} 

================================================
File: frontend/src/hooks/usePerformanceMonitoring.js
================================================
import { useState } from "preact/hooks";

export function usePerformanceMonitoring() {
    const [navigationStats, setNavigationStats] = useState({
        totalNavigations: 0,
        averageTime: 0,
        lastNavigationTime: 0
    });

    return {
        navigationStats,
        setNavigationStats
    };
} 

================================================
File: frontend/src/hooks/useKeyboardShortcuts.js
================================================
import { useEffect, useMemo } from "preact/hooks";
import { throttle } from "../utils/debounce";

export function useKeyboardShortcuts({
    handleRefresh,
    handleNavigateUp,
    selectedFiles,
    allFiles,
    handleFileOpen,
    selectAll,
    handleCopySelected,
    handleCutSelected,
    handlePaste,
    isPasteAvailable,
    handleArrowNavigation,
    clearSelection,
    closeContextMenu,
    closeEmptySpaceContextMenu
}) {
    // Optimized keyboard shortcuts
    const keyboardHandler = useMemo(
        () => throttle((event) => {
            if (event.key === 'F5') {
                event.preventDefault();
                handleRefresh();
            } else if ((event.key === 'Backspace' && !event.target.matches('input, textarea')) || 
                     (event.altKey && event.key === 'ArrowLeft')) {
                event.preventDefault();
                handleNavigateUp();
            } else if (event.key === 'Enter' && selectedFiles.size > 0) {
                event.preventDefault();
                const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
                selectedFileObjects.forEach(file => handleFileOpen(file));
            } else if (event.ctrlKey && event.key === 'a' && !event.target.matches('input, textarea')) {
                event.preventDefault();
                selectAll(allFiles.length);
            } else if (event.ctrlKey && event.key === 'c' && selectedFiles.size > 0) {
                event.preventDefault();
                handleCopySelected();
            } else if (event.ctrlKey && event.key === 'x' && selectedFiles.size > 0) {
                event.preventDefault();
                handleCutSelected();
            } else if (event.ctrlKey && event.key === 'v' && isPasteAvailable()) {
                event.preventDefault();
                handlePaste();
            } else if (event.key === 'ArrowUp' && !event.target.matches('input, textarea')) {
                event.preventDefault();
                handleArrowNavigation('up', allFiles);
            } else if (event.key === 'ArrowDown' && !event.target.matches('input, textarea')) {
                event.preventDefault();
                handleArrowNavigation('down', allFiles);
            } else if (event.key === 'Escape') {
                clearSelection();
                closeContextMenu();
                closeEmptySpaceContextMenu();
            }
        }, 50), // Faster response for keyboard
        [
            handleRefresh, 
            handleNavigateUp, 
            selectedFiles, 
            allFiles, 
            handleFileOpen, 
            selectAll, 
            handleCopySelected, 
            handleCutSelected, 
            handlePaste, 
            isPasteAvailable, 
            handleArrowNavigation, 
            clearSelection, 
            closeContextMenu, 
            closeEmptySpaceContextMenu
        ]
    );

    // Keyboard shortcuts
    useEffect(() => {
        window.addEventListener('keydown', keyboardHandler);
        return () => window.removeEventListener('keydown', keyboardHandler);
    }, [keyboardHandler]);
} 

================================================
File: frontend/src/hooks/useNavigation.js
================================================
import { useState, useCallback, useRef, useEffect } from "preact/hooks";
import { NavigateToPath } from "../../wailsjs/go/backend/App";
import { EventsOn, EventsOff } from "../../wailsjs/runtime/runtime";
import { log, error } from "../utils/logger";

export function useNavigation(setError, setNavigationStats) {
    const [currentPath, setCurrentPath] = useState('');
    const [directoryContents, setDirectoryContents] = useState(null);
    const [isActuallyLoading, setIsActuallyLoading] = useState(true);
    const [showLoadingIndicator, setShowLoadingIndicator] = useState(false);
    
    // Performance tracking refs
    const navigationStartTime = useRef(null);
    const loadingTimeout = useRef(null);
    const renderCompleteCallback = useRef(null);

    // Smart loading indicator management
    const showSmartLoadingIndicator = useCallback(() => {
        // Clear any existing timeout
        if (loadingTimeout.current) {
            clearTimeout(loadingTimeout.current);
        }
        
        // Only show loading after 150ms delay for perceived speed
        loadingTimeout.current = setTimeout(() => {
            if (isActuallyLoading) {
                setShowLoadingIndicator(true);
            }
        }, 150);
    }, [isActuallyLoading]);

    const hideLoadingIndicator = useCallback(() => {
        if (loadingTimeout.current) {
            clearTimeout(loadingTimeout.current);
            loadingTimeout.current = null;
        }
        setShowLoadingIndicator(false);
    }, []);

    // Helper function to measure render completion time
    const measureRenderTime = useCallback((startTime, source = 'unknown') => {
        // Wait for multiple animation frames to ensure rendering is complete
        // This accounts for: DOM updates, style calculations, layout, paint, and composite
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    const totalTime = Date.now() - startTime;
                    const renderPhaseTime = totalTime - (source === 'backend' ? 0 : 0); // Can track backend vs render split if needed
                    
                    // Update performance stats with the complete UI render time
                    setNavigationStats(prev => ({
                        totalNavigations: prev.totalNavigations + 1,
                        averageTime: (prev.averageTime * prev.totalNavigations + totalTime) / (prev.totalNavigations + 1),
                        lastNavigationTime: totalTime
                    }));
                    
                    log(`‚úÖ Complete navigation with UI render: ${totalTime}ms total (includes backend + rendering)`);
                    
                    // Clear the callback reference
                    renderCompleteCallback.current = null;
                });
            });
        });
    }, [setNavigationStats]);

    // Navigate to path with real-time fresh data
    const navigateToPath = useCallback(async (path, source = 'user') => {
        log(`üß≠ Navigation request: ${path} (${source}) - Real-time mode`);
        navigationStartTime.current = Date.now();
        
        // Clear any pending render completion callback
        if (renderCompleteCallback.current) {
            renderCompleteCallback.current = null;
        }
        
        // Set measuring state to show progress in UI
        setNavigationStats(prev => ({
            ...prev,
            lastNavigationTime: 0 // This will trigger "Measuring..." display
        }));
        
        try {
            setError('');
            
            // Always fetch fresh data from backend (no caching)
            setIsActuallyLoading(true);
            showSmartLoadingIndicator();
            
            // Backend call with optimized timeout
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Navigation timeout')), 5000);
            });
            
            const navigationPromise = NavigateToPath(path);
            const response = await Promise.race([navigationPromise, timeoutPromise]);
            
            if (response && response.success) {
                const backendTime = Date.now() - navigationStartTime.current;
                log(`üìä Fresh backend response received in ${backendTime}ms, starting UI render...`);
                
                setCurrentPath(response.data.currentPath);
                setDirectoryContents(response.data);
                
                // Measure render completion time for fresh data
                measureRenderTime(navigationStartTime.current, 'backend');
                
            } else {
                const errorMsg = response?.message || 'Unknown navigation error';
                setError(errorMsg);
                error('‚ùå Navigation failed:', errorMsg);
            }
        } catch (err) {
            error('‚ùå Navigation error:', err);
            setError('Failed to navigate: ' + err.message);
        } finally {
            setIsActuallyLoading(false);
            hideLoadingIndicator();
        }
    }, [setError, measureRenderTime, showSmartLoadingIndicator, hideLoadingIndicator]);

    // Navigate up
    const handleNavigateUp = useCallback(async () => {
        if (!currentPath) return;
        
        try {
            // Calculate parent path
            const parentPath = currentPath.includes('\\') 
                ? currentPath.split('\\').slice(0, -1).join('\\')
                : currentPath.split('/').slice(0, -1).join('/');
                
            if (parentPath && parentPath !== currentPath) {
                await navigateToPath(parentPath, 'navigate-up');
            }
        } catch (err) {
            error('‚ùå Navigate up error:', err);
            setError('Failed to navigate up: ' + err.message);
        }
    }, [currentPath, navigateToPath, setError]);

    const handleRefresh = useCallback(() => {
        if (currentPath) {
            navigateToPath(currentPath, 'refresh');
        }
    }, [currentPath, navigateToPath]);

    // Listen for progressive hydration events
    useEffect(() => {
        const unsubscribeHydrate = EventsOn("DirectoryHydrate", (fileInfo) => {
            log(`üîÑ Hydrating file: ${fileInfo.name}`);
            
            setDirectoryContents(prev => {
                if (!prev) return prev;
                
                // Find and update the matching entry
                const allFiles = [...prev.directories, ...prev.files];
                const updatedFiles = allFiles.map(file => 
                    file.path === fileInfo.path ? fileInfo : file
                );
                
                // Split back into directories and files
                const directories = updatedFiles.filter(f => f.isDir);
                const files = updatedFiles.filter(f => !f.isDir);
                
                return {
                    ...prev,
                    directories,
                    files,
                    totalDirs: directories.length,
                    totalFiles: files.length
                };
            });
        });

        const unsubscribeComplete = EventsOn("DirectoryComplete", (data) => {
            log(`‚úÖ Directory hydration completed: ${data.path} (${data.totalFiles} files processed)`);
            
            // Update performance stats to reflect completion
            setNavigationStats(prev => ({
                ...prev,
                lastHydrationTime: Date.now()
            }));
        });
        
        return () => {
            EventsOff("DirectoryHydrate");
            EventsOff("DirectoryComplete");
        };
    }, [setNavigationStats]);

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            if (loadingTimeout.current) {
                clearTimeout(loadingTimeout.current);
            }
            if (renderCompleteCallback.current) {
                renderCompleteCallback.current = null;
            }
        };
    }, []);

    return {
        currentPath,
        directoryContents,
        isActuallyLoading,
        showLoadingIndicator,
        navigateToPath,
        handleNavigateUp,
        handleRefresh
    };
} 

================================================
File: frontend/src/hooks/useOptimizedState.js
================================================
import { useState, useCallback, useMemo } from "preact/hooks";

// Optimized state hook that combines related states to reduce re-renders
export const useOptimizedState = () => {
    // Consolidated navigation state
    const [navigationState, setNavigationState] = useState({
        currentPath: '',
        directoryContents: null,
        isLoading: true,
        error: '',
        drives: []
    });

    // Consolidated UI state
    const [uiState, setUiState] = useState({
        showHiddenFiles: false,
        selectedFiles: new Set(),
        lastSelectedIndex: -1,
        isDragging: false,
        dragOverFolder: null
    });

    // Consolidated context menu state
    const [contextMenuState, setContextMenuState] = useState({
        main: { visible: false, x: 0, y: 0, files: [] },
        emptySpace: { visible: false, x: 0, y: 0 }
    });

    // Consolidated dialog state
    const [dialogState, setDialogState] = useState({
        isOpen: false,
        type: 'alert',
        title: '',
        message: '',
        defaultValue: '',
        onConfirm: () => {},
        onCancel: () => {}
    });

    // Memoized update functions to prevent unnecessary re-renders
    const updateNavigation = useCallback((updates) => {
        setNavigationState(prev => ({ ...prev, ...updates }));
    }, []);

    const updateUI = useCallback((updates) => {
        setUiState(prev => ({ ...prev, ...updates }));
    }, []);

    const updateContextMenu = useCallback((updates) => {
        setContextMenuState(prev => ({ ...prev, ...updates }));
    }, []);

    const updateDialog = useCallback((updates) => {
        setDialogState(prev => ({ ...prev, ...updates }));
    }, []);

    // Optimized clear selection
    const clearSelection = useCallback(() => {
        updateUI({
            selectedFiles: new Set(),
            lastSelectedIndex: -1
        });
    }, [updateUI]);

    // Optimized close context menus
    const closeContextMenus = useCallback(() => {
        setContextMenuState({
            main: { visible: false, x: 0, y: 0, files: [] },
            emptySpace: { visible: false, x: 0, y: 0 }
        });
    }, []);

    return {
        // States
        navigationState,
        uiState,
        contextMenuState,
        dialogState,
        
        // Update functions
        updateNavigation,
        updateUI,
        updateContextMenu,
        updateDialog,
        
        // Helper functions
        clearSelection,
        closeContextMenus
    };
}; 

================================================
File: frontend/src/main.jsx
================================================
import {render} from 'preact';
import {App} from './app';
import './style.css';

render(<App/>, document.getElementById('app'));

================================================
File: frontend/src/components/EmptySpaceContextMenu.jsx
================================================
import { useRef, useEffect } from "preact/hooks";
import { memo } from "preact/compat";

// Memoized Empty Space Context Menu Component  
const EmptySpaceContextMenu = memo(({ visible, x, y, onClose, onOpenPowerShell, onCreateFolder }) => {
    const menuRef = useRef(null);
    
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
                onClose();
            }
        };
        
        if (visible) {
            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
        }
    }, [visible, onClose]);
    
    if (!visible) return null;
    
    return (
        <div 
            ref={menuRef}
            className="context-menu empty-space-context-menu"
            onSelectStart={(e) => e.preventDefault()}
            style={{ 
                position: 'fixed', 
                left: x, 
                top: y, 
                zIndex: 1000 
            }}
        >
            <div className="context-menu-item" onClick={onCreateFolder}>
                <span className="context-menu-icon">[+]</span>
                <span className="context-menu-text">New Folder</span>
            </div>
            <div className="context-menu-separator"></div>
            <div className="context-menu-item" onClick={onOpenPowerShell}>
                <span className="context-menu-icon">[{'>'}_]</span>
                <span className="context-menu-text">Open PowerShell 7 Here</span>
            </div>
        </div>
    );
});

export { EmptySpaceContextMenu };
export default EmptySpaceContextMenu; 

================================================
File: frontend/src/hooks/useSelection.js
================================================
import { useState, useCallback } from "preact/hooks";

export const useSelection = () => {
    const [selectedFiles, setSelectedFiles] = useState(new Set());
    const [lastSelectedIndex, setLastSelectedIndex] = useState(-1);

    const handleFileSelect = useCallback((fileIndex, isShiftKey, isCtrlKey) => {
        console.log('üìã File selection:', fileIndex, 'Shift:', isShiftKey, 'Ctrl:', isCtrlKey);
        
        setSelectedFiles(prevSelected => {
            const newSelected = new Set(prevSelected);
            
            if (isShiftKey && lastSelectedIndex !== -1) {
                // Range selection
                const start = Math.min(lastSelectedIndex, fileIndex);
                const end = Math.max(lastSelectedIndex, fileIndex);
                
                for (let i = start; i <= end; i++) {
                    newSelected.add(i);
                }
            } else if (isCtrlKey) {
                // Toggle selection
                if (newSelected.has(fileIndex)) {
                    newSelected.delete(fileIndex);
                } else {
                    newSelected.add(fileIndex);
                }
            } else {
                // Single selection
                newSelected.clear();
                newSelected.add(fileIndex);
            }
            
            return newSelected;
        });
        
        setLastSelectedIndex(fileIndex);
    }, [lastSelectedIndex]);

    const clearSelection = useCallback(() => {
        setSelectedFiles(new Set());
        setLastSelectedIndex(-1);
        console.log('üìã Cleared selection');
    }, []);

    const selectAll = useCallback((totalFiles) => {
        const allIndices = new Set();
        for (let i = 0; i < totalFiles; i++) {
            allIndices.add(i);
        }
        setSelectedFiles(allIndices);
        console.log('üìã Selected all files:', allIndices.size);
    }, []);

    const handleArrowNavigation = useCallback((direction, allFiles) => {
        if (allFiles.length === 0) return;
        
        let targetIndex;
        
        if (selectedFiles.size === 1) {
            // Move from current selection
            const currentIndex = Array.from(selectedFiles)[0];
            
            if (direction === 'up') {
                targetIndex = currentIndex > 0 ? currentIndex - 1 : allFiles.length - 1; // Wrap to bottom
            } else {
                targetIndex = currentIndex < allFiles.length - 1 ? currentIndex + 1 : 0; // Wrap to top
            }
        } else {
            // No selection or multiple selections - select first/last item
            if (direction === 'up') {
                targetIndex = allFiles.length - 1; // Select last item
            } else {
                targetIndex = 0; // Select first item
            }
        }
        
        console.log(`‚¨ÜÔ∏è‚¨áÔ∏è Arrow navigation ${direction}: moving to index ${targetIndex} (${allFiles[targetIndex]?.name})`);
        
        // Select the target file
        setSelectedFiles(new Set([targetIndex]));
        setLastSelectedIndex(targetIndex);
        
        return targetIndex;
    }, [selectedFiles]);

    return {
        selectedFiles,
        lastSelectedIndex,
        handleFileSelect,
        clearSelection,
        selectAll,
        handleArrowNavigation
    };
}; 

================================================
File: frontend/src/hooks/useDragAndDrop.js
================================================
import { useState, useCallback, useRef } from "preact/hooks";
import { CopyFiles, MoveFiles } from "../../wailsjs/go/backend/App";

export const useDragAndDrop = (currentPath, selectedFiles, allFiles, setError, clearSelection, handleRefresh) => {
    const [dragState, setDragState] = useState({
        isDragging: false,
        draggedFiles: [],
        draggedPaths: [],
        dragOperation: 'move', // 'move' or 'copy'
        dragOverFolder: null,
        dragStartPosition: { x: 0, y: 0 }
    });

    const dragPreviewRef = useRef(null);
    const dragTimeoutRef = useRef(null);

    // Start drag operation
    const handleDragStart = useCallback((event, file) => {
        console.log('üéØ Drag started for:', file.name);

        // Get all selected files or just the dragged file
        let draggedFiles = [];
        let draggedPaths = [];

        if (selectedFiles.has(allFiles.findIndex(f => f.path === file.path))) {
            // Dragging selected files
            draggedFiles = Array.from(selectedFiles).map(index => allFiles[index]);
        } else {
            // Dragging unselected file
            draggedFiles = [file];
        }

        draggedPaths = draggedFiles.map(f => f.path);

        // Set drag operation based on modifier keys
        const operation = event.ctrlKey ? 'copy' : 'move';

        // Create drag data
        const dragData = {
            files: draggedPaths,
            operation: operation,
            source: currentPath,
            fileNames: draggedFiles.map(f => f.name)
        };

        // Set drag effect
        event.dataTransfer.effectAllowed = event.ctrlKey ? 'copy' : 'move';
        event.dataTransfer.setData('application/json', JSON.stringify(dragData));
        event.dataTransfer.setData('text/plain', draggedFiles.map(f => f.name).join(', '));

        // Create custom drag preview
        const dragPreview = createDragPreview(draggedFiles, operation);
        if (dragPreview) {
            document.body.appendChild(dragPreview);
            event.dataTransfer.setDragImage(dragPreview, 20, 20);
            dragPreviewRef.current = dragPreview;
        }

        // Update drag state
        setDragState({
            isDragging: true,
            draggedFiles,
            draggedPaths,
            dragOperation: operation,
            dragOverFolder: null,
            dragStartPosition: { x: event.clientX, y: event.clientY }
        });

        console.log(`üéØ Dragging ${draggedFiles.length} items with operation: ${operation}`);
    }, [currentPath, selectedFiles, allFiles]);

    // Handle drag over folder
    const handleDragOver = useCallback((event, targetFolder) => {
        if (!dragState.isDragging || !targetFolder.isDir) return;

        event.preventDefault();
        
        // Update drop effect based on current modifier keys
        const operation = event.ctrlKey ? 'copy' : 'move';
        event.dataTransfer.dropEffect = operation;

        // Update drag operation if it changed
        if (operation !== dragState.dragOperation) {
            setDragState(prev => ({ ...prev, dragOperation: operation }));
        }

        // Set visual feedback for drop target
        if (dragState.dragOverFolder !== targetFolder.path) {
            setDragState(prev => ({ ...prev, dragOverFolder: targetFolder.path }));
        }
    }, [dragState.isDragging, dragState.dragOperation, dragState.dragOverFolder]);

    // Handle drag enter
    const handleDragEnter = useCallback((event, targetFolder) => {
        if (!targetFolder.isDir) return;
        
        event.preventDefault();
        
        // Clear any existing timeout
        if (dragTimeoutRef.current) {
            clearTimeout(dragTimeoutRef.current);
            dragTimeoutRef.current = null;
        }

        setDragState(prev => ({ ...prev, dragOverFolder: targetFolder.path }));
    }, []);

    // Handle drag leave
    const handleDragLeave = useCallback((event, targetFolder) => {
        if (!targetFolder.isDir) return;

        // Add small delay to prevent flicker when moving between child elements
        dragTimeoutRef.current = setTimeout(() => {
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX;
            const y = event.clientY;

            // Only clear if we're actually outside the element
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                setDragState(prev => ({ 
                    ...prev, 
                    dragOverFolder: prev.dragOverFolder === targetFolder.path ? null : prev.dragOverFolder 
                }));
            }
        }, 100);
    }, []);

    // Handle drop operation
    const handleDrop = useCallback(async (event, targetFolder, dragData) => {
        event.preventDefault();
        
        if (!targetFolder.isDir) {
            console.warn('‚ö†Ô∏è Cannot drop on non-directory:', targetFolder.name);
            return;
        }

        const { files: sourcePaths, operation, source } = dragData;
        
        // Prevent dropping on itself or into same directory
        if (source === targetFolder.path) {
            console.log('‚ÑπÔ∏è Dropping in same directory, ignoring');
            return;
        }

        // Prevent dropping a folder into itself or its subdirectories
        const isInvalidDrop = sourcePaths.some(srcPath => {
            return targetFolder.path.startsWith(srcPath + '/') || targetFolder.path.startsWith(srcPath + '\\') || targetFolder.path === srcPath;
        });

        if (isInvalidDrop) {
            setError('Cannot move or copy a folder into itself or its subdirectories');
            return;
        }

        try {
            console.log(`üéØ Dropping ${sourcePaths.length} items into:`, targetFolder.path);
            console.log(`üìã Operation: ${operation}`);

            let success = false;

            if (operation === 'copy') {
                success = await CopyFiles(sourcePaths, targetFolder.path);
            } else {
                success = await MoveFiles(sourcePaths, targetFolder.path);
            }

            if (success) {
                console.log(`‚úÖ ${operation} operation successful`);
                
                // If we moved files, clear selection
                if (operation === 'move') {
                    clearSelection();
                }
                
                // Refresh current directory
                setTimeout(() => {
                    handleRefresh();
                }, 100);
                
            } else {
                setError(`Failed to ${operation} files to "${targetFolder.name}"`);
            }

        } catch (err) {
            console.error(`‚ùå Error during ${operation} operation:`, err);
            setError(`Failed to ${operation} files: ${err.message}`);
        }
    }, [setError, clearSelection, handleRefresh]);

    // Handle drag end
    const handleDragEnd = useCallback(() => {
        console.log('üéØ Drag operation ended');

        // Clean up drag preview
        if (dragPreviewRef.current) {
            document.body.removeChild(dragPreviewRef.current);
            dragPreviewRef.current = null;
        }

        // Clear timeout
        if (dragTimeoutRef.current) {
            clearTimeout(dragTimeoutRef.current);
            dragTimeoutRef.current = null;
        }

        // Reset drag state
        setDragState({
            isDragging: false,
            draggedFiles: [],
            draggedPaths: [],
            dragOperation: 'move',
            dragOverFolder: null,
            dragStartPosition: { x: 0, y: 0 }
        });
    }, []);

    // Create custom drag preview
    const createDragPreview = (files, operation) => {
        const preview = document.createElement('div');
        preview.style.cssText = `
            position: absolute;
            top: -1000px;
            left: -1000px;
            background: var(--blueprint-surface);
            border: 1px solid var(--blueprint-border);
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--blueprint-text);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 300px;
        `;

        const icon = operation === 'copy' ? 'üìÑ' : 'üîÑ';
        const action = operation === 'copy' ? 'Copy' : 'Move';
        
        if (files.length === 1) {
            preview.innerHTML = `${icon} ${action} "${files[0].name}"`;
        } else {
            preview.innerHTML = `${icon} ${action} ${files.length} items`;
        }

        return preview;
    };

    return {
        dragState,
        handleDragStart,
        handleDragOver,
        handleDragEnter,
        handleDragLeave,
        handleDrop,
        handleDragEnd
    };
};

export default useDragAndDrop; 

================================================
File: frontend/src/hooks/useFileOperations.js
================================================
import { useCallback } from "preact/hooks";
import { 
    CopyFiles,
    MoveFiles,
    DeleteFiles,
    MoveFilesToRecycleBin,
    RenameFile,
    OpenFile,
    OpenInSystemExplorer,
    OpenPowerShellHere,
    HideFiles
} from "../../wailsjs/go/backend/App";

export const useFileOperations = (currentPath, setError, clearSelection, handleRefresh, showDialog) => {
    const handleFileOpen = useCallback((file) => {
        console.log('üîç Opening file/folder:', file);
        console.log('üìä File properties - Name:', file.name, 'IsDir:', file.isDir, 'Path:', file.path);
        
        try {
            if (file.isDir) {
                console.log('üìÅ Navigating to folder:', file.path);
                // This will be handled by the parent component
                return { type: 'navigate', path: file.path };
            } else {
                console.log('üìÑ Opening file with default application:', file.path);
                const success = OpenFile(file.path);
                if (!success) {
                    console.warn('‚ö†Ô∏è Failed to open file with default application, falling back to explorer');
                    OpenInSystemExplorer(file.path);
                }
            }
        } catch (err) {
            console.error('‚ùå Error opening file:', err);
            setError('Failed to open file: ' + err.message);
        }
    }, [setError]);

    const handleCopyFiles = useCallback(async (filePaths) => {
        if (filePaths.length === 0 || !currentPath) return false;

        try {
            console.log(`üì• Copying ${filePaths.length} items to:`, currentPath);
            
            const success = await CopyFiles(filePaths, currentPath);
            
            if (success) {
                console.log('‚úÖ Copy operation successful');
                clearSelection();
                setTimeout(() => {
                    console.log('üîÑ Refreshing directory after copy operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('‚ùå Copy operation failed');
                setError(`Failed to copy files to "${currentPath}". This may be due to:
‚Ä¢ Insufficient permissions (try running as administrator)
‚Ä¢ Destination folder is read-only
‚Ä¢ Not enough disk space
‚Ä¢ Files are in use by another application`);
                return false;
            }
        } catch (err) {
            console.error('‚ùå Error during copy operation:', err);
            setError('Failed to copy files: ' + err.message);
            return false;
        }
    }, [currentPath, setError, clearSelection, handleRefresh]);

    const handleMoveFiles = useCallback(async (filePaths) => {
        if (filePaths.length === 0 || !currentPath) return false;

        try {
            console.log(`üì• Moving ${filePaths.length} items to:`, currentPath);
            
            const success = await MoveFiles(filePaths, currentPath);
            
            if (success) {
                console.log('‚úÖ Move operation successful');
                clearSelection();
                setTimeout(() => {
                    console.log('üîÑ Refreshing directory after move operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('‚ùå Move operation failed');
                setError(`Failed to move files to "${currentPath}". This may be due to:
‚Ä¢ Insufficient permissions (try running as administrator)
‚Ä¢ Destination folder is read-only
‚Ä¢ Files are in use by another application
‚Ä¢ Cannot move across different drive types`);
                return false;
            }
        } catch (err) {
            console.error('‚ùå Error during move operation:', err);
            setError('Failed to move files: ' + err.message);
            return false;
        }
    }, [currentPath, setError, clearSelection, handleRefresh]);

    const handleRecycleBinDelete = useCallback(async (filePaths) => {
        try {
            console.log('üóëÔ∏è Moving files to recycle bin:', filePaths);
            
            const success = await MoveFilesToRecycleBin(filePaths);
            
            if (success) {
                console.log('‚úÖ Move to recycle bin successful');
                clearSelection();
                setTimeout(() => {
                    console.log('üîÑ Refreshing directory after recycle bin operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('‚ùå Move to recycle bin failed');
                setError('Failed to move files to recycle bin');
                return false;
            }
        } catch (err) {
            console.error('‚ùå Error during recycle bin operation:', err);
            setError('Failed to move files to recycle bin: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    const handlePermanentDelete = useCallback(async (filePaths) => {
        try {
            console.log('üóëÔ∏è Permanently deleting files:', filePaths);
            
            const success = await DeleteFiles(filePaths);
            
            if (success) {
                console.log('‚úÖ Permanent delete operation successful');
                clearSelection();
                setTimeout(() => {
                    console.log('üîÑ Refreshing directory after permanent delete operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('‚ùå Permanent delete operation failed');
                setError('Failed to permanently delete files');
                return false;
            }
        } catch (err) {
            console.error('‚ùå Error during permanent delete operation:', err);
            setError('Failed to permanently delete files: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    const handleRename = useCallback(async (filePath, newName) => {
        try {
            console.log('‚úèÔ∏è Renaming file:', filePath, 'to:', newName);
            
            const success = await RenameFile(filePath, newName);
            
            if (success) {
                console.log('‚úÖ Rename operation successful');
                clearSelection();
                setTimeout(() => {
                    console.log('üîÑ Refreshing directory after rename operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('‚ùå Rename operation failed');
                setError(`Failed to rename "${filePath}". This may be due to:
‚Ä¢ A file with that name already exists
‚Ä¢ Insufficient permissions
‚Ä¢ Invalid characters in the new name
‚Ä¢ File is in use by another application`);
                return false;
            }
        } catch (err) {
            console.error('‚ùå Error during rename operation:', err);
            setError('Failed to rename file: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    const handleOpenPowerShell = useCallback(async () => {
        if (!currentPath) {
            console.warn('‚ö†Ô∏è No current path available for PowerShell');
            return;
        }
        
        try {
            console.log('üîß Opening PowerShell 7 in:', currentPath);
            
            const success = await OpenPowerShellHere(currentPath);
            
            if (!success) {
                console.warn('‚ö†Ô∏è Failed to open PowerShell 7');
                setError('Failed to open PowerShell 7. Please ensure PowerShell 7 is installed at the default location.');
            } else {
                console.log('‚úÖ PowerShell 7 opened successfully in:', currentPath);
            }
        } catch (err) {
            console.error('‚ùå Error opening PowerShell 7:', err);
            setError('Failed to open PowerShell 7: ' + err.message);
        }
    }, [currentPath, setError]);

    const handleHideFiles = useCallback(async (filePaths) => {
        try {
            console.log('üëÅÔ∏è Hiding files:', filePaths);
            
            const success = await HideFiles(filePaths);
            
            if (success) {
                console.log('‚úÖ Hide files operation successful');
                clearSelection();
                setTimeout(() => {
                    console.log('üîÑ Refreshing directory after hide operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('‚ùå Hide files operation failed');
                setError(`Failed to hide files. This may be due to:
‚Ä¢ Insufficient permissions (try running as administrator)
‚Ä¢ Files are in use by another application
‚Ä¢ Files are on a network drive or external storage`);
                return false;
            }
        } catch (err) {
            console.error('‚ùå Error during hide files operation:', err);
            setError('Failed to hide files: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    return {
        handleFileOpen,
        handleCopyFiles,
        handleMoveFiles,
        handleRecycleBinDelete,
        handlePermanentDelete,
        handleRename,
        handleOpenPowerShell,
        handleHideFiles
    };
}; 

================================================
File: backend/platform.go
================================================
package backend

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"syscall"
)

// NewPlatformManager creates a new platform manager instance
func NewPlatformManager() *PlatformManager {
	return &PlatformManager{}
}

// GetHomeDirectory returns the user's home directory
func (p *PlatformManager) GetHomeDirectory() string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		log.Printf("Error getting home directory: %v", err)
		return ""
	}
	return homeDir
}

// GetCurrentWorkingDirectory returns the current working directory
func (p *PlatformManager) GetCurrentWorkingDirectory() string {
	cwd, err := os.Getwd()
	if err != nil {
		log.Printf("Error getting current working directory: %v", err)
		return ""
	}
	return cwd
}

// GetSystemRoots returns system root paths (drives on Windows, / on Unix)
func (p *PlatformManager) GetSystemRoots() []string {
	var roots []string

	switch runtime.GOOS {
	case "windows":
		// Get all drives on Windows
		for i := 'A'; i <= 'Z'; i++ {
			drive := fmt.Sprintf("%c:\\", i)
			if _, err := os.Stat(drive); err == nil {
				roots = append(roots, drive)
			}
		}
	default:
		// Unix-like systems start from root
		roots = append(roots, "/")
	}

	return roots
}

// OpenInSystemExplorer opens the given path in the system's default file manager
func (p *PlatformManager) OpenInSystemExplorer(path string) bool {
	var cmd string
	var args []string

	switch runtime.GOOS {
	case "windows":
		cmd = "explorer"
		args = []string{path}
	case "darwin":
		cmd = "open"
		args = []string{path}
	case "linux":
		cmd = "xdg-open"
		args = []string{path}
	default:
		log.Printf("OpenInSystemExplorer not supported on %s", runtime.GOOS)
		return false
	}

	err := exec.Command(cmd, args...).Start()
	if err != nil {
		log.Printf("Error opening in system explorer: %v", err)
		return false
	}
	return true
}

// OpenFile opens a file with its default application
func (p *PlatformManager) OpenFile(filePath string) bool {
	log.Printf("Opening file with default application: %s", filePath)

	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "windows":
		// Use rundll32 with shell32.dll to open file without showing command prompt
		cmd = exec.Command("rundll32.exe", "shell32.dll,ShellExec_RunDLL", filePath)
		cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}
	case "darwin":
		cmd = exec.Command("open", filePath)
	case "linux":
		cmd = exec.Command("xdg-open", filePath)
	default:
		log.Printf("Unsupported operating system: %s", runtime.GOOS)
		return false
	}

	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening file: %v", err)
		return false
	}

	log.Printf("Successfully opened file: %s", filePath)
	return true
}

// IsHiddenWindows checks if a file has the Windows hidden attribute
func (p *PlatformManager) IsHiddenWindows(filePath string) bool {
	if runtime.GOOS != "windows" {
		return false
	}

	// Use attrib command to check hidden attribute
	cmd := exec.Command("attrib", filePath)
	cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}

	output, err := cmd.Output()
	if err != nil {
		return false
	}

	// Parse attrib output - hidden files show 'H' in the attribute string
	outputStr := string(output)
	lines := strings.Split(outputStr, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.Contains(line, filePath) {
			parts := strings.Fields(line)
			if len(parts) > 0 {
				attributes := parts[0]
				return strings.Contains(attributes, "H")
			}
		}
	}

	return false
}

// IsHiddenMac checks if a file is hidden on macOS
func (p *PlatformManager) IsHiddenMac(filePath string) bool {
	if runtime.GOOS != "darwin" {
		return false
	}

	fileName := filepath.Base(filePath)
	// Files starting with dot are hidden on macOS
	return strings.HasPrefix(fileName, ".")
}

// IsHiddenLinux checks if a file is hidden on Linux
func (p *PlatformManager) IsHiddenLinux(filePath string) bool {
	if runtime.GOOS != "linux" {
		return false
	}

	fileName := filepath.Base(filePath)
	// Files starting with dot are hidden on Linux
	return strings.HasPrefix(fileName, ".")
}

// IsHidden checks if a file/directory is hidden using OS-specific methods
func (p *PlatformManager) IsHidden(filePath string) bool {
	// Check for dot prefix (universal Unix convention)
	fileName := filepath.Base(filePath)
	if strings.HasPrefix(fileName, ".") {
		return true
	}

	// Check OS-specific hidden attributes
	switch runtime.GOOS {
	case "windows":
		return p.IsHiddenWindows(filePath)
	case "darwin":
		return p.IsHiddenMac(filePath)
	case "linux":
		return p.IsHiddenLinux(filePath)
	default:
		return false
	}
}

// HideFileWindows sets the hidden attribute on Windows using attrib command
func (p *PlatformManager) HideFileWindows(filePath string) bool {
	if runtime.GOOS != "windows" {
		return false
	}

	log.Printf("Setting hidden attribute on Windows: %s", filePath)

	cmd := exec.Command("attrib", "+H", filePath)
	cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}

	err := cmd.Run()
	if err != nil {
		log.Printf("Failed to hide file using attrib: %v", err)
		return false
	}

	log.Printf("Successfully set hidden attribute: %s", filePath)
	return true
}

// HideFileMac hides file on macOS by adding a dot prefix (if not already hidden)
func (p *PlatformManager) HideFileMac(filePath string) bool {
	if runtime.GOOS != "darwin" {
		return false
	}

	log.Printf("Hiding file on macOS: %s", filePath)

	fileName := filepath.Base(filePath)
	if strings.HasPrefix(fileName, ".") {
		log.Printf("File is already hidden: %s", filePath)
		return true
	}

	dir := filepath.Dir(filePath)
	newPath := filepath.Join(dir, "."+fileName)

	err := os.Rename(filePath, newPath)
	if err != nil {
		log.Printf("Failed to hide file on macOS: %v", err)
		return false
	}

	log.Printf("Successfully hid file on macOS: %s -> %s", filePath, newPath)
	return true
}

// HideFileLinux hides file on Linux by adding a dot prefix (if not already hidden)
func (p *PlatformManager) HideFileLinux(filePath string) bool {
	if runtime.GOOS != "linux" {
		return false
	}

	log.Printf("Hiding file on Linux: %s", filePath)

	fileName := filepath.Base(filePath)
	if strings.HasPrefix(fileName, ".") {
		log.Printf("File is already hidden: %s", filePath)
		return true
	}

	dir := filepath.Dir(filePath)
	newPath := filepath.Join(dir, "."+fileName)

	err := os.Rename(filePath, newPath)
	if err != nil {
		log.Printf("Failed to hide file on Linux: %v", err)
		return false
	}

	log.Printf("Successfully hid file on Linux: %s -> %s", filePath, newPath)
	return true
}

// HideFile sets the hidden attribute on a file using OS-specific methods
func (p *PlatformManager) HideFile(filePath string) bool {
	switch runtime.GOOS {
	case "windows":
		return p.HideFileWindows(filePath)
	case "darwin":
		return p.HideFileMac(filePath)
	case "linux":
		return p.HideFileLinux(filePath)
	default:
		log.Printf("Hide file not supported on %s", runtime.GOOS)
		return false
	}
}

// GetExtension returns the file extension in lowercase
func (p *PlatformManager) GetExtension(name string) string {
	ext := filepath.Ext(name)
	if ext != "" {
		return strings.ToLower(ext[1:]) // Remove the dot and convert to lowercase
	}
	return ""
}

// FormatFileSize formats file size in human readable format
func (p *PlatformManager) FormatFileSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}

	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}

	units := []string{"KB", "MB", "GB", "TB", "PB"}
	return fmt.Sprintf("%.1f %s", float64(size)/float64(div), units[exp])
}


================================================
File: frontend/src/utils/formatUtils.js
================================================
// Formatting utility functions

export const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
};

export const formatFileSize = (size) => {
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    let unitIndex = 0;
    let fileSize = size;
    
    while (fileSize >= 1024 && unitIndex < units.length - 1) {
        fileSize /= 1024;
        unitIndex++;
    }
    
    return fileSize < 10 && unitIndex > 0 
        ? `${fileSize.toFixed(1)} ${units[unitIndex]}`
        : `${Math.round(fileSize)} ${units[unitIndex]}`;
}; 

================================================
File: frontend/src/components/Breadcrumb.jsx
================================================
import { memo, useMemo, useCallback } from "preact/compat";

// Memoized Breadcrumb component
const Breadcrumb = memo(({ 
    currentPath, 
    onNavigate
}) => {
    const segments = useMemo(() => {
        if (!currentPath) return [];
        
        // Handle Windows and Unix paths differently
        const isWindows = currentPath.includes('\\') || currentPath.includes(':');
        
        if (isWindows) {
            // For Windows paths like "C:\Users\username"
            const parts = currentPath.split(/[\\]/);
            return parts.filter(Boolean);
        } else {
            // For Unix paths like "/home/username"
            const parts = currentPath.split('/');
            return parts.filter(Boolean);
        }
    }, [currentPath]);
    
    const handleSegmentClick = useCallback((index) => {
        // Build path from segments
        const pathSegments = segments.slice(0, index + 1);
        let newPath;
        
        // Detect Windows vs Unix path
        const isWindows = currentPath.includes('\\') || currentPath.includes(':');
        
        if (isWindows) {
            // Windows path reconstruction
            newPath = pathSegments.join('\\');
            // Add trailing backslash for drive roots
            if (index === 0 && pathSegments[0].includes(':')) {
                newPath += '\\';
            }
        } else {
            // Unix path reconstruction
            newPath = '/' + pathSegments.join('/');
        }
        
        onNavigate(newPath);
    }, [segments, onNavigate, currentPath]);
    
    if (!segments.length) return null;
    
    return (
        <div className="nav-breadcrumb custom-scrollbar" onSelectStart={(e) => e.preventDefault()}>
            {segments.map((segment, index) => (
                <div key={index} className="breadcrumb-segment-wrapper">
                    {index > 0 && <span className="separator">{'/'}</span>}
                    <span 
                        className={`nav-segment ${index === segments.length - 1 ? 'current' : ''}`}
                        onClick={() => handleSegmentClick(index)}
                        title={segment}
                    >
                        {segment}
                    </span>
                </div>
            ))}
        </div>
    );
});

export { Breadcrumb };
export default Breadcrumb; 

================================================
File: frontend/src/utils/fileUtils.js
================================================
// Optimized file type detection using pre-compiled maps
import { 
    SPECIFIC_FILE_MAP, 
    EXTENSION_TYPE_MAP, 
    DEFAULT_FILE_TYPE,
    SPECIAL_FOLDER_MAP, 
    TYPE_ICON_MAP, 
    DEFAULT_FILE_ICON, 
    DEFAULT_FOLDER_ICON 
} from './fileTypeMaps.js';

export const getFileType = (fileName, isDir) => {
    if (isDir) return 'folder';
    
    const baseName = fileName.toLowerCase();
    
    // Check specific file mappings first (highest priority)
    if (SPECIFIC_FILE_MAP[baseName]) return SPECIFIC_FILE_MAP[baseName];
    
    // Check extension mappings
    const ext = fileName.split('.').pop()?.toLowerCase();
    return EXTENSION_TYPE_MAP[ext] || DEFAULT_FILE_TYPE;
};

export const getFileIcon = (fileName, isDir) => {
    if (isDir) {
        const folderName = fileName.toLowerCase();
        return SPECIAL_FOLDER_MAP[folderName] || DEFAULT_FOLDER_ICON;
    }
    
    const type = getFileType(fileName, false);
    return TYPE_ICON_MAP[type] || DEFAULT_FILE_ICON;
};

// Filter function for hidden and system files
export const filterFiles = (files, showHiddenFiles) => {
    if (!files) return [];
    if (showHiddenFiles) return files;
    
    return files.filter(file => {
        // Most important: Check the isHidden property from the backend
        if (file.isHidden) return false;
        
        // Hide files that start with . (hidden files) - redundant but kept for safety
        if (file.name.startsWith('.')) return false;
        
        // Hide common Windows system files
        const systemFiles = [
            'NTUSER.DAT', 'ntuser.dat.LOG1', 'ntuser.dat.LOG2', 'ntuser.ini',
            'Application Data', 'Cookies', 'Local Settings', 'My Documents',
            'NetHood', 'PrintHood', 'Recent', 'SendTo', 'Start Menu', 'Templates'
        ];
        
        if (systemFiles.includes(file.name)) return false;
        
        // Hide files with system file extensions and patterns
        const hiddenPatterns = [
            /^NTUSER\.DAT/i,
            /\.TM\.blf$/i,
            /\.TMContainer.*\.regtrans-ms$/i,
            /^thumbs\.db$/i,
            /^desktop\.ini$/i
        ];
        
        return !hiddenPatterns.some(pattern => pattern.test(file.name));
    });
}; 

================================================
File: frontend/src/utils/fileTypeMaps.js
================================================
// Pre-compiled file type and icon maps for optimal performance
// These are constants that are computed once at module load time

// Specific file mappings (highest priority)
export const SPECIFIC_FILE_MAP = {
    'readme': 'readme',
    'readme.md': 'readme',
    'readme.txt': 'readme',
    'license': 'license',
    'license.md': 'license',
    'license.txt': 'license',
    'dockerfile': 'docker',
    'docker-compose.yml': 'docker',
    'docker-compose.yaml': 'docker',
    'makefile': 'build',
    'cmake.txt': 'build',
    'package.json': 'nodejs',
    'package-lock.json': 'nodejs',
    'yarn.lock': 'nodejs',
    'pom.xml': 'java',
    'build.gradle': 'java',
    'cargo.toml': 'rust',
    'go.mod': 'go',
    'requirements.txt': 'python',
    'pipfile': 'python',
    '.gitignore': 'git',
    '.gitmodules': 'git',
    '.env': 'config',
    '.env.local': 'config',
    '.env.example': 'config'
};

// Extension to type mappings
export const EXTENSION_TYPE_MAP = {
    // Web technologies
    'js': 'javascript', 'mjs': 'javascript', 'cjs': 'javascript',
    'jsx': 'react', 'tsx': 'react',
    'ts': 'typescript',
    'html': 'html', 'htm': 'html',
    'css': 'css', 'scss': 'sass', 'sass': 'sass', 'less': 'css',
    'vue': 'vue', 'svelte': 'svelte',
    'php': 'php', 'phtml': 'php',
    
    // System languages
    'c': 'c', 'h': 'c',
    'cpp': 'cpp', 'cxx': 'cpp', 'cc': 'cpp', 'hpp': 'cpp',
    'cs': 'csharp', 'csx': 'csharp',
    'java': 'java', 'class': 'java', 'jar': 'java',
    'go': 'go',
    'rs': 'rust', 'rlib': 'rust',
    'swift': 'swift',
    'kt': 'kotlin', 'kts': 'kotlin',
    'dart': 'dart',
    
    // Scripting languages
    'py': 'python', 'pyw': 'python', 'pyc': 'python',
    'rb': 'ruby', 'rbw': 'ruby',
    'pl': 'perl', 'pm': 'perl',
    'lua': 'lua',
    'r': 'r', 'rdata': 'r',
    'jl': 'julia',
    
    // Shell scripts
    'sh': 'shell', 'bash': 'shell', 'zsh': 'shell', 'fish': 'shell',
    'ps1': 'powershell', 'psm1': 'powershell',
    'bat': 'batch', 'cmd': 'batch',
    
    // Assembly and low-level
    'asm': 'assembly', 's': 'assembly',
    
    // Database
    'sql': 'database', 'mysql': 'database', 'pgsql': 'database',
    'db': 'database', 'sqlite': 'database', 'sqlite3': 'database',
    
    // Configuration and data
    'json': 'json', 'jsonc': 'json',
    'xml': 'xml', 'xsd': 'xml', 'xsl': 'xml',
    'yaml': 'yaml', 'yml': 'yaml',
    'toml': 'config', 'ini': 'config', 'cfg': 'config', 'conf': 'config',
    'properties': 'config', 'env': 'config',
    
    // Images
    'jpg': 'image', 'jpeg': 'image',
    'png': 'image',
    'gif': 'gif',
    'svg': 'vector',
    'bmp': 'image',
    'webp': 'image',
    'ico': 'icon',
    'tiff': 'image', 'tif': 'image',
    'raw': 'camera', 'cr2': 'camera', 'nef': 'camera', 'arw': 'camera',
    'psd': 'photoshop', 'psb': 'photoshop',
    'ai': 'illustrator',
    'sketch': 'design',
    'fig': 'figma',
    'xd': 'xd',
    
    // Audio files
    'mp3': 'audio', 'm4a': 'audio', 'aac': 'audio',
    'wav': 'audio', 'flac': 'audio', 'ogg': 'audio',
    'wma': 'audio', 'aiff': 'audio',
    'midi': 'music', 'mid': 'music',
    
    // Video files
    'mp4': 'video', 'm4v': 'video',
    'avi': 'video', 'mkv': 'video', 'mov': 'video',
    'wmv': 'video', 'flv': 'video', 'webm': 'video',
    '3gp': 'video', 'mpg': 'video', 'mpeg': 'video',
    
    // Documents
    'pdf': 'pdf',
    'doc': 'word', 'docx': 'word',
    'xls': 'excel', 'xlsx': 'excel', 'csv': 'csv',
    'ppt': 'powerpoint', 'pptx': 'powerpoint',
    'odt': 'document', 'ods': 'document', 'odp': 'document',
    'rtf': 'document',
    'txt': 'text',
    'md': 'markdown', 'markdown': 'markdown',
    'tex': 'latex', 'bib': 'latex',
    'epub': 'ebook', 'mobi': 'ebook', 'azw': 'ebook',
    
    // Archives
    'zip': 'archive', 'rar': 'archive', '7z': 'archive',
    'tar': 'archive', 'gz': 'archive', 'bz2': 'archive',
    'xz': 'archive', 'lz': 'archive', 'lzma': 'archive',
    'cab': 'archive', 'iso': 'disc', 'dmg': 'disc',
    'pkg': 'package', 'deb': 'package', 'rpm': 'package',
    
    // Executables
    'exe': 'executable', 'msi': 'installer', 'app': 'macos',
    'run': 'executable', 'bin': 'executable',
    'appimage': 'executable', 'snap': 'executable',
    
    // Fonts
    'ttf': 'font', 'otf': 'font', 'woff': 'font', 'woff2': 'font',
    'eot': 'font', 'fon': 'font',
    
    // 3D and CAD
    'obj': '3d', 'fbx': '3d', 'dae': '3d', 'blend': 'blender',
    'max': '3d', '3ds': '3d', 'stl': '3d', 'ply': '3d',
    'dwg': 'cad', 'dxf': 'cad', 'step': 'cad', 'iges': 'cad'
};

// Special folder icons
export const SPECIAL_FOLDER_MAP = {
    'node_modules': 'üì¶',
    '.git': 'üîÄ',
    '.vscode': 'üîµ',
    '.idea': 'üí°',
    'dist': 'üì¶',
    'build': 'üî®',
    'src': 'üìÇ',
    'assets': 'üé®',
    'images': 'üñºÔ∏è',
    'img': 'üñºÔ∏è',
    'css': 'üé®',
    'js': 'üìú',
    'components': 'üß©',
    'utils': 'üîß',
    'config': '‚öôÔ∏è',
    'docs': 'üìö',
    'documentation': 'üìö',
    'test': 'üß™',
    'tests': 'üß™',
    '__pycache__': 'üêç',
    'venv': 'üêç',
    'env': 'üåç',
    'bin': '‚öôÔ∏è',
    'lib': 'üìö',
    'include': 'üìÇ',
    'public': 'üåê',
    'private': 'üîí',
    'temp': 'üóÇÔ∏è',
    'tmp': 'üóÇÔ∏è',
    'cache': 'üíæ',
    'log': 'üìù',
    'logs': 'üìù'
};

// Type to icon mappings
export const TYPE_ICON_MAP = {
    // Programming languages
    'javascript': 'üü®',
    'typescript': 'üî∑',
    'react': '‚öõÔ∏è',
    'vue': 'üíö',
    'svelte': 'üß°',
    'html': 'üåê',
    'css': 'üé®',
    'sass': 'üíÖ',
    'php': 'üêò',
    'python': 'üêç',
    'java': '‚òï',
    'csharp': 'üî∑',
    'cpp': '‚öôÔ∏è',
    'c': 'üîß',
    'go': 'üêπ',
    'rust': 'ü¶Ä',
    'swift': 'üê¶',
    'kotlin': 'üü£',
    'dart': 'üéØ',
    'ruby': 'üíé',
    'perl': 'üê™',
    'lua': 'üåô',
    'r': 'üìä',
    'julia': 'üî¥',
    'shell': 'üêö',
    'powershell': 'üíô',
    'batch': '‚ö´',
    'assembly': 'üî©',
    
    // Data and config
    'json': 'üìã',
    'xml': 'üìÑ',
    'yaml': 'üìù',
    'database': 'üóÑÔ∏è',
    'config': '‚öôÔ∏è',
    
    // Special files
    'readme': 'üìñ',
    'license': 'üìú',
    'docker': 'üê≥',
    'build': 'üî®',
    'nodejs': 'üíö',
    'git': 'üîÄ',
    
    // Images
    'image': 'üñºÔ∏è',
    'gif': 'üéûÔ∏è',
    'vector': 'üé®',
    'icon': 'üî≥',
    'camera': 'üì∑',
    'photoshop': 'üé®',
    'illustrator': 'üé®',
    'design': 'üé®',
    'figma': 'üé®',
    'xd': 'üé®',
    
    // Media
    'audio': 'üéµ',
    'music': 'üéº',
    'video': 'üé¨',
    
    // Documents
    'pdf': 'üìï',
    'word': 'üìò',
    'excel': 'üìó',
    'csv': 'üìä',
    'powerpoint': 'üìô',
    'document': 'üìÑ',
    'text': 'üìù',
    'markdown': 'üìù',
    'latex': 'üìñ',
    'ebook': 'üìö',
    
    // Archives and packages
    'archive': 'üì¶',
    'package': 'üì¶',
    'disc': 'üíø',
    
    // Executables
    'executable': '‚ö°',
    'installer': 'üì¶',
    'macos': 'üçé',
    
    // Fonts
    'font': 'üî§',
    
    // 3D and design
    '3d': 'üé≤',
    'blender': 'üé≤',
    'cad': 'üìê',
    
    // Default
    'file': 'üìÑ',
    'folder': 'üìÅ'
};

// Default constants
export const DEFAULT_FILE_ICON = 'üìÑ';
export const DEFAULT_FOLDER_ICON = 'üìÅ';
export const DEFAULT_FILE_TYPE = 'file'; 

================================================
File: frontend/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta name="description" content="Wails application with Tailwind CSS v3">
    <title>testui</title>
</head>
<body class="m-0 p-0 font-jetbrains antialiased">
<div id="app"></div>
<script src="./src/main.jsx" type="module"></script>
</body>
</html>



================================================
File: frontend/wailsjs/go/backend/App.js
================================================
// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH √Ç MODIWL
// This file is automatically generated. DO NOT EDIT

export function CopyFiles(arg1, arg2) {
  return window['go']['backend']['App']['CopyFiles'](arg1, arg2);
}

export function CreateDirectory(arg1, arg2) {
  return window['go']['backend']['App']['CreateDirectory'](arg1, arg2);
}

export function DeleteFiles(arg1) {
  return window['go']['backend']['App']['DeleteFiles'](arg1);
}

export function DeletePath(arg1) {
  return window['go']['backend']['App']['DeletePath'](arg1);
}

export function ExecuteCommand(arg1, arg2) {
  return window['go']['backend']['App']['ExecuteCommand'](arg1, arg2);
}

export function FileExists(arg1) {
  return window['go']['backend']['App']['FileExists'](arg1);
}

export function FormatFileSize(arg1) {
  return window['go']['backend']['App']['FormatFileSize'](arg1);
}

export function GetAvailableTerminals() {
  return window['go']['backend']['App']['GetAvailableTerminals']();
}

export function GetCurrentWorkingDirectory() {
  return window['go']['backend']['App']['GetCurrentWorkingDirectory']();
}

export function GetDriveInfo() {
  return window['go']['backend']['App']['GetDriveInfo']();
}

export function GetFileDetails(arg1) {
  return window['go']['backend']['App']['GetFileDetails'](arg1);
}

export function GetHomeDirectory() {
  return window['go']['backend']['App']['GetHomeDirectory']();
}

export function GetQuickAccessPaths() {
  return window['go']['backend']['App']['GetQuickAccessPaths']();
}

export function GetSystemRoots() {
  return window['go']['backend']['App']['GetSystemRoots']();
}

export function HealthCheck() {
  return window['go']['backend']['App']['HealthCheck']();
}

export function HideFiles(arg1) {
  return window['go']['backend']['App']['HideFiles'](arg1);
}

export function IsHidden(arg1) {
  return window['go']['backend']['App']['IsHidden'](arg1);
}

export function ListDirectory(arg1) {
  return window['go']['backend']['App']['ListDirectory'](arg1);
}

export function MoveFiles(arg1, arg2) {
  return window['go']['backend']['App']['MoveFiles'](arg1, arg2);
}

export function MoveFilesToRecycleBin(arg1) {
  return window['go']['backend']['App']['MoveFilesToRecycleBin'](arg1);
}

export function NavigateToPath(arg1) {
  return window['go']['backend']['App']['NavigateToPath'](arg1);
}

export function NavigateUp(arg1) {
  return window['go']['backend']['App']['NavigateUp'](arg1);
}

export function OpenFile(arg1) {
  return window['go']['backend']['App']['OpenFile'](arg1);
}

export function OpenInSystemExplorer(arg1) {
  return window['go']['backend']['App']['OpenInSystemExplorer'](arg1);
}

export function OpenPowerShellHere(arg1) {
  return window['go']['backend']['App']['OpenPowerShellHere'](arg1);
}

export function OpenTerminalHere(arg1) {
  return window['go']['backend']['App']['OpenTerminalHere'](arg1);
}

export function PrefetchDirectory(arg1) {
  return window['go']['backend']['App']['PrefetchDirectory'](arg1);
}

export function RenameFile(arg1, arg2) {
  return window['go']['backend']['App']['RenameFile'](arg1, arg2);
}

export function ValidatePath(arg1) {
  return window['go']['backend']['App']['ValidatePath'](arg1);
}


================================================
File: backend/types.go
================================================
package backend

import (
	"context"
	"time"
)

// FileInfo represents file/directory information
type FileInfo struct {
	Name        string    `json:"name"`
	Path        string    `json:"path"`
	IsDir       bool      `json:"isDir"`
	Size        int64     `json:"size"`
	ModTime     time.Time `json:"modTime"`
	Permissions string    `json:"permissions"`
	Extension   string    `json:"extension"`
	IsHidden    bool      `json:"isHidden"`
}

// DirectoryContents represents the contents of a directory
type DirectoryContents struct {
	CurrentPath string     `json:"currentPath"`
	ParentPath  string     `json:"parentPath"`
	Files       []FileInfo `json:"files"`
	Directories []FileInfo `json:"directories"`
	TotalFiles  int        `json:"totalFiles"`
	TotalDirs   int        `json:"totalDirs"`
}

// NavigationResponse represents navigation result
type NavigationResponse struct {
	Success bool              `json:"success"`
	Message string            `json:"message"`
	Data    DirectoryContents `json:"data"`
}

// DriveInfo represents information about a system drive
type DriveInfo struct {
	Path   string `json:"path"`
	Letter string `json:"letter"`
	Name   string `json:"name"`
}

// Interfaces for dependency injection and better testability

// FileSystemManagerInterface defines the file system operations contract
type FileSystemManagerInterface interface {
	ListDirectory(path string) NavigationResponse
	GetFileInfo(path string) (FileInfo, error)
	CreateFileInfo(basePath string, name string) FileInfo
	IsHidden(path string) bool
	GetExtension(name string) string
	NavigateToPath(path string) NavigationResponse
	NavigateUp(currentPath string) NavigationResponse
	CreateDirectory(path, name string) NavigationResponse
	ValidatePath(path string) error
	FileExists(path string) bool
}

// FileOperationsManagerInterface defines file operations contract
type FileOperationsManagerInterface interface {
	CopyFiles(sourcePaths []string, destDir string) bool
	MoveFiles(sourcePaths []string, destDir string) bool
	DeleteFiles(filePaths []string) bool
	MoveFilesToRecycleBin(filePaths []string) bool
	RenameFile(oldPath, newName string) bool
	HideFiles(filePaths []string) bool
	OpenFile(filePath string) bool
}

// PlatformManagerInterface defines OS-specific operations contract
type PlatformManagerInterface interface {
	GetHomeDirectory() string
	GetCurrentWorkingDirectory() string
	GetSystemRoots() []string
	OpenInSystemExplorer(path string) bool
	IsHiddenWindows(filePath string) bool
	IsHiddenMac(filePath string) bool
	IsHiddenLinux(filePath string) bool
	IsHidden(filePath string) bool
	GetExtension(name string) string
	HideFile(filePath string) bool
	OpenFile(filePath string) bool
	FormatFileSize(size int64) string
}

// DriveManagerInterface defines drive management contract
type DriveManagerInterface interface {
	GetDriveInfo() []DriveInfo
	GetQuickAccessPaths() []DriveInfo
}

// TerminalManagerInterface defines terminal operations contract
type TerminalManagerInterface interface {
	OpenPowerShellHere(directoryPath string) bool
	OpenTerminalHere(directoryPath string) bool
	GetAvailableTerminals() []string
	ExecuteCommand(command string, workingDir string) error
}

// App struct - Main application structure with dependency injection
type App struct {
	ctx        context.Context
	filesystem FileSystemManagerInterface
	fileOps    FileOperationsManagerInterface
	platform   PlatformManagerInterface
	drives     DriveManagerInterface
	terminal   TerminalManagerInterface
}

// FileSystemManager implementation
type FileSystemManager struct {
	platform     PlatformManagerInterface
	ctx          context.Context
	eventEmitter *EventEmitter
}

// FileOperationsManager implementation
type FileOperationsManager struct {
	platform PlatformManagerInterface
}

// PlatformManager implementation
type PlatformManager struct{}

// DriveManager implementation
type DriveManager struct{}

// TerminalManager implementation
type TerminalManager struct{}


================================================
File: frontend/src/assets/preact.svg
================================================
<svg xmlns="http://www.w3.org/2000/svg" width="27.68" height="32" aria-hidden="true" class="iconify iconify--logos" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 256 296"><path fill="#673AB8" d="m128 0l128 73.9v147.8l-128 73.9L0 221.7V73.9z"/><path fill="#FFF" d="M34.865 220.478c17.016 21.78 71.095 5.185 122.15-34.704c51.055-39.888 80.24-88.345 63.224-110.126c-17.017-21.78-71.095-5.184-122.15 34.704c-51.055 39.89-80.24 88.346-63.224 110.126Zm7.27-5.68c-5.644-7.222-3.178-21.402 7.573-39.253c11.322-18.797 30.541-39.548 54.06-57.923c23.52-18.375 48.303-32.004 69.281-38.442c19.922-6.113 34.277-5.075 39.92 2.148c5.644 7.223 3.178 21.403-7.573 39.254c-11.322 18.797-30.541 39.547-54.06 57.923c-23.52 18.375-48.304 32.004-69.281 38.441c-19.922 6.114-34.277 5.076-39.92-2.147Z"/><path fill="#FFF" d="M220.239 220.478c17.017-21.78-12.169-70.237-63.224-110.126C105.96 70.464 51.88 53.868 34.865 75.648c-17.017 21.78 12.169 70.238 63.224 110.126c51.055 39.889 105.133 56.485 122.15 34.704Zm-7.27-5.68c-5.643 7.224-19.998 8.262-39.92 2.148c-20.978-6.437-45.761-20.066-69.28-38.441c-23.52-18.376-42.74-39.126-54.06-57.923c-10.752-17.851-13.218-32.03-7.575-39.254c5.644-7.223 19.999-8.261 39.92-2.148c20.978 6.438 45.762 20.067 69.281 38.442c23.52 18.375 42.739 39.126 54.06 57.923c10.752 17.85 13.218 32.03 7.574 39.254Z"/><path fill="#FFF" d="M127.552 167.667c10.827 0 19.603-8.777 19.603-19.604c0-10.826-8.776-19.603-19.603-19.603c-10.827 0-19.604 8.777-19.604 19.603c0 10.827 8.777 19.604 19.604 19.604Z"/></svg>

================================================
File: frontend/src/components/ContextMenu.jsx
================================================
import { useRef, useEffect } from "preact/hooks";
import { memo } from "preact/compat";

// Memoized Context Menu Component
const ContextMenu = memo(({ visible, x, y, files, onClose, onPermanentDelete, onCopy, onCut, onRename, onHide }) => {
    const menuRef = useRef(null);
    
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
                onClose();
            }
        };
        
        if (visible) {
            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
        }
    }, [visible, onClose]);
    
    if (!visible) return null;
    
    return (
        <div 
            ref={menuRef}
            className="context-menu"
            onSelectStart={(e) => e.preventDefault()}
            style={{ 
                position: 'fixed', 
                left: x, 
                top: y, 
                zIndex: 1000 
            }}
        >
            <div className="context-menu-item" onClick={onCopy}>
                <span className="context-menu-icon">[C]</span>
                <span className="context-menu-text">Copy ({files.length})</span>
            </div>
            <div className="context-menu-item" onClick={onCut}>
                <span className="context-menu-icon">[X]</span>
                <span className="context-menu-text">Cut ({files.length})</span>
            </div>
            <div className="context-menu-separator"></div>
            {files.length === 1 && (
                <div className="context-menu-item" onClick={onRename}>
                    <span className="context-menu-icon">[F2]</span>
                    <span className="context-menu-text">Rename</span>
                </div>
            )}
            <div className="context-menu-separator"></div>
            <div className="context-menu-item" onClick={onHide} style={{ color: 'var(--zen-text-secondary)' }}>
                <span className="context-menu-icon">[H]</span>
                <span className="context-menu-text">Hide ({files.length})</span>
            </div>
            <div className="context-menu-item" onClick={onPermanentDelete} style={{ color: 'var(--zen-error)' }}>
                <span className="context-menu-icon">[!]</span>
                <span className="context-menu-text">Delete ({files.length})</span>
            </div>
        </div>
    );
});

export { ContextMenu };
export default ContextMenu; 

================================================
File: frontend/wailsjs/runtime/runtime.js
================================================
/*
 _       __      _ __
| |     / /___ _(_) /____
| | /| / / __ `/ / / ___/
| |/ |/ / /_/ / / (__  )
|__/|__/\__,_/_/_/____/
The electron alternative for Go
(c) Lea Anthony 2019-present
*/

export function LogPrint(message) {
    window.runtime.LogPrint(message);
}

export function LogTrace(message) {
    window.runtime.LogTrace(message);
}

export function LogDebug(message) {
    window.runtime.LogDebug(message);
}

export function LogInfo(message) {
    window.runtime.LogInfo(message);
}

export function LogWarning(message) {
    window.runtime.LogWarning(message);
}

export function LogError(message) {
    window.runtime.LogError(message);
}

export function LogFatal(message) {
    window.runtime.LogFatal(message);
}

export function EventsOnMultiple(eventName, callback, maxCallbacks) {
    return window.runtime.EventsOnMultiple(eventName, callback, maxCallbacks);
}

export function EventsOn(eventName, callback) {
    return EventsOnMultiple(eventName, callback, -1);
}

export function EventsOff(eventName, ...additionalEventNames) {
    return window.runtime.EventsOff(eventName, ...additionalEventNames);
}

export function EventsOnce(eventName, callback) {
    return EventsOnMultiple(eventName, callback, 1);
}

export function EventsEmit(eventName) {
    let args = [eventName].slice.call(arguments);
    return window.runtime.EventsEmit.apply(null, args);
}

export function WindowReload() {
    window.runtime.WindowReload();
}

export function WindowReloadApp() {
    window.runtime.WindowReloadApp();
}

export function WindowSetAlwaysOnTop(b) {
    window.runtime.WindowSetAlwaysOnTop(b);
}

export function WindowSetSystemDefaultTheme() {
    window.runtime.WindowSetSystemDefaultTheme();
}

export function WindowSetLightTheme() {
    window.runtime.WindowSetLightTheme();
}

export function WindowSetDarkTheme() {
    window.runtime.WindowSetDarkTheme();
}

export function WindowCenter() {
    window.runtime.WindowCenter();
}

export function WindowSetTitle(title) {
    window.runtime.WindowSetTitle(title);
}

export function WindowFullscreen() {
    window.runtime.WindowFullscreen();
}

export function WindowUnfullscreen() {
    window.runtime.WindowUnfullscreen();
}

export function WindowIsFullscreen() {
    return window.runtime.WindowIsFullscreen();
}

export function WindowGetSize() {
    return window.runtime.WindowGetSize();
}

export function WindowSetSize(width, height) {
    window.runtime.WindowSetSize(width, height);
}

export function WindowSetMaxSize(width, height) {
    window.runtime.WindowSetMaxSize(width, height);
}

export function WindowSetMinSize(width, height) {
    window.runtime.WindowSetMinSize(width, height);
}

export function WindowSetPosition(x, y) {
    window.runtime.WindowSetPosition(x, y);
}

export function WindowGetPosition() {
    return window.runtime.WindowGetPosition();
}

export function WindowHide() {
    window.runtime.WindowHide();
}

export function WindowShow() {
    window.runtime.WindowShow();
}

export function WindowMaximise() {
    window.runtime.WindowMaximise();
}

export function WindowToggleMaximise() {
    window.runtime.WindowToggleMaximise();
}

export function WindowUnmaximise() {
    window.runtime.WindowUnmaximise();
}

export function WindowIsMaximised() {
    return window.runtime.WindowIsMaximised();
}

export function WindowMinimise() {
    window.runtime.WindowMinimise();
}

export function WindowUnminimise() {
    window.runtime.WindowUnminimise();
}

export function WindowSetBackgroundColour(R, G, B, A) {
    window.runtime.WindowSetBackgroundColour(R, G, B, A);
}

export function ScreenGetAll() {
    return window.runtime.ScreenGetAll();
}

export function WindowIsMinimised() {
    return window.runtime.WindowIsMinimised();
}

export function WindowIsNormal() {
    return window.runtime.WindowIsNormal();
}

export function BrowserOpenURL(url) {
    window.runtime.BrowserOpenURL(url);
}

export function Environment() {
    return window.runtime.Environment();
}

export function Quit() {
    window.runtime.Quit();
}

export function Hide() {
    window.runtime.Hide();
}

export function Show() {
    window.runtime.Show();
}

export function ClipboardGetText() {
    return window.runtime.ClipboardGetText();
}

export function ClipboardSetText(text) {
    return window.runtime.ClipboardSetText(text);
}

/**
 * Callback for OnFileDrop returns a slice of file path strings when a drop is finished.
 *
 * @export
 * @callback OnFileDropCallback
 * @param {number} x - x coordinate of the drop
 * @param {number} y - y coordinate of the drop
 * @param {string[]} paths - A list of file paths.
 */

/**
 * OnFileDrop listens to drag and drop events and calls the callback with the coordinates of the drop and an array of path strings.
 *
 * @export
 * @param {OnFileDropCallback} callback - Callback for OnFileDrop returns a slice of file path strings when a drop is finished.
 * @param {boolean} [useDropTarget=true] - Only call the callback when the drop finished on an element that has the drop target style. (--wails-drop-target)
 */
export function OnFileDrop(callback, useDropTarget) {
    return window.runtime.OnFileDrop(callback, useDropTarget);
}

/**
 * OnFileDropOff removes the drag and drop listeners and handlers.
 */
export function OnFileDropOff() {
    return window.runtime.OnFileDropOff();
}

export function CanResolveFilePaths() {
    return window.runtime.CanResolveFilePaths();
}

export function ResolveFilePaths(files) {
    return window.runtime.ResolveFilePaths(files);
}

================================================
File: frontend/vite.config.js
================================================
import {defineConfig} from 'vite'
import preact from '@preact/preset-vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [preact()]
})


================================================
File: main.go
================================================
package main

import (
	"embed"

	"github.com/wailsapp/wails/v2"
	"github.com/wailsapp/wails/v2/pkg/options"
	"github.com/wailsapp/wails/v2/pkg/options/assetserver"

	"testui/backend"
)

//go:embed all:frontend/dist
var assets embed.FS

func main() {
	// Create an instance of the app structure
	app := backend.NewApp()

	// Create application with options
	err := wails.Run(&options.App{
		Title:  "Blueprint File Explorer",
		Width:  1400,
		Height: 900,
		AssetServer: &assetserver.Options{
			Assets: assets,
		},
		BackgroundColour: &options.RGBA{R: 27, G: 38, B: 54, A: 1},
		OnStartup:        app.Startup,
		Bind: []interface{}{
			app,
		},
	})

	if err != nil {
		println("Error:", err.Error())
	}
}


================================================
File: go.sum
================================================
github.com/bep/debounce v1.2.1 h1:v67fRdBA9UQu2NhLFXrSg0Brw7CexQekrBwDMM8bzeY=
github.com/bep/debounce v1.2.1/go.mod h1:H8yggRPQKLUhUoqrJC1bO2xNya7vanpDl7xR3ISbCJ0=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/go-ole/go-ole v1.3.0 h1:Dt6ye7+vXGIKZ7Xtk4s6/xVdGDQynvom7xCFEdWr6uE=
github.com/go-ole/go-ole v1.3.0/go.mod h1:5LS6F96DhAwUc7C+1HLexzMXY1xGRSryjyPPKW6zv78=
github.com/godbus/dbus/v5 v5.1.0 h1:4KLkAxT3aOY8Li4FRJe/KvhoNFFxo0m6fNuFUO8QJUk=
github.com/godbus/dbus/v5 v5.1.0/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e h1:Q3+PugElBCf4PFpxhErSzU3/PY5sFL5Z6rfv4AbGAck=
github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e/go.mod h1:alcuEEnZsY1WQsagKhZDsoPCRoOijYqhZvPwLG0kzVs=
github.com/labstack/echo/v4 v4.13.3 h1:pwhpCPrTl5qry5HRdM5FwdXnhXSLSY+WE+YQSeCaafY=
github.com/labstack/echo/v4 v4.13.3/go.mod h1:o90YNEeQWjDozo584l7AwhJMHN0bOC4tAfg+Xox9q5g=
github.com/labstack/gommon v0.4.2 h1:F8qTUNXgG1+6WQmqoUWnz8WiEU60mXVVw0P4ht1WRA0=
github.com/labstack/gommon v0.4.2/go.mod h1:QlUFxVM+SNXhDL/Z7YhocGIBYOiwB0mXm1+1bAPHPyU=
github.com/leaanthony/debme v1.2.1 h1:9Tgwf+kjcrbMQ4WnPcEIUcQuIZYqdWftzZkBr+i/oOc=
github.com/leaanthony/debme v1.2.1/go.mod h1:3V+sCm5tYAgQymvSOfYQ5Xx2JCr+OXiD9Jkw3otUjiA=
github.com/leaanthony/go-ansi-parser v1.6.1 h1:xd8bzARK3dErqkPFtoF9F3/HgN8UQk0ed1YDKpEz01A=
github.com/leaanthony/go-ansi-parser v1.6.1/go.mod h1:+vva/2y4alzVmmIEpk9QDhA7vLC5zKDTRwfZGOp3IWU=
github.com/leaanthony/gosod v1.0.4 h1:YLAbVyd591MRffDgxUOU1NwLhT9T1/YiwjKZpkNFeaI=
github.com/leaanthony/gosod v1.0.4/go.mod h1:GKuIL0zzPj3O1SdWQOdgURSuhkF+Urizzxh26t9f1cw=
github.com/leaanthony/slicer v1.6.0 h1:1RFP5uiPJvT93TAHi+ipd3NACobkW53yUiBqZheE/Js=
github.com/leaanthony/slicer v1.6.0/go.mod h1:o/Iz29g7LN0GqH3aMjWAe90381nyZlDNquK+mtH2Fj8=
github.com/leaanthony/u v1.1.1 h1:TUFjwDGlNX+WuwVEzDqQwC2lOv0P4uhTQw7CMFdiK7M=
github.com/leaanthony/u v1.1.1/go.mod h1:9+o6hejoRljvZ3BzdYlVL0JYCwtnAsVuN9pVTQcaRfI=
github.com/matryer/is v1.4.0/go.mod h1:8I/i5uYgLzgsgEloJE1U6xx5HkBQpAZvepWuujKwMRU=
github.com/matryer/is v1.4.1 h1:55ehd8zaGABKLXQUe2awZ99BD/PTc2ls+KV/dXphgEQ=
github.com/matryer/is v1.4.1/go.mod h1:8I/i5uYgLzgsgEloJE1U6xx5HkBQpAZvepWuujKwMRU=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c h1:+mdjkGKdHQG3305AYmdv1U2eRNDiU2ErMBj1gwrq8eQ=
github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c/go.mod h1:7rwL4CYBLnjLxUqIJNnCWiEdr3bn6IUYi15bNlnbCCU=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/samber/lo v1.49.1 h1:4BIFyVfuQSEpluc7Fua+j1NolZHiEHEpaSEKdsH0tew=
github.com/samber/lo v1.49.1/go.mod h1:dO6KHFzUKXgP8LDhU0oI8d2hekjXnGOu0DB8Jecxd6o=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/tkrajina/go-reflector v0.5.8 h1:yPADHrwmUbMq4RGEyaOUpz2H90sRsETNVpjzo3DLVQQ=
github.com/tkrajina/go-reflector v0.5.8/go.mod h1:ECbqLgccecY5kPmPmXg1MrHW585yMcDkVl6IvJe64T4=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasttemplate v1.2.2 h1:lxLXG0uE3Qnshl9QyaK6XJxMXlQZELvChBOCmQD0Loo=
github.com/valyala/fasttemplate v1.2.2/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=
github.com/wailsapp/go-webview2 v1.0.19 h1:7U3QcDj1PrBPaxJNCui2k1SkWml+Q5kvFUFyTImA6NU=
github.com/wailsapp/go-webview2 v1.0.19/go.mod h1:qJmWAmAmaniuKGZPWwne+uor3AHMB5PFhqiK0Bbj8kc=
github.com/wailsapp/mimetype v1.4.1 h1:pQN9ycO7uo4vsUUuPeHEYoUkLVkaRntMnHJxVwYhwHs=
github.com/wailsapp/mimetype v1.4.1/go.mod h1:9aV5k31bBOv5z6u+QP8TltzvNGJPmNJD4XlAL3U+j3o=
github.com/wailsapp/wails/v2 v2.10.1 h1:QWHvWMXII2nI/nXz77gpPG8P3ehl6zKe+u4su5BWIns=
github.com/wailsapp/wails/v2 v2.10.1/go.mod h1:zrebnFV6MQf9kx8HI4iAv63vsR5v67oS7GTEZ7Pz1TY=
golang.org/x/crypto v0.33.0 h1:IOBPskki6Lysi0lo9qQvbxiQ+FvsCC/YWOecCHAixus=
golang.org/x/crypto v0.33.0/go.mod h1:bVdXmD7IV/4GdElGPozy6U7lWdRXA4qyRVGJV57uQ5M=
golang.org/x/net v0.0.0-20210505024714-0287a6fb4125/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.35.0 h1:T5GQRQb2y08kTAByq9L4/bz8cipCdA8FbRTXewonqY8=
golang.org/x/net v0.35.0/go.mod h1:EglIi67kWsHKlRzzVMUD93VMSWGFOMSZgxFjparz1Qk=
golang.org/x/sys v0.0.0-20200810151505-1b9f1253b3ed/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=
golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.22.0 h1:bofq7m3/HAFvbF51jz3Q9wLg3jkvSPuiZu/pD1XwgtM=
golang.org/x/text v0.22.0/go.mod h1:YRoo4H8PVmsu+E3Ou7cqLVH8oXWIHVoX0jqUWALQhfY=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


================================================
File: frontend/wailsjs/runtime/package.json
================================================
{
  "name": "@wailsapp/runtime",
  "version": "2.0.0",
  "description": "Wails Javascript runtime library",
  "main": "runtime.js",
  "types": "runtime.d.ts",
  "scripts": {
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/wailsapp/wails.git"
  },
  "keywords": [
    "Wails",
    "Javascript",
    "Go"
  ],
  "author": "Lea Anthony <lea.anthony@gmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/wailsapp/wails/issues"
  },
  "homepage": "https://github.com/wailsapp/wails#readme"
}


================================================
File: wails.json
================================================
{
  "$schema": "https://wails.io/schemas/config.v2.json",
  "name": "testui",
  "outputfilename": "testui",
  "frontend:install": "bun install",
  "frontend:build": "bun run build",
  "frontend:dev:watcher": "bun run dev",
  "frontend:dev:serverUrl": "auto",
  "author": {
    "name": "YourAverageDev",
    "email": "andrewzhuangyue@hotmail.com"
  }
}


================================================
File: frontend/src/utils/logger.js
================================================
// Logger utility to gate console logging in production
export const debug = process.env.NODE_ENV !== 'production';

export const log = (...args) => { 
    if (debug) console.log(...args); 
};

export const warn = (...args) => { 
    if (debug) console.warn(...args); 
};

export const error = (...args) => { 
    if (debug) console.error(...args); 
};

export const time = (label) => { 
    if (debug) console.time(label); 
};

export const timeEnd = (label) => { 
    if (debug) console.timeEnd(label); 
};

export const group = (label) => { 
    if (debug) console.group(label); 
};

export const groupEnd = () => { 
    if (debug) console.groupEnd(); 
}; 

================================================
File: backend/fileops.go
================================================
package backend

import (
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

// NewFileOperationsManager creates a new file operations manager instance
func NewFileOperationsManager(platform PlatformManagerInterface) *FileOperationsManager {
	return &FileOperationsManager{
		platform: platform,
	}
}

// CopyFiles copies files from source paths to destination directory
func (fo *FileOperationsManager) CopyFiles(sourcePaths []string, destDir string) bool {
	log.Printf("Copying %d files to: %s", len(sourcePaths), destDir)

	for _, srcPath := range sourcePaths {
		srcInfo, err := os.Stat(srcPath)
		if err != nil {
			log.Printf("Error getting source file info: %v", err)
			return false
		}

		destPath := filepath.Join(destDir, filepath.Base(srcPath))

		if srcInfo.IsDir() {
			err = fo.copyDir(srcPath, destPath)
		} else {
			err = fo.copyFile(srcPath, destPath)
		}

		if err != nil {
			log.Printf("Error copying %s: %v", srcPath, err)
			return false
		}

		// Verify the copy was successful
		if _, err := os.Stat(destPath); err != nil {
			log.Printf("Copy verification failed for %s: %v", destPath, err)
			return false
		}
	}

	log.Printf("Successfully copied %d files to %s", len(sourcePaths), destDir)
	return true
}

// MoveFiles moves files from source paths to destination directory
func (fo *FileOperationsManager) MoveFiles(sourcePaths []string, destDir string) bool {
	log.Printf("Moving %d files to: %s", len(sourcePaths), destDir)

	for _, srcPath := range sourcePaths {
		destPath := filepath.Join(destDir, filepath.Base(srcPath))

		err := os.Rename(srcPath, destPath)
		if err != nil {
			// If rename fails, try copy + delete (for cross-drive moves)
			if err := fo.copyAndDelete(srcPath, destPath); err != nil {
				log.Printf("Error moving %s: %v", srcPath, err)
				return false
			}
		}

		// Verify the move was successful
		if _, err := os.Stat(destPath); err != nil {
			log.Printf("Move verification failed for %s: %v", destPath, err)
			return false
		}
	}

	log.Printf("Successfully moved %d files to %s", len(sourcePaths), destDir)
	return true
}

// DeleteFiles permanently deletes the specified files and directories
func (fo *FileOperationsManager) DeleteFiles(filePaths []string) bool {
	log.Printf("Permanently deleting %d files", len(filePaths))

	for _, filePath := range filePaths {
		err := os.RemoveAll(filePath)
		if err != nil {
			log.Printf("Error permanently deleting %s: %v", filePath, err)
			return false
		}
	}

	return true
}

// MoveFilesToRecycleBin moves files to the system recycle bin/trash
func (fo *FileOperationsManager) MoveFilesToRecycleBin(filePaths []string) bool {
	log.Printf("Moving %d files to recycle bin", len(filePaths))

	for _, filePath := range filePaths {
		success := fo.moveToRecycleBin(filePath)
		if !success {
			log.Printf("Error moving %s to recycle bin", filePath)
			return false
		}
	}

	return true
}

// RenameFile renames a file or directory
func (fo *FileOperationsManager) RenameFile(oldPath, newName string) bool {
	log.Printf("Renaming %s to %s", oldPath, newName)

	// Validate inputs
	if oldPath == "" || newName == "" {
		log.Printf("Error: Empty path or new name provided")
		return false
	}

	// Get the directory containing the file
	dir := filepath.Dir(oldPath)
	newPath := filepath.Join(dir, newName)

	// Check if old path exists
	if _, err := os.Stat(oldPath); os.IsNotExist(err) {
		log.Printf("Error: Source file does not exist: %s", oldPath)
		return false
	}

	// Check if new path already exists
	if _, err := os.Stat(newPath); err == nil {
		log.Printf("Error: Destination already exists: %s", newPath)
		return false
	}

	// Perform the rename
	err := os.Rename(oldPath, newPath)
	if err != nil {
		log.Printf("Error renaming file: %v", err)
		return false
	}

	log.Printf("Successfully renamed %s to %s", oldPath, newPath)
	return true
}

// HideFiles sets the hidden attribute on the specified files
func (fo *FileOperationsManager) HideFiles(filePaths []string) bool {
	log.Printf("Hiding %d files", len(filePaths))

	for _, filePath := range filePaths {
		success := fo.platform.HideFile(filePath)
		if !success {
			log.Printf("Error hiding file: %s", filePath)
			return false
		}
	}

	log.Printf("Successfully hid %d files", len(filePaths))
	return true
}

// OpenFile opens a file with its default application
func (fo *FileOperationsManager) OpenFile(filePath string) bool {
	return fo.platform.OpenFile(filePath)
}

// Helper methods

// copyFile copies a single file with optimized buffer size for better performance
func (fo *FileOperationsManager) copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	// Use optimized buffer size for better performance (64KB)
	buffer := make([]byte, 64*1024)
	_, err = io.CopyBuffer(destFile, sourceFile, buffer)
	if err != nil {
		return err
	}

	// Copy file permissions and timestamps
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	os.Chmod(dst, srcInfo.Mode())
	os.Chtimes(dst, srcInfo.ModTime(), srcInfo.ModTime())

	return nil
}

// copyDir recursively copies a directory with progress tracking
func (fo *FileOperationsManager) copyDir(src, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	err = os.MkdirAll(dst, srcInfo.Mode())
	if err != nil {
		return err
	}

	entries, err := os.ReadDir(src)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		dstPath := filepath.Join(dst, entry.Name())

		if entry.IsDir() {
			err = fo.copyDir(srcPath, dstPath)
		} else {
			err = fo.copyFile(srcPath, dstPath)
		}

		if err != nil {
			return err
		}
	}

	return nil
}

// copyAndDelete copies a file/directory then deletes the original (for cross-drive moves)
func (fo *FileOperationsManager) copyAndDelete(src, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	if srcInfo.IsDir() {
		return fo.copyDirAndDelete(src, dst)
	}

	return fo.copyFileAndDelete(src, dst)
}

// copyFileAndDelete copies a file and then deletes the original
func (fo *FileOperationsManager) copyFileAndDelete(src, dst string) error {
	err := fo.copyFile(src, dst)
	if err != nil {
		return err
	}

	return os.Remove(src)
}

// copyDirAndDelete recursively copies a directory and then deletes the original
func (fo *FileOperationsManager) copyDirAndDelete(src, dst string) error {
	err := fo.copyDir(src, dst)
	if err != nil {
		return err
	}

	return os.RemoveAll(src)
}

// moveToRecycleBin moves a single file to the recycle bin using OS-specific methods
func (fo *FileOperationsManager) moveToRecycleBin(filePath string) bool {
	switch runtime.GOOS {
	case "windows":
		return fo.moveToWindowsRecycleBin(filePath)
	case "darwin":
		return fo.moveToMacTrash(filePath)
	case "linux":
		return fo.moveToLinuxTrash(filePath)
	default:
		log.Printf("Recycle bin not supported on %s, falling back to permanent delete", runtime.GOOS)
		return os.RemoveAll(filePath) == nil
	}
}

// moveToWindowsRecycleBin moves file to Windows Recycle Bin using optimized method
func (fo *FileOperationsManager) moveToWindowsRecycleBin(filePath string) bool {
	log.Printf("Moving to Windows Recycle Bin: %s", filePath)

	// Get current user SID efficiently
	userSID, err := fo.getCurrentUserSID()
	if err != nil {
		log.Printf("Failed to get user SID: %v", err)
		return false
	}

	// Get the drive letter from the file path
	if len(filePath) < 2 || filePath[1] != ':' {
		log.Printf("Invalid file path format: %s", filePath)
		return false
	}

	driveLetter := strings.ToUpper(string(filePath[0]))
	recycleBinPath := fmt.Sprintf("%s:\\$Recycle.Bin\\%s", driveLetter, userSID)

	// Create recycle bin directory if it doesn't exist
	err = os.MkdirAll(recycleBinPath, 0755)
	if err != nil {
		log.Printf("Failed to create recycle bin directory: %v", err)
		return false
	}

	// Generate unique filename in recycle bin
	originalName := filepath.Base(filePath)
	recycleBinFile := filepath.Join(recycleBinPath, originalName)

	// Handle filename conflicts
	if fo.fileExists(recycleBinFile) {
		recycleBinFile = fo.generateUniqueRecycleBinPath(recycleBinPath, originalName)
	}

	// Move file to recycle bin
	err = os.Rename(filePath, recycleBinFile)
	if err != nil {
		// If rename fails, try copy + delete (for cross-drive moves)
		err = fo.copyAndDelete(filePath, recycleBinFile)
		if err != nil {
			log.Printf("Failed to move file to recycle bin: %v", err)
			return false
		}
	}

	log.Printf("Successfully moved to recycle bin: %s -> %s", filePath, recycleBinFile)
	return true
}

// getCurrentUserSID gets the current user's SID using optimized method
func (fo *FileOperationsManager) getCurrentUserSID() (string, error) {
	cmd := exec.Command("whoami", "/user", "/fo", "csv", "/nh")
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("whoami failed: %v", err)
	}

	// Parse CSV output: "DOMAIN\username","S-1-5-..."
	csvLine := strings.TrimSpace(string(output))
	if len(csvLine) < 10 {
		return "", fmt.Errorf("invalid whoami output: %s", csvLine)
	}

	// Extract SID from CSV (second column)
	parts := strings.Split(csvLine, ",")
	if len(parts) < 2 {
		return "", fmt.Errorf("could not parse SID from: %s", csvLine)
	}

	sid := strings.Trim(parts[1], `"`)
	if !strings.HasPrefix(sid, "S-1-5-") {
		return "", fmt.Errorf("invalid SID format: %s", sid)
	}

	return sid, nil
}

// fileExists checks if a file exists
func (fo *FileOperationsManager) fileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

// generateUniqueRecycleBinPath creates a unique filename for the recycle bin
func (fo *FileOperationsManager) generateUniqueRecycleBinPath(recycleBinDir, originalName string) string {
	ext := filepath.Ext(originalName)
	nameWithoutExt := strings.TrimSuffix(originalName, ext)

	for counter := 1; counter < 1000; counter++ {
		newName := fmt.Sprintf("%s (%d)%s", nameWithoutExt, counter, ext)
		newPath := filepath.Join(recycleBinDir, newName)

		if !fo.fileExists(newPath) {
			return newPath
		}
	}

	// Fallback with timestamp if we hit 1000 conflicts
	timestamp := fmt.Sprintf("%d", time.Now().Unix())
	newName := fmt.Sprintf("%s_%s%s", nameWithoutExt, timestamp, ext)
	return filepath.Join(recycleBinDir, newName)
}

// moveToMacTrash moves file to macOS Trash
func (fo *FileOperationsManager) moveToMacTrash(filePath string) bool {
	cmd := exec.Command("osascript", "-e", fmt.Sprintf(`tell app "Finder" to delete POSIX file "%s"`, filePath))
	err := cmd.Run()
	return err == nil
}

// moveToLinuxTrash moves file to Linux trash (freedesktop.org standard)
func (fo *FileOperationsManager) moveToLinuxTrash(filePath string) bool {
	// Try using gio trash (modern method)
	cmd := exec.Command("gio", "trash", filePath)
	err := cmd.Run()

	if err != nil {
		// Fallback to gvfs-trash
		cmd = exec.Command("gvfs-trash", filePath)
		err = cmd.Run()

		if err != nil {
			// Final fallback: move to ~/.local/share/Trash
			homeDir, _ := os.UserHomeDir()
			trashDir := filepath.Join(homeDir, ".local", "share", "Trash", "files")

			// Create trash directory if it doesn't exist
			os.MkdirAll(trashDir, 0755)

			// Move file to trash
			fileName := filepath.Base(filePath)
			trashPath := filepath.Join(trashDir, fileName)

			return os.Rename(filePath, trashPath) == nil
		}
	}

	return true
}


================================================
File: frontend/wailsjs/go/backend/App.d.ts
================================================
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH √Ç MODIWL
// This file is automatically generated. DO NOT EDIT
import {backend} from '../models';

export function CopyFiles(arg1:Array<string>,arg2:string):Promise<boolean>;

export function CreateDirectory(arg1:string,arg2:string):Promise<backend.NavigationResponse>;

export function DeleteFiles(arg1:Array<string>):Promise<boolean>;

export function DeletePath(arg1:string):Promise<backend.NavigationResponse>;

export function ExecuteCommand(arg1:string,arg2:string):Promise<boolean>;

export function FileExists(arg1:string):Promise<boolean>;

export function FormatFileSize(arg1:number):Promise<string>;

export function GetAvailableTerminals():Promise<Array<string>>;

export function GetCurrentWorkingDirectory():Promise<string>;

export function GetDriveInfo():Promise<Array<Record<string, any>>>;

export function GetFileDetails(arg1:string):Promise<backend.FileInfo>;

export function GetHomeDirectory():Promise<string>;

export function GetQuickAccessPaths():Promise<Array<Record<string, any>>>;

export function GetSystemRoots():Promise<Array<string>>;

export function HealthCheck():Promise<Record<string, any>>;

export function HideFiles(arg1:Array<string>):Promise<boolean>;

export function IsHidden(arg1:string):Promise<boolean>;

export function ListDirectory(arg1:string):Promise<backend.NavigationResponse>;

export function MoveFiles(arg1:Array<string>,arg2:string):Promise<boolean>;

export function MoveFilesToRecycleBin(arg1:Array<string>):Promise<boolean>;

export function NavigateToPath(arg1:string):Promise<backend.NavigationResponse>;

export function NavigateUp(arg1:string):Promise<backend.NavigationResponse>;

export function OpenFile(arg1:string):Promise<boolean>;

export function OpenInSystemExplorer(arg1:string):Promise<boolean>;

export function OpenPowerShellHere(arg1:string):Promise<boolean>;

export function OpenTerminalHere(arg1:string):Promise<boolean>;

export function PrefetchDirectory(arg1:string):Promise<backend.NavigationResponse>;

export function RenameFile(arg1:string,arg2:string):Promise<boolean>;

export function ValidatePath(arg1:string):Promise<boolean>;


================================================
File: frontend/src/utils/debounce.js
================================================
// Debounce utility to prevent excessive function calls
export function debounce(func, wait, immediate = false) {
    let timeout;
    
    return function executedFunction(...args) {
        const later = () => {
            timeout = null;
            if (!immediate) func.apply(this, args);
        };
        
        const callNow = immediate && !timeout;
        
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        
        if (callNow) func.apply(this, args);
    };
}

// Enhanced throttle utility for high-frequency events
export function throttle(func, limit) {
    let inThrottle;
    
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// RAF-based throttle for smooth animations and scroll handling
export function rafThrottle(func) {
    let rafId = null;
    let lastArgs = null;
    
    return function(...args) {
        lastArgs = args;
        
        if (rafId === null) {
            rafId = requestAnimationFrame(() => {
                func.apply(this, lastArgs);
                rafId = null;
            });
        }
    };
}

// RequestIdleCallback wrapper with fallback
export function idleCallback(func, options = {}) {
    if (typeof requestIdleCallback !== 'undefined') {
        return requestIdleCallback(func, options);
    } else {
        // Fallback for browsers without requestIdleCallback
        return setTimeout(func, 1);
    }
}

// Batch DOM reads to avoid layout thrashing
export function batchReads(readFunctions) {
    return new Promise(resolve => {
        requestAnimationFrame(() => {
            const results = readFunctions.map(fn => fn());
            resolve(results);
        });
    });
}

// Batch DOM writes to optimize rendering
export function batchWrites(writeFunctions) {
    requestAnimationFrame(() => {
        writeFunctions.forEach(fn => fn());
    });
}

// Specialized debounce for navigation operations (super fast)
export const debouncedNavigate = debounce((navigateFunc, path) => {
    navigateFunc(path);
}, 50); // Much faster for responsive navigation

// Specialized RAF throttle for scroll events (smoother than timer-based)
export const rafThrottledScroll = rafThrottle((scrollFunc, event) => {
    scrollFunc(event);
});

// Legacy throttle for scroll events (keeping for compatibility)
export const throttledScroll = throttle((scrollFunc, event) => {
    scrollFunc(event);
}, 16); // ~60fps

// Specialized debounce for file operations
export const debouncedFileOperation = debounce((operationFunc, ...args) => {
    operationFunc(...args);
}, 75); // Slightly faster for better responsiveness 

================================================
File: frontend/wailsjs/go/models.ts
================================================
export namespace backend {
	
	export class FileInfo {
	    name: string;
	    path: string;
	    isDir: boolean;
	    size: number;
	    // Go type: time
	    modTime: any;
	    permissions: string;
	    extension: string;
	    isHidden: boolean;
	
	    static createFrom(source: any = {}) {
	        return new FileInfo(source);
	    }
	
	    constructor(source: any = {}) {
	        if ('string' === typeof source) source = JSON.parse(source);
	        this.name = source["name"];
	        this.path = source["path"];
	        this.isDir = source["isDir"];
	        this.size = source["size"];
	        this.modTime = this.convertValues(source["modTime"], null);
	        this.permissions = source["permissions"];
	        this.extension = source["extension"];
	        this.isHidden = source["isHidden"];
	    }
	
		convertValues(a: any, classs: any, asMap: boolean = false): any {
		    if (!a) {
		        return a;
		    }
		    if (a.slice && a.map) {
		        return (a as any[]).map(elem => this.convertValues(elem, classs));
		    } else if ("object" === typeof a) {
		        if (asMap) {
		            for (const key of Object.keys(a)) {
		                a[key] = new classs(a[key]);
		            }
		            return a;
		        }
		        return new classs(a);
		    }
		    return a;
		}
	}
	export class DirectoryContents {
	    currentPath: string;
	    parentPath: string;
	    files: FileInfo[];
	    directories: FileInfo[];
	    totalFiles: number;
	    totalDirs: number;
	
	    static createFrom(source: any = {}) {
	        return new DirectoryContents(source);
	    }
	
	    constructor(source: any = {}) {
	        if ('string' === typeof source) source = JSON.parse(source);
	        this.currentPath = source["currentPath"];
	        this.parentPath = source["parentPath"];
	        this.files = this.convertValues(source["files"], FileInfo);
	        this.directories = this.convertValues(source["directories"], FileInfo);
	        this.totalFiles = source["totalFiles"];
	        this.totalDirs = source["totalDirs"];
	    }
	
		convertValues(a: any, classs: any, asMap: boolean = false): any {
		    if (!a) {
		        return a;
		    }
		    if (a.slice && a.map) {
		        return (a as any[]).map(elem => this.convertValues(elem, classs));
		    } else if ("object" === typeof a) {
		        if (asMap) {
		            for (const key of Object.keys(a)) {
		                a[key] = new classs(a[key]);
		            }
		            return a;
		        }
		        return new classs(a);
		    }
		    return a;
		}
	}
	
	export class NavigationResponse {
	    success: boolean;
	    message: string;
	    data: DirectoryContents;
	
	    static createFrom(source: any = {}) {
	        return new NavigationResponse(source);
	    }
	
	    constructor(source: any = {}) {
	        if ('string' === typeof source) source = JSON.parse(source);
	        this.success = source["success"];
	        this.message = source["message"];
	        this.data = this.convertValues(source["data"], DirectoryContents);
	    }
	
		convertValues(a: any, classs: any, asMap: boolean = false): any {
		    if (!a) {
		        return a;
		    }
		    if (a.slice && a.map) {
		        return (a as any[]).map(elem => this.convertValues(elem, classs));
		    } else if ("object" === typeof a) {
		        if (asMap) {
		            for (const key of Object.keys(a)) {
		                a[key] = new classs(a[key]);
		            }
		            return a;
		        }
		        return new classs(a);
		    }
		    return a;
		}
	}

}



================================================
File: frontend/src/utils/styleConstants.js
================================================
// Pre-compiled style constants for zen minimalist theme
// These styles are computed once at module load time for optimal performance

// Common positioning and layout styles
export const FIXED_POSITION_STYLE = {
    position: 'fixed',
    zIndex: 1000
};

export const CONTEXT_MENU_STYLE = {
    position: 'fixed',
    zIndex: 1000,
    background: 'var(--zen-surface)',
    border: '1px solid var(--zen-border)',
    borderRadius: 'var(--zen-radius-md)',
    boxShadow: 'var(--zen-shadow-lg)',
    minWidth: '200px',
    padding: 'var(--zen-space-sm)',
    backdropFilter: 'blur(16px)',
    WebkitBackdropFilter: 'blur(16px)'
};

export const LOADING_OVERLAY_STYLE = {
    textAlign: 'center',
    padding: 'var(--zen-space-3xl) var(--zen-space-2xl)',
    color: 'var(--zen-text-tertiary)',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: 'var(--zen-space-lg)'
};

export const EMPTY_DIRECTORY_STYLE = {
    textAlign: 'center',
    padding: 'var(--zen-space-3xl) var(--zen-space-2xl)',
    color: 'var(--zen-text-tertiary)',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: 'var(--zen-space-lg)'
};

export const LARGE_ICON_STYLE = {
    fontSize: '3rem',
    marginBottom: 'var(--zen-space-lg)',
    opacity: 0.5
};

export const LOADING_SPINNER_LARGE_STYLE = {
    width: '2rem',
    height: '2rem',
    marginBottom: 'var(--zen-space-lg)',
    border: '2px solid var(--zen-border)',
    borderTop: '2px solid var(--zen-primary)',
    borderRadius: '50%'
};

export const HEADER_STATS_STYLE = {
    marginLeft: 'auto',
    display: 'flex',
    alignItems: 'center',
    gap: 'var(--zen-space-lg)',
    fontSize: 'var(--zen-text-sm)',
    color: 'var(--zen-text-secondary)'
};

export const PERFORMANCE_INDICATOR_STYLE = {
    fontSize: 'var(--zen-text-xs)',
    opacity: 0.6,
    color: 'var(--zen-text-tertiary)',
    fontWeight: 500
};

export const CURRENT_PATH_INDICATOR_STYLE = {
    fontSize: 'var(--zen-text-sm)',
    opacity: 0.7,
    maxWidth: '200px',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    color: 'var(--zen-text-secondary)'
};

export const ERROR_DISMISS_BUTTON_STYLE = {
    marginLeft: 'var(--zen-space-lg)',
    background: 'none',
    border: 'none',
    color: 'inherit',
    textDecoration: 'underline',
    cursor: 'pointer',
    fontSize: 'var(--zen-text-sm)',
    padding: 'var(--zen-space-sm)',
    borderRadius: 'var(--zen-radius-sm)',
    transition: 'all 150ms ease'
};

export const STATUS_BAR_RIGHT_STYLE = {
    marginLeft: 'auto',
    fontSize: 'var(--zen-text-xs)',
    color: 'var(--zen-text-tertiary)'
};

// Animation and transition styles - More zen and subtle
export const TRANSFORM_TRANSITION_STYLE = {
    transition: 'transform 200ms ease-out, opacity 200ms ease-out',
    willChange: 'transform'
};

export const OPACITY_TRANSITION_STYLE = {
    transition: 'opacity 200ms ease-out'
};

// Layout helpers - More spacious
export const FLEX_CENTER_STYLE = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 'var(--zen-space-md)'
};

export const FLEX_COLUMN_STYLE = {
    display: 'flex',
    flexDirection: 'column',
    gap: 'var(--zen-space-md)'
};

export const FLEX_ROW_STYLE = {
    display: 'flex',
    flexDirection: 'row',
    alignItems: 'center',
    gap: 'var(--zen-space-md)'
};

// Spacing using zen variables
export const SMALL_MARGIN_STYLE = { margin: 'var(--zen-space-sm)' };
export const MEDIUM_MARGIN_STYLE = { margin: 'var(--zen-space-lg)' };
export const LARGE_MARGIN_STYLE = { margin: 'var(--zen-space-xl)' };

export const SMALL_PADDING_STYLE = { padding: 'var(--zen-space-sm)' };
export const MEDIUM_PADDING_STYLE = { padding: 'var(--zen-space-lg)' };
export const LARGE_PADDING_STYLE = { padding: 'var(--zen-space-xl)' };

// Text styles - More refined typography
export const MONOSPACE_STYLE = {
    fontFamily: "'JetBrains Mono', ui-monospace, 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace",
    fontSize: 'var(--zen-text-sm)',
    lineHeight: 1.5
};

export const TECHNICAL_TEXT_STYLE = {
    fontFamily: "inherit",
    fontSize: 'var(--zen-text-xs)',
    opacity: 0.8,
    color: 'var(--zen-text-tertiary)',
    fontWeight: 500
};

// Hidden/disabled styles
export const HIDDEN_STYLE = { display: 'none' };
export const INVISIBLE_STYLE = { visibility: 'hidden' };
export const DISABLED_STYLE = { 
    opacity: 0.5, 
    pointerEvents: 'none' 
};

// Drag and drop styles - More zen
export const DRAG_OVER_STYLE = {
    background: 'var(--zen-primary-alpha-hover)',
    borderColor: 'var(--zen-primary)',
    transform: 'scale(1.02)',
    boxShadow: 'var(--zen-shadow-md)'
};

export const DRAG_PREVIEW_STYLE = {
    opacity: 0.6,
    transform: 'rotate(-2deg) scale(0.95)',
    filter: 'none'
};

// File item styles - Refined and spacious
export const FILE_ITEM_SELECTED_STYLE = {
    background: 'var(--zen-primary-alpha)',
    borderColor: 'var(--zen-primary)',
    color: 'var(--zen-primary)',
    transform: 'translateY(-1px)',
    boxShadow: 'var(--zen-shadow)'
};

export const FILE_ITEM_CUT_STYLE = {
    opacity: 0.6,
    filter: 'grayscale(30%)',
    borderStyle: 'dashed'
}; 

================================================
File: frontend/src/style.css
================================================
/* Local JetBrains Mono Font */
@font-face {
  font-family: 'JetBrains Mono';
  src: url('./assets/fonts/JetBrainsMono-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Zen Minimalist Theme - Modern & Spacious */
:root {
  /* Base colors - Calm and zen */
  --zen-bg: #fafafa;
  --zen-surface: #ffffff;
  --zen-surface-elevated: #ffffff;
  --zen-surface-hover: #f8f9fa;
  --zen-surface-active: #f1f3f4;
  
  /* Primary accent - Soft and calming */
  --zen-primary: #4f46e5;
  --zen-primary-light: #6366f1;
  --zen-primary-alpha: rgba(79, 70, 229, 0.08);
  --zen-primary-alpha-hover: rgba(79, 70, 229, 0.12);
  
  /* Borders and dividers - Very subtle */
  --zen-border: #e5e7eb;
  --zen-border-light: #f3f4f6;
  --zen-border-focus: #d1d5db;
  
  /* Text hierarchy - Clear and readable */
  --zen-text-primary: #111827;
  --zen-text-secondary: #6b7280;
  --zen-text-tertiary: #9ca3af;
  --zen-text-inverse: #ffffff;
  
  /* Status colors - Soft and non-intrusive */
  --zen-success: #059669;
  --zen-warning: #d97706;
  --zen-error: #dc2626;
  --zen-info: #0284c7;
  
  /* Shadows - Gentle and zen */
  --zen-shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --zen-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  --zen-shadow-md: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
  --zen-shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05);
  
  /* Spacing scale - Generous and consistent */
  --zen-space-xs: 0.25rem;  /* 4px */
  --zen-space-sm: 0.5rem;   /* 8px */
  --zen-space-md: 0.75rem;  /* 12px */
  --zen-space-lg: 1rem;     /* 16px */
  --zen-space-xl: 1.5rem;   /* 24px */
  --zen-space-2xl: 2rem;    /* 32px */
  --zen-space-3xl: 3rem;    /* 48px */
  
  /* Typography scale */
  --zen-text-xs: 0.75rem;   /* 12px */
  --zen-text-sm: 0.875rem;  /* 14px */
  --zen-text-base: 1rem;    /* 16px */
  --zen-text-lg: 1.125rem;  /* 18px */
  --zen-text-xl: 1.25rem;   /* 20px */
  --zen-text-2xl: 1.5rem;   /* 24px */
  
  /* Radius scale */
  --zen-radius-sm: 0.25rem; /* 4px */
  --zen-radius: 0.375rem;   /* 6px */
  --zen-radius-md: 0.5rem;  /* 8px */
  --zen-radius-lg: 0.75rem; /* 12px */
}

/* Base styles with better defaults */
* {
  box-sizing: border-box;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}

body {
  margin: 0;
  padding: 0;
  font-family: 'JetBrains Mono', ui-monospace, 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
  font-size: var(--zen-text-sm);
  line-height: 1.5;
  background: var(--zen-bg);
  color: var(--zen-text-primary);
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Performance optimizations */
.file-explorer,
.file-list {
  will-change: scroll-position;
  transform: translateZ(0);
}

/* Main layout structure - More spacious */
.file-explorer {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: var(--zen-bg);
}

/* Header - Clean and spacious */
.app-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--zen-space-lg) var(--zen-space-xl);
  background: var(--zen-surface);
  border-bottom: 1px solid var(--zen-border-light);
  min-height: 4rem;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

.app-title {
  font-size: var(--zen-text-xl);
  font-weight: 600;
  color: var(--zen-text-primary);
  margin: 0;
  letter-spacing: -0.025em;
}

/* Main content area - Better proportions */
.main-content {
  display: flex;
  flex: 1;
  min-height: 0;
  background: var(--zen-bg);
}

/* Sidebar - More refined */
.sidebar {
  width: 240px;
  background: var(--zen-surface);
  border-right: 1px solid var(--zen-border-light);
  display: flex;
  flex-direction: column;
  padding: var(--zen-space-lg);
  gap: var(--zen-space-xl);
}

.sidebar-section {
  display: flex;
  flex-direction: column;
  gap: var(--zen-space-sm);
}

.sidebar-title {
  font-size: var(--zen-text-xs);
  font-weight: 600;
  color: var(--zen-text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: var(--zen-space-sm);
}

.sidebar-item {
  display: flex;
  align-items: center;
  gap: var(--zen-space-md);
  padding: var(--zen-space-md) var(--zen-space-lg);
  border-radius: var(--zen-radius);
  color: var(--zen-text-secondary);
  cursor: pointer;
  transition: all 150ms ease;
  font-size: var(--zen-text-sm);
  min-height: 2.5rem;
}

.sidebar-item:hover:not(.active) {
  background: var(--zen-surface-hover);
  color: var(--zen-text-primary);
  transform: translateX(2px);
}

.sidebar-item.active {
  background: var(--zen-primary-alpha);
  color: var(--zen-primary);
  font-weight: 500;
}

.sidebar-icon {
  width: 1.25rem;
  height: 1.25rem;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

/* Content area - Spacious and clean */
.content-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  background: var(--zen-surface);
}

/* Toolbar - Modern and spacious */
.toolbar {
  display: flex;
  align-items: center;
  gap: var(--zen-space-sm);
  padding: var(--zen-space-lg) var(--zen-space-xl);
  background: var(--zen-surface);
  border-bottom: 1px solid var(--zen-border-light);
  min-height: 3.5rem;
}

.toolbar-btn {
  display: flex;
  align-items: center;
  gap: var(--zen-space-sm);
  padding: var(--zen-space-sm) var(--zen-space-lg);
  background: transparent;
  border: 1px solid var(--zen-border);
  border-radius: var(--zen-radius);
  color: var(--zen-text-secondary);
  font-size: var(--zen-text-sm);
  font-family: inherit;
  cursor: pointer;
  transition: all 150ms ease;
  min-height: 2.25rem;
  font-weight: 500;
}

.toolbar-btn:hover:not(:disabled) {
  background: var(--zen-surface-hover);
  border-color: var(--zen-border-focus);
  color: var(--zen-text-primary);
  transform: translateY(-1px);
  box-shadow: var(--zen-shadow-sm);
}

.toolbar-btn:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: none;
}

.toolbar-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.toolbar-btn.active {
  background: var(--zen-primary-alpha);
  border-color: var(--zen-primary);
  color: var(--zen-primary);
}

/* Breadcrumb navigation - Clean and clickable */
.nav-breadcrumb {
  display: flex;
  align-items: center;
  gap: 0;
  padding: var(--zen-space-lg) var(--zen-space-xl);
  background: var(--zen-surface);
  border-bottom: 1px solid var(--zen-border-light);
  font-size: var(--zen-text-sm);
  min-height: 3rem;
  overflow-x: auto;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.nav-breadcrumb::-webkit-scrollbar {
  display: none;
}

.breadcrumb-segment-wrapper {
  display: flex;
  align-items: center;
  flex-shrink: 0;
}

.nav-segment {
  display: inline-flex;
  align-items: center;
  padding: var(--zen-space-sm) var(--zen-space-md);
  border-radius: var(--zen-radius-sm);
  color: var(--zen-text-secondary);
  cursor: pointer;
  transition: all 150ms ease;
  white-space: nowrap;
  font-weight: 500;
  user-select: none;
  max-width: 200px;
  overflow: hidden;
  text-overflow: ellipsis;
}

.nav-segment:hover {
  background: var(--zen-surface-hover);
  color: var(--zen-text-primary);
  transform: translateY(-1px);
}

.nav-segment.current {
  color: var(--zen-primary);
  font-weight: 600;
  background: var(--zen-primary-alpha);
}

.separator {
  color: var(--zen-text-tertiary);
  margin: 0 var(--zen-space-sm);
  font-size: var(--zen-text-xs);
  font-weight: 400;
  flex-shrink: 0;
}

/* File list container - Spacious and clean */
.file-list-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  background: var(--zen-surface);
}

.file-list {
  flex: 1;
  overflow-y: auto;
  padding: var(--zen-space-xl);
  gap: var(--zen-space-xs);
  display: flex;
  flex-direction: column;
}

/* File items - Much more spacious and refined */
.file-item {
  display: flex;
  align-items: center;
  gap: var(--zen-space-lg);
  padding: var(--zen-space-lg);
  border-radius: var(--zen-radius-md);
  cursor: pointer;
  transition: all 150ms ease;
  border: 1px solid transparent;
  min-height: 3.5rem;
  background: transparent;
}

.file-item:hover:not(.selected) {
  background: var(--zen-surface-hover);
  border-color: var(--zen-border);
  transform: translateY(-1px);
  box-shadow: var(--zen-shadow-sm);
}

.file-item.selected {
  background: var(--zen-primary-alpha);
  border-color: var(--zen-primary);
  color: var(--zen-primary);
  transform: translateY(-1px);
  box-shadow: var(--zen-shadow);
}

.file-item.selected:hover {
  background: var(--zen-primary-alpha-hover);
  transform: translateY(-2px);
  box-shadow: var(--zen-shadow-md);
}

.file-item:active {
  transform: scale(0.98);
}

.file-item.cut {
  opacity: 0.6;
  filter: grayscale(30%);
  border-style: dashed;
}

/* File icons - More refined */
.file-icon {
  width: 2rem;
  height: 2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--zen-radius);
  font-size: var(--zen-text-sm);
  flex-shrink: 0;
  font-weight: 600;
}

.file-icon.folder {
  background: var(--zen-primary);
  color: var(--zen-text-inverse);
}

.file-icon.file {
  background: var(--zen-surface-hover);
  color: var(--zen-text-secondary);
  border: 1px solid var(--zen-border);
}

.file-icon.code {
  background: var(--zen-success);
  color: var(--zen-text-inverse);
}

.file-icon.image {
  background: var(--zen-warning);
  color: var(--zen-text-inverse);
}

.file-icon.document {
  background: var(--zen-info);
  color: var(--zen-text-inverse);
}

.file-icon.archive {
  background: var(--zen-text-secondary);
  color: var(--zen-text-inverse);
}

.file-icon.executable {
  background: var(--zen-error);
  color: var(--zen-text-inverse);
}

/* File details - Better typography */
.file-details {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: var(--zen-space-xs);
  min-width: 0;
}

.file-name {
  font-size: var(--zen-text-sm);
  font-weight: 500;
  color: inherit;
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.file-meta {
  font-size: var(--zen-text-xs);
  color: var(--zen-text-tertiary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Status bar - Clean and informative */
.status-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--zen-space-md) var(--zen-space-xl);
  background: var(--zen-surface);
  border-top: 1px solid var(--zen-border-light);
  font-size: var(--zen-text-xs);
  color: var(--zen-text-secondary);
  min-height: 2.5rem;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

/* Error message - Non-intrusive */
.error-message {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--zen-space-lg) var(--zen-space-xl);
  background: rgba(239, 68, 68, 0.1);
  border-left: 4px solid var(--zen-error);
  color: var(--zen-error);
  font-size: var(--zen-text-sm);
  margin: var(--zen-space-lg);
  border-radius: var(--zen-radius);
}

/* Loading states - Gentle and zen */
.loading-overlay {
  display: flex;
  align-items: center;
  justify-content: center;
  flex: 1;
  background: var(--zen-surface);
}

.loading-spinner {
  width: 1.5rem;
  height: 1.5rem;
  border: 2px solid var(--zen-border);
  border-top: 2px solid var(--zen-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Empty state - Zen and calming */
.empty-directory {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  gap: var(--zen-space-lg);
  color: var(--zen-text-tertiary);
  font-size: var(--zen-text-sm);
}

.empty-directory-icon {
  font-size: 3rem;
  opacity: 0.5;
}

/* Context menus - Modern and clean */
.context-menu,
.empty-space-context-menu {
  position: fixed;
  background: var(--zen-surface);
  border: 1px solid var(--zen-border);
  border-radius: var(--zen-radius-md);
  box-shadow: var(--zen-shadow-lg);
  z-index: 1000;
  min-width: 200px;
  padding: var(--zen-space-sm);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
}

.context-menu-item {
  display: flex;
  align-items: center;
  gap: var(--zen-space-md);
  padding: var(--zen-space-md) var(--zen-space-lg);
  border-radius: var(--zen-radius);
  cursor: pointer;
  transition: all 150ms ease;
  font-size: var(--zen-text-sm);
  color: var(--zen-text-secondary);
  min-height: 2.5rem;
}

.context-menu-item:hover {
  background: var(--zen-surface-hover);
  color: var(--zen-text-primary);
}

.context-menu-item:active {
  background: var(--zen-surface-active);
}

.context-menu-icon {
  width: 1rem;
  height: 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.context-menu-separator {
  height: 1px;
  background: var(--zen-border-light);
  margin: var(--zen-space-sm) 0;
}

/* Custom scrollbar - Minimal and zen */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: var(--zen-border);
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: var(--zen-border-focus);
}

/* Text utilities */
.text-technical {
  font-family: inherit;
  font-size: var(--zen-text-xs);
  color: var(--zen-text-tertiary);
  font-weight: 500;
}

/* Drag and drop states */
.file-item.drag-over {
  background: var(--zen-primary-alpha-hover);
  border-color: var(--zen-primary);
  transform: scale(1.02);
  box-shadow: var(--zen-shadow-md);
}

.file-item.dragging {
  opacity: 0.6;
  transform: rotate(-2deg) scale(0.95);
}

.file-explorer.dragging-active {
  cursor: grabbing;
}

/* Folder creation input */
.folder-name-input {
  background: var(--zen-surface);
  border: 2px solid var(--zen-primary);
  border-radius: var(--zen-radius);
  padding: var(--zen-space-md) var(--zen-space-lg);
  font-family: inherit;
  font-size: var(--zen-text-sm);
  color: var(--zen-text-primary);
  min-height: 2.5rem;
  transition: all 150ms ease;
}

.folder-name-input:focus {
  outline: none;
  border-color: var(--zen-primary);
  box-shadow: 0 0 0 3px var(--zen-primary-alpha);
}

/* Responsive design */
@media (max-width: 768px) {
  .main-content {
    flex-direction: column;
  }
  
  .sidebar {
    width: 100%;
    height: auto;
    border-right: none;
    border-bottom: 1px solid var(--zen-border-light);
  }
  
  .toolbar {
    flex-wrap: wrap;
    gap: var(--zen-space-xs);
  }
  
  .app-header {
    padding: var(--zen-space-md) var(--zen-space-lg);
  }
  
  .file-list {
    padding: var(--zen-space-lg);
  }
}

@media (max-width: 480px) {
  .file-item {
    padding: var(--zen-space-md);
    gap: var(--zen-space-md);
    min-height: 3rem;
  }
  
  .file-icon {
    width: 1.5rem;
    height: 1.5rem;
  }
  
  .toolbar-btn {
    padding: var(--zen-space-sm) var(--zen-space-md);
    font-size: var(--zen-text-xs);
  }
}

/* Accessibility improvements */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

@media (prefers-contrast: high) {
  :root {
    --zen-border: #000000;
    --zen-text-secondary: #000000;
    --zen-primary: #0000ff;
  }
}

/* Focus states for accessibility */
.toolbar-btn:focus-visible,
.sidebar-item:focus-visible,
.nav-segment:focus-visible,
.file-item:focus-visible {
  outline: 2px solid var(--zen-primary);
  outline-offset: 2px;
}

/* Print styles */
@media print {
  .toolbar,
  .sidebar,
  .status-bar {
    display: none;
  }
  
  .main-content {
    flex-direction: column;
  }
  
 .file-list {
    background: white;
    color: black;
  }
}


================================================
File: go.mod
================================================
module testui

go 1.23

require github.com/wailsapp/wails/v2 v2.10.1

require (
	github.com/bep/debounce v1.2.1 // indirect
	github.com/go-ole/go-ole v1.3.0 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e // indirect
	github.com/labstack/echo/v4 v4.13.3 // indirect
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/leaanthony/go-ansi-parser v1.6.1 // indirect
	github.com/leaanthony/gosod v1.0.4 // indirect
	github.com/leaanthony/slicer v1.6.0 // indirect
	github.com/leaanthony/u v1.1.1 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/samber/lo v1.49.1 // indirect
	github.com/tkrajina/go-reflector v0.5.8 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	github.com/wailsapp/go-webview2 v1.0.19 // indirect
	github.com/wailsapp/mimetype v1.4.1 // indirect
	golang.org/x/crypto v0.33.0 // indirect
	golang.org/x/net v0.35.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.22.0 // indirect
)

// replace github.com/wailsapp/wails/v2 v2.10.1 => C:\Users\andrewzhuang\go\pkg\mod


================================================
File: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        'wails-dark': 'rgba(27, 38, 54, 1)',
      },
      fontFamily: {
        'jetbrains': ['JetBrains Mono', 'monospace'],
      },
    },
  },
  plugins: [],
}



================================================
File: frontend/wailsjs/runtime/runtime.d.ts
================================================
/*
 _       __      _ __
| |     / /___ _(_) /____
| | /| / / __ `/ / / ___/
| |/ |/ / /_/ / / (__  )
|__/|__/\__,_/_/_/____/
The electron alternative for Go
(c) Lea Anthony 2019-present
*/

export interface Position {
    x: number;
    y: number;
}

export interface Size {
    w: number;
    h: number;
}

export interface Screen {
    isCurrent: boolean;
    isPrimary: boolean;
    width : number
    height : number
}

// Environment information such as platform, buildtype, ...
export interface EnvironmentInfo {
    buildType: string;
    platform: string;
    arch: string;
}

// [EventsEmit](https://wails.io/docs/reference/runtime/events#eventsemit)
// emits the given event. Optional data may be passed with the event.
// This will trigger any event listeners.
export function EventsEmit(eventName: string, ...data: any): void;

// [EventsOn](https://wails.io/docs/reference/runtime/events#eventson) sets up a listener for the given event name.
export function EventsOn(eventName: string, callback: (...data: any) => void): () => void;

// [EventsOnMultiple](https://wails.io/docs/reference/runtime/events#eventsonmultiple)
// sets up a listener for the given event name, but will only trigger a given number times.
export function EventsOnMultiple(eventName: string, callback: (...data: any) => void, maxCallbacks: number): () => void;

// [EventsOnce](https://wails.io/docs/reference/runtime/events#eventsonce)
// sets up a listener for the given event name, but will only trigger once.
export function EventsOnce(eventName: string, callback: (...data: any) => void): () => void;

// [EventsOff](https://wails.io/docs/reference/runtime/events#eventsoff)
// unregisters the listener for the given event name.
export function EventsOff(eventName: string, ...additionalEventNames: string[]): void;

// [EventsOffAll](https://wails.io/docs/reference/runtime/events#eventsoffall)
// unregisters all listeners.
export function EventsOffAll(): void;

// [LogPrint](https://wails.io/docs/reference/runtime/log#logprint)
// logs the given message as a raw message
export function LogPrint(message: string): void;

// [LogTrace](https://wails.io/docs/reference/runtime/log#logtrace)
// logs the given message at the `trace` log level.
export function LogTrace(message: string): void;

// [LogDebug](https://wails.io/docs/reference/runtime/log#logdebug)
// logs the given message at the `debug` log level.
export function LogDebug(message: string): void;

// [LogError](https://wails.io/docs/reference/runtime/log#logerror)
// logs the given message at the `error` log level.
export function LogError(message: string): void;

// [LogFatal](https://wails.io/docs/reference/runtime/log#logfatal)
// logs the given message at the `fatal` log level.
// The application will quit after calling this method.
export function LogFatal(message: string): void;

// [LogInfo](https://wails.io/docs/reference/runtime/log#loginfo)
// logs the given message at the `info` log level.
export function LogInfo(message: string): void;

// [LogWarning](https://wails.io/docs/reference/runtime/log#logwarning)
// logs the given message at the `warning` log level.
export function LogWarning(message: string): void;

// [WindowReload](https://wails.io/docs/reference/runtime/window#windowreload)
// Forces a reload by the main application as well as connected browsers.
export function WindowReload(): void;

// [WindowReloadApp](https://wails.io/docs/reference/runtime/window#windowreloadapp)
// Reloads the application frontend.
export function WindowReloadApp(): void;

// [WindowSetAlwaysOnTop](https://wails.io/docs/reference/runtime/window#windowsetalwaysontop)
// Sets the window AlwaysOnTop or not on top.
export function WindowSetAlwaysOnTop(b: boolean): void;

// [WindowSetSystemDefaultTheme](https://wails.io/docs/next/reference/runtime/window#windowsetsystemdefaulttheme)
// *Windows only*
// Sets window theme to system default (dark/light).
export function WindowSetSystemDefaultTheme(): void;

// [WindowSetLightTheme](https://wails.io/docs/next/reference/runtime/window#windowsetlighttheme)
// *Windows only*
// Sets window to light theme.
export function WindowSetLightTheme(): void;

// [WindowSetDarkTheme](https://wails.io/docs/next/reference/runtime/window#windowsetdarktheme)
// *Windows only*
// Sets window to dark theme.
export function WindowSetDarkTheme(): void;

// [WindowCenter](https://wails.io/docs/reference/runtime/window#windowcenter)
// Centers the window on the monitor the window is currently on.
export function WindowCenter(): void;

// [WindowSetTitle](https://wails.io/docs/reference/runtime/window#windowsettitle)
// Sets the text in the window title bar.
export function WindowSetTitle(title: string): void;

// [WindowFullscreen](https://wails.io/docs/reference/runtime/window#windowfullscreen)
// Makes the window full screen.
export function WindowFullscreen(): void;

// [WindowUnfullscreen](https://wails.io/docs/reference/runtime/window#windowunfullscreen)
// Restores the previous window dimensions and position prior to full screen.
export function WindowUnfullscreen(): void;

// [WindowIsFullscreen](https://wails.io/docs/reference/runtime/window#windowisfullscreen)
// Returns the state of the window, i.e. whether the window is in full screen mode or not.
export function WindowIsFullscreen(): Promise<boolean>;

// [WindowSetSize](https://wails.io/docs/reference/runtime/window#windowsetsize)
// Sets the width and height of the window.
export function WindowSetSize(width: number, height: number): void;

// [WindowGetSize](https://wails.io/docs/reference/runtime/window#windowgetsize)
// Gets the width and height of the window.
export function WindowGetSize(): Promise<Size>;

// [WindowSetMaxSize](https://wails.io/docs/reference/runtime/window#windowsetmaxsize)
// Sets the maximum window size. Will resize the window if the window is currently larger than the given dimensions.
// Setting a size of 0,0 will disable this constraint.
export function WindowSetMaxSize(width: number, height: number): void;

// [WindowSetMinSize](https://wails.io/docs/reference/runtime/window#windowsetminsize)
// Sets the minimum window size. Will resize the window if the window is currently smaller than the given dimensions.
// Setting a size of 0,0 will disable this constraint.
export function WindowSetMinSize(width: number, height: number): void;

// [WindowSetPosition](https://wails.io/docs/reference/runtime/window#windowsetposition)
// Sets the window position relative to the monitor the window is currently on.
export function WindowSetPosition(x: number, y: number): void;

// [WindowGetPosition](https://wails.io/docs/reference/runtime/window#windowgetposition)
// Gets the window position relative to the monitor the window is currently on.
export function WindowGetPosition(): Promise<Position>;

// [WindowHide](https://wails.io/docs/reference/runtime/window#windowhide)
// Hides the window.
export function WindowHide(): void;

// [WindowShow](https://wails.io/docs/reference/runtime/window#windowshow)
// Shows the window, if it is currently hidden.
export function WindowShow(): void;

// [WindowMaximise](https://wails.io/docs/reference/runtime/window#windowmaximise)
// Maximises the window to fill the screen.
export function WindowMaximise(): void;

// [WindowToggleMaximise](https://wails.io/docs/reference/runtime/window#windowtogglemaximise)
// Toggles between Maximised and UnMaximised.
export function WindowToggleMaximise(): void;

// [WindowUnmaximise](https://wails.io/docs/reference/runtime/window#windowunmaximise)
// Restores the window to the dimensions and position prior to maximising.
export function WindowUnmaximise(): void;

// [WindowIsMaximised](https://wails.io/docs/reference/runtime/window#windowismaximised)
// Returns the state of the window, i.e. whether the window is maximised or not.
export function WindowIsMaximised(): Promise<boolean>;

// [WindowMinimise](https://wails.io/docs/reference/runtime/window#windowminimise)
// Minimises the window.
export function WindowMinimise(): void;

// [WindowUnminimise](https://wails.io/docs/reference/runtime/window#windowunminimise)
// Restores the window to the dimensions and position prior to minimising.
export function WindowUnminimise(): void;

// [WindowIsMinimised](https://wails.io/docs/reference/runtime/window#windowisminimised)
// Returns the state of the window, i.e. whether the window is minimised or not.
export function WindowIsMinimised(): Promise<boolean>;

// [WindowIsNormal](https://wails.io/docs/reference/runtime/window#windowisnormal)
// Returns the state of the window, i.e. whether the window is normal or not.
export function WindowIsNormal(): Promise<boolean>;

// [WindowSetBackgroundColour](https://wails.io/docs/reference/runtime/window#windowsetbackgroundcolour)
// Sets the background colour of the window to the given RGBA colour definition. This colour will show through for all transparent pixels.
export function WindowSetBackgroundColour(R: number, G: number, B: number, A: number): void;

// [ScreenGetAll](https://wails.io/docs/reference/runtime/window#screengetall)
// Gets the all screens. Call this anew each time you want to refresh data from the underlying windowing system.
export function ScreenGetAll(): Promise<Screen[]>;

// [BrowserOpenURL](https://wails.io/docs/reference/runtime/browser#browseropenurl)
// Opens the given URL in the system browser.
export function BrowserOpenURL(url: string): void;

// [Environment](https://wails.io/docs/reference/runtime/intro#environment)
// Returns information about the environment
export function Environment(): Promise<EnvironmentInfo>;

// [Quit](https://wails.io/docs/reference/runtime/intro#quit)
// Quits the application.
export function Quit(): void;

// [Hide](https://wails.io/docs/reference/runtime/intro#hide)
// Hides the application.
export function Hide(): void;

// [Show](https://wails.io/docs/reference/runtime/intro#show)
// Shows the application.
export function Show(): void;

// [ClipboardGetText](https://wails.io/docs/reference/runtime/clipboard#clipboardgettext)
// Returns the current text stored on clipboard
export function ClipboardGetText(): Promise<string>;

// [ClipboardSetText](https://wails.io/docs/reference/runtime/clipboard#clipboardsettext)
// Sets a text on the clipboard
export function ClipboardSetText(text: string): Promise<boolean>;

// [OnFileDrop](https://wails.io/docs/reference/runtime/draganddrop#onfiledrop)
// OnFileDrop listens to drag and drop events and calls the callback with the coordinates of the drop and an array of path strings.
export function OnFileDrop(callback: (x: number, y: number ,paths: string[]) => void, useDropTarget: boolean) :void

// [OnFileDropOff](https://wails.io/docs/reference/runtime/draganddrop#dragandddropoff)
// OnFileDropOff removes the drag and drop listeners and handlers.
export function OnFileDropOff() :void

// Check if the file path resolver is available
export function CanResolveFilePaths(): boolean;

// Resolves file paths for an array of files
export function ResolveFilePaths(files: File[]): void

