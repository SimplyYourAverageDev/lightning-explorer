================================================
File: .gitignore
================================================
build/*
node_modules
frontend/dist

================================================
File: .cursor/rules/project-overview.mdc
================================================
---
description: 
globs: 
alwaysApply: true
---
This Project is a Wails V2 Project (App) that uses Preact to build an alternative File Explorer for Windows 11 Systems. The UI Design is Retro and 8-bit styled yet also extremely zen and minimalist!

================================================
File: frontend/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta name="description" content="Wails application with Tailwind CSS v3">
    <title>lightning_explorer</title>
</head>
<body class="m-0 p-0 font-jetbrains antialiased">
<div id="app"></div>
<script src="./src/main.jsx" type="module"></script>
</body>
</html>



================================================
File: frontend/package.json
================================================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "preact": "^10.10.1"
  },
  "devDependencies": {
    "@preact/preset-vite": "^2.3.0",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.4",
    "tailwindcss": "3",
    "vite": "^3.0.7"
  }
}

================================================
File: backend/fileops.go
================================================
package backend

import (
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"syscall"
	"time"
	"unsafe"
)

var (
	shell32 = syscall.NewLazyDLL("shell32.dll")

	// Shell32 procedures for enhanced file operations
	shFileOperationW        = shell32.NewProc("SHFileOperationW")
	shGetSpecialFolderPathW = shell32.NewProc("SHGetSpecialFolderPathW")
)

// Windows constants for file operations
const (
	FO_DELETE = 0x0003
	FO_MOVE   = 0x0001
	FO_COPY   = 0x0002

	FOF_ALLOWUNDO      = 0x0040
	FOF_NOCONFIRMATION = 0x0010
	FOF_SILENT         = 0x0004

	CSIDL_BITBUCKET = 0x000a
)

// SHFILEOPSTRUCT represents the Windows SHFILEOPSTRUCT structure
type SHFILEOPSTRUCT struct {
	Hwnd                  uintptr
	WFunc                 uint32
	PFrom                 uintptr
	PTo                   uintptr
	FFlags                uint16
	FAnyOperationsAborted int32
	HNameMappings         uintptr
	LpszProgressTitle     uintptr
}

// NewFileOperationsManager creates a new file operations manager instance
func NewFileOperationsManager(platform PlatformManagerInterface) *FileOperationsManager {
	return &FileOperationsManager{
		platform: platform,
	}
}

// CopyFiles copies files from source paths to destination directory using optimized methods
func (fo *FileOperationsManager) CopyFiles(sourcePaths []string, destDir string) bool {
	log.Printf("Copying %d files to: %s", len(sourcePaths), destDir)

	// Use native Windows API for better performance on Windows
	if runtime.GOOS == "windows" {
		return fo.copyFilesWindows(sourcePaths, destDir)
	}

	// Fallback to Go standard library for other platforms
	return fo.copyFilesStandard(sourcePaths, destDir)
}

// copyFilesWindows uses Windows API for optimized file copying
func (fo *FileOperationsManager) copyFilesWindows(sourcePaths []string, destDir string) bool {
	// For now, use the standard method but could be enhanced with SHFileOperationW
	// SHFileOperationW is complex for copy operations, so we'll keep the current optimized Go implementation
	return fo.copyFilesStandard(sourcePaths, destDir)
}

// copyFilesStandard uses Go standard library for file copying
func (fo *FileOperationsManager) copyFilesStandard(sourcePaths []string, destDir string) bool {
	for _, srcPath := range sourcePaths {
		srcInfo, err := os.Stat(srcPath)
		if err != nil {
			log.Printf("Error getting source file info: %v", err)
			return false
		}

		destPath := filepath.Join(destDir, filepath.Base(srcPath))

		if srcInfo.IsDir() {
			err = fo.copyDir(srcPath, destPath)
		} else {
			err = fo.copyFile(srcPath, destPath)
		}

		if err != nil {
			log.Printf("Error copying %s: %v", srcPath, err)
			return false
		}

		// Verify the copy was successful
		if _, err := os.Stat(destPath); err != nil {
			log.Printf("Copy verification failed for %s: %v", destPath, err)
			return false
		}
	}

	log.Printf("Successfully copied %d files to %s", len(sourcePaths), destDir)
	return true
}

// MoveFiles moves files from source paths to destination directory
func (fo *FileOperationsManager) MoveFiles(sourcePaths []string, destDir string) bool {
	log.Printf("Moving %d files to: %s", len(sourcePaths), destDir)

	for _, srcPath := range sourcePaths {
		destPath := filepath.Join(destDir, filepath.Base(srcPath))

		err := os.Rename(srcPath, destPath)
		if err != nil {
			// If rename fails, try copy + delete (for cross-drive moves)
			if err := fo.copyAndDelete(srcPath, destPath); err != nil {
				log.Printf("Error moving %s: %v", srcPath, err)
				return false
			}
		}

		// Verify the move was successful
		if _, err := os.Stat(destPath); err != nil {
			log.Printf("Move verification failed for %s: %v", destPath, err)
			return false
		}
	}

	log.Printf("Successfully moved %d files to %s", len(sourcePaths), destDir)
	return true
}

// DeleteFiles permanently deletes the specified files and directories
func (fo *FileOperationsManager) DeleteFiles(filePaths []string) bool {
	log.Printf("Permanently deleting %d files", len(filePaths))

	for _, filePath := range filePaths {
		err := os.RemoveAll(filePath)
		if err != nil {
			log.Printf("Error permanently deleting %s: %v", filePath, err)
			return false
		}
	}

	return true
}

// MoveFilesToRecycleBin moves files to the system recycle bin/trash using native APIs
func (fo *FileOperationsManager) MoveFilesToRecycleBin(filePaths []string) bool {
	log.Printf("Moving %d files to recycle bin", len(filePaths))

	if runtime.GOOS == "windows" {
		return fo.moveToWindowsRecycleBinNative(filePaths)
	}

	// Fallback to individual file processing for other platforms
	for _, filePath := range filePaths {
		success := fo.moveToRecycleBin(filePath)
		if !success {
			log.Printf("Error moving %s to recycle bin", filePath)
			return false
		}
	}

	return true
}

// moveToWindowsRecycleBinNative uses SHFileOperationW for proper recycle bin operations
func (fo *FileOperationsManager) moveToWindowsRecycleBinNative(filePaths []string) bool {
	log.Printf("Moving files to Windows Recycle Bin using native API")

	// Create double-null-terminated string of file paths
	var pathsBuilder strings.Builder
	for _, path := range filePaths {
		pathsBuilder.WriteString(path)
		pathsBuilder.WriteByte(0) // Null terminator for each path
	}
	pathsBuilder.WriteByte(0) // Final null terminator

	// Convert to UTF16
	pathsUTF16, err := syscall.UTF16FromString(pathsBuilder.String())
	if err != nil {
		log.Printf("Failed to convert paths to UTF16: %v", err)
		return false
	}

	// Set up SHFILEOPSTRUCT
	fileOp := SHFILEOPSTRUCT{
		Hwnd:   0, // No parent window
		WFunc:  FO_DELETE,
		PFrom:  uintptr(unsafe.Pointer(&pathsUTF16[0])),
		PTo:    0, // Not needed for delete
		FFlags: FOF_ALLOWUNDO | FOF_NOCONFIRMATION | FOF_SILENT,
	}

	// Call SHFileOperationW
	ret, _, err := shFileOperationW.Call(uintptr(unsafe.Pointer(&fileOp)))
	if ret != 0 {
		log.Printf("SHFileOperationW failed with code %d: %v", ret, err)
		// Fallback to manual recycle bin method
		return fo.moveToWindowsRecycleBinManual(filePaths)
	}

	log.Printf("Successfully moved %d files to recycle bin using native API", len(filePaths))
	return true
}

// moveToWindowsRecycleBinManual provides fallback manual recycle bin implementation
func (fo *FileOperationsManager) moveToWindowsRecycleBinManual(filePaths []string) bool {
	log.Printf("Using manual recycle bin method as fallback")

	for _, filePath := range filePaths {
		success := fo.moveToWindowsRecycleBin(filePath)
		if !success {
			log.Printf("Error moving %s to recycle bin", filePath)
			return false
		}
	}

	return true
}

// RenameFile renames a file or directory
func (fo *FileOperationsManager) RenameFile(oldPath, newName string) bool {
	log.Printf("Renaming %s to %s", oldPath, newName)

	// Validate inputs
	if oldPath == "" || newName == "" {
		log.Printf("Error: Empty path or new name provided")
		return false
	}

	// Get the directory containing the file
	dir := filepath.Dir(oldPath)
	newPath := filepath.Join(dir, newName)

	// Check if old path exists
	if _, err := os.Stat(oldPath); os.IsNotExist(err) {
		log.Printf("Error: Source file does not exist: %s", oldPath)
		return false
	}

	// Check if new path already exists
	if _, err := os.Stat(newPath); err == nil {
		log.Printf("Error: Destination already exists: %s", newPath)
		return false
	}

	// Perform the rename
	err := os.Rename(oldPath, newPath)
	if err != nil {
		log.Printf("Error renaming file: %v", err)
		return false
	}

	log.Printf("Successfully renamed %s to %s", oldPath, newPath)
	return true
}

// HideFiles sets the hidden attribute on the specified files
func (fo *FileOperationsManager) HideFiles(filePaths []string) bool {
	log.Printf("Hiding %d files", len(filePaths))

	for _, filePath := range filePaths {
		success := fo.platform.HideFile(filePath)
		if !success {
			log.Printf("Error hiding file: %s", filePath)
			return false
		}
	}

	log.Printf("Successfully hid %d files", len(filePaths))
	return true
}

// OpenFile opens a file with its default application
func (fo *FileOperationsManager) OpenFile(filePath string) bool {
	return fo.platform.OpenFile(filePath)
}

// Helper methods

// copyFile copies a single file with optimized buffer size for better performance
func (fo *FileOperationsManager) copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	// Use optimized buffer size for better performance (64KB)
	buffer := make([]byte, 64*1024)
	_, err = io.CopyBuffer(destFile, sourceFile, buffer)
	if err != nil {
		return err
	}

	// Copy file permissions and timestamps
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	os.Chmod(dst, srcInfo.Mode())
	os.Chtimes(dst, srcInfo.ModTime(), srcInfo.ModTime())

	return nil
}

// copyDir recursively copies a directory with progress tracking
func (fo *FileOperationsManager) copyDir(src, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	err = os.MkdirAll(dst, srcInfo.Mode())
	if err != nil {
		return err
	}

	entries, err := os.ReadDir(src)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		dstPath := filepath.Join(dst, entry.Name())

		if entry.IsDir() {
			err = fo.copyDir(srcPath, dstPath)
		} else {
			err = fo.copyFile(srcPath, dstPath)
		}

		if err != nil {
			return err
		}
	}

	return nil
}

// copyAndDelete copies a file/directory then deletes the original (for cross-drive moves)
func (fo *FileOperationsManager) copyAndDelete(src, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	if srcInfo.IsDir() {
		return fo.copyDirAndDelete(src, dst)
	}

	return fo.copyFileAndDelete(src, dst)
}

// copyFileAndDelete copies a file and then deletes the original
func (fo *FileOperationsManager) copyFileAndDelete(src, dst string) error {
	err := fo.copyFile(src, dst)
	if err != nil {
		return err
	}

	return os.Remove(src)
}

// copyDirAndDelete recursively copies a directory and then deletes the original
func (fo *FileOperationsManager) copyDirAndDelete(src, dst string) error {
	err := fo.copyDir(src, dst)
	if err != nil {
		return err
	}

	return os.RemoveAll(src)
}

// moveToRecycleBin moves a single file to the recycle bin using OS-specific methods
func (fo *FileOperationsManager) moveToRecycleBin(filePath string) bool {
	switch runtime.GOOS {
	case "windows":
		return fo.moveToWindowsRecycleBin(filePath)
	case "darwin":
		return fo.moveToMacTrash(filePath)
	case "linux":
		return fo.moveToLinuxTrash(filePath)
	default:
		log.Printf("Recycle bin not supported on %s, falling back to permanent delete", runtime.GOOS)
		return os.RemoveAll(filePath) == nil
	}
}

// moveToWindowsRecycleBin moves file to Windows Recycle Bin using optimized method with native SID retrieval
func (fo *FileOperationsManager) moveToWindowsRecycleBin(filePath string) bool {
	log.Printf("Moving to Windows Recycle Bin: %s", filePath)

	// Get current user SID using native Windows API
	userSID, err := fo.getCurrentUserSIDNative()
	if err != nil {
		log.Printf("Failed to get user SID using native API: %v", err)
		return false
	}

	// Get the drive letter from the file path
	if len(filePath) < 2 || filePath[1] != ':' {
		log.Printf("Invalid file path format: %s", filePath)
		return false
	}

	driveLetter := strings.ToUpper(string(filePath[0]))
	recycleBinPath := fmt.Sprintf("%s:\\$Recycle.Bin\\%s", driveLetter, userSID)

	// Create recycle bin directory if it doesn't exist
	err = os.MkdirAll(recycleBinPath, 0755)
	if err != nil {
		log.Printf("Failed to create recycle bin directory: %v", err)
		return false
	}

	// Generate unique filename in recycle bin
	originalName := filepath.Base(filePath)
	recycleBinFile := filepath.Join(recycleBinPath, originalName)

	// Handle filename conflicts
	if fo.fileExists(recycleBinFile) {
		recycleBinFile = fo.generateUniqueRecycleBinPath(recycleBinPath, originalName)
	}

	// Move file to recycle bin
	err = os.Rename(filePath, recycleBinFile)
	if err != nil {
		// If rename fails, try copy + delete (for cross-drive moves)
		err = fo.copyAndDelete(filePath, recycleBinFile)
		if err != nil {
			log.Printf("Failed to move file to recycle bin: %v", err)
			return false
		}
	}

	log.Printf("Successfully moved to recycle bin: %s -> %s", filePath, recycleBinFile)
	return true
}

// getCurrentUserSIDNative gets the current user's SID using native Windows APIs
func (fo *FileOperationsManager) getCurrentUserSIDNative() (string, error) {
	if runtime.GOOS != "windows" {
		return "", fmt.Errorf("native SID retrieval only available on Windows")
	}

	// Cast platform to access Windows-specific methods
	if platformManager, ok := fo.platform.(*PlatformManager); ok {
		return platformManager.GetCurrentUserSIDNative()
	}

	return "", fmt.Errorf("platform manager does not support native SID retrieval")
}

// fileExists checks if a file exists
func (fo *FileOperationsManager) fileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

// generateUniqueRecycleBinPath creates a unique filename for the recycle bin
func (fo *FileOperationsManager) generateUniqueRecycleBinPath(recycleBinDir, originalName string) string {
	ext := filepath.Ext(originalName)
	nameWithoutExt := strings.TrimSuffix(originalName, ext)

	for counter := 1; counter < 1000; counter++ {
		newName := fmt.Sprintf("%s (%d)%s", nameWithoutExt, counter, ext)
		newPath := filepath.Join(recycleBinDir, newName)

		if !fo.fileExists(newPath) {
			return newPath
		}
	}

	// Fallback with timestamp if we hit 1000 conflicts
	timestamp := fmt.Sprintf("%d", time.Now().Unix())
	newName := fmt.Sprintf("%s_%s%s", nameWithoutExt, timestamp, ext)
	return filepath.Join(recycleBinDir, newName)
}

// moveToMacTrash moves file to macOS Trash
func (fo *FileOperationsManager) moveToMacTrash(filePath string) bool {
	cmd := exec.Command("osascript", "-e", fmt.Sprintf(`tell app "Finder" to delete POSIX file "%s"`, filePath))
	err := cmd.Run()
	return err == nil
}

// moveToLinuxTrash moves file to Linux trash (freedesktop.org standard)
func (fo *FileOperationsManager) moveToLinuxTrash(filePath string) bool {
	// Try using gio trash (modern method)
	cmd := exec.Command("gio", "trash", filePath)
	err := cmd.Run()

	if err != nil {
		// Fallback to gvfs-trash
		cmd = exec.Command("gvfs-trash", filePath)
		err = cmd.Run()

		if err != nil {
			// Final fallback: move to ~/.local/share/Trash
			homeDir, _ := os.UserHomeDir()
			trashDir := filepath.Join(homeDir, ".local", "share", "Trash", "files")

			// Create trash directory if it doesn't exist
			os.MkdirAll(trashDir, 0755)

			// Move file to trash
			fileName := filepath.Base(filePath)
			trashPath := filepath.Join(trashDir, fileName)

			return os.Rename(filePath, trashPath) == nil
		}
	}

	return true
}


================================================
File: frontend/package.json.md5
================================================
c3da20351cdc630bf29b545cce8f1b8d

================================================
File: frontend/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


================================================
File: frontend/src/components/Breadcrumb.jsx
================================================
import { memo, useMemo, useCallback } from "preact/compat";

// Memoized Breadcrumb component
const Breadcrumb = memo(({ 
    currentPath, 
    onNavigate
}) => {
    const segments = useMemo(() => {
        if (!currentPath) return [];
        
        // Windows paths like "C:\Users\username"
        const parts = currentPath.split(/[\\]/);
        return parts.filter(Boolean);
    }, [currentPath]);
    
    const handleSegmentClick = useCallback((index) => {
        // Build Windows path from segments
        const pathSegments = segments.slice(0, index + 1);
        let newPath = pathSegments.join('\\');
        
        // Add trailing backslash for drive roots
        if (index === 0 && pathSegments[0].includes(':')) {
            newPath += '\\';
        }
        
        onNavigate(newPath);
    }, [segments, onNavigate]);
    
    if (!segments.length) return null;
    
    return (
        <div className="nav-breadcrumb custom-scrollbar" onSelectStart={(e) => e.preventDefault()}>
            {segments.map((segment, index) => (
                <div key={index} className="breadcrumb-segment-wrapper">
                    {index > 0 && <span className="separator">{'/'}</span>}
                    <span 
                        className={`nav-segment ${index === segments.length - 1 ? 'current' : ''}`}
                        onClick={() => handleSegmentClick(index)}
                        title={segment}
                    >
                        {segment}
                    </span>
                </div>
            ))}
        </div>
    );
});

export { Breadcrumb };
export default Breadcrumb; 

================================================
File: backend/platform.go
================================================
package backend

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"syscall"
)

// NewPlatformManager creates a new platform manager instance
func NewPlatformManager() *PlatformManager {
	return &PlatformManager{}
}

// GetHomeDirectory returns the user's home directory
func (p *PlatformManager) GetHomeDirectory() string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		log.Printf("Error getting home directory: %v", err)
		return ""
	}
	return homeDir
}

// GetCurrentWorkingDirectory returns the current working directory
func (p *PlatformManager) GetCurrentWorkingDirectory() string {
	cwd, err := os.Getwd()
	if err != nil {
		log.Printf("Error getting current working directory: %v", err)
		return ""
	}
	return cwd
}

// GetSystemRoots returns system root paths (drives on Windows, / on Unix)
func (p *PlatformManager) GetSystemRoots() []string {
	var roots []string

	switch runtime.GOOS {
	case "windows":
		// Use the optimized Windows-specific method
		return p.GetSystemRootsWindows()
	default:
		// Unix-like systems start from root
		roots = append(roots, "/")
	}
	return roots
}

// OpenInSystemExplorer opens the given path in the system's default file manager
func (p *PlatformManager) OpenInSystemExplorer(path string) bool {
	var cmd string
	var args []string

	switch runtime.GOOS {
	case "windows":
		cmd = "explorer"
		args = []string{path}
	case "darwin":
		cmd = "open"
		args = []string{path}
	case "linux":
		cmd = "xdg-open"
		args = []string{path}
	default:
		log.Printf("OpenInSystemExplorer not supported on %s", runtime.GOOS)
		return false
	}

	err := exec.Command(cmd, args...).Start()
	if err != nil {
		log.Printf("Error opening in system explorer: %v", err)
		return false
	}
	return true
}

// OpenFile opens a file with its default application
func (p *PlatformManager) OpenFile(filePath string) bool {
	log.Printf("Opening file with default application: %s", filePath)

	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "windows":
		// Use rundll32 with shell32.dll to open file without showing command prompt
		cmd = exec.Command("rundll32.exe", "shell32.dll,ShellExec_RunDLL", filePath)
		cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}
	case "darwin":
		cmd = exec.Command("open", filePath)
	case "linux":
		cmd = exec.Command("xdg-open", filePath)
	default:
		log.Printf("Unsupported operating system: %s", runtime.GOOS)
		return false
	}

	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening file: %v", err)
		return false
	}

	log.Printf("Successfully opened file: %s", filePath)
	return true
}

// IsHiddenWindows checks if a file has the Windows hidden attribute
func (p *PlatformManager) IsHiddenWindows(filePath string) bool {
	if runtime.GOOS != "windows" {
		return false
	}

	// Use native Windows API instead of attrib command
	return p.IsHiddenWindowsNative(filePath)
}

// IsHiddenMac checks if a file is hidden on macOS
func (p *PlatformManager) IsHiddenMac(filePath string) bool {
	if runtime.GOOS != "darwin" {
		return false
	}

	fileName := filepath.Base(filePath)
	// Files starting with dot are hidden on macOS
	return strings.HasPrefix(fileName, ".")
}

// IsHiddenLinux checks if a file is hidden on Linux
func (p *PlatformManager) IsHiddenLinux(filePath string) bool {
	if runtime.GOOS != "linux" {
		return false
	}

	fileName := filepath.Base(filePath)
	// Files starting with dot are hidden on Linux
	return strings.HasPrefix(fileName, ".")
}

// IsHidden checks if a file/directory is hidden using OS-specific methods
func (p *PlatformManager) IsHidden(filePath string) bool {
	// Check for dot prefix (universal Unix convention)
	fileName := filepath.Base(filePath)
	if strings.HasPrefix(fileName, ".") {
		return true
	}

	// Check OS-specific hidden attributes
	switch runtime.GOOS {
	case "windows":
		return p.IsHiddenWindows(filePath)
	case "darwin":
		return p.IsHiddenMac(filePath)
	case "linux":
		return p.IsHiddenLinux(filePath)
	default:
		return false
	}
}

// HideFileWindows sets the hidden attribute on Windows using native API
func (p *PlatformManager) HideFileWindows(filePath string) bool {
	if runtime.GOOS != "windows" {
		return false
	}

	// Use native Windows API instead of attrib command
	return p.HideFileWindowsNative(filePath)
}

// HideFileMac hides file on macOS by adding a dot prefix (if not already hidden)
func (p *PlatformManager) HideFileMac(filePath string) bool {
	if runtime.GOOS != "darwin" {
		return false
	}

	log.Printf("Hiding file on macOS: %s", filePath)

	fileName := filepath.Base(filePath)
	if strings.HasPrefix(fileName, ".") {
		log.Printf("File is already hidden: %s", filePath)
		return true
	}

	dir := filepath.Dir(filePath)
	newPath := filepath.Join(dir, "."+fileName)

	err := os.Rename(filePath, newPath)
	if err != nil {
		log.Printf("Failed to hide file on macOS: %v", err)
		return false
	}

	log.Printf("Successfully hid file on macOS: %s -> %s", filePath, newPath)
	return true
}

// HideFileLinux hides file on Linux by adding a dot prefix (if not already hidden)
func (p *PlatformManager) HideFileLinux(filePath string) bool {
	if runtime.GOOS != "linux" {
		return false
	}

	log.Printf("Hiding file on Linux: %s", filePath)

	fileName := filepath.Base(filePath)
	if strings.HasPrefix(fileName, ".") {
		log.Printf("File is already hidden: %s", filePath)
		return true
	}

	dir := filepath.Dir(filePath)
	newPath := filepath.Join(dir, "."+fileName)

	err := os.Rename(filePath, newPath)
	if err != nil {
		log.Printf("Failed to hide file on Linux: %v", err)
		return false
	}

	log.Printf("Successfully hid file on Linux: %s -> %s", filePath, newPath)
	return true
}

// HideFile sets the hidden attribute on a file using OS-specific methods
func (p *PlatformManager) HideFile(filePath string) bool {
	switch runtime.GOOS {
	case "windows":
		return p.HideFileWindows(filePath)
	case "darwin":
		return p.HideFileMac(filePath)
	case "linux":
		return p.HideFileLinux(filePath)
	default:
		log.Printf("Hide file not supported on %s", runtime.GOOS)
		return false
	}
}

// GetExtension returns the file extension in lowercase
func (p *PlatformManager) GetExtension(name string) string {
	ext := filepath.Ext(name)
	if ext != "" {
		return strings.ToLower(ext[1:]) // Remove the dot and convert to lowercase
	}
	return ""
}

// FormatFileSize formats file size in human readable format
func (p *PlatformManager) FormatFileSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}

	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}

	units := []string{"KB", "MB", "GB", "TB", "PB"}
	return fmt.Sprintf("%.1f %s", float64(size)/float64(div), units[exp])
}


================================================
File: backend/platform_windows.go
================================================
//go:build windows

package backend

import (
	"log"
	"os"
	"syscall"
	"unsafe"
)

var (
	kernel32 = syscall.NewLazyDLL("kernel32.dll")
	advapi32 = syscall.NewLazyDLL("advapi32.dll")

	// Kernel32 procedures
	getLogicalDriveStringsW = kernel32.NewProc("GetLogicalDriveStringsW")
	getLogicalDrives        = kernel32.NewProc("GetLogicalDrives")
	getVolumeInformationW   = kernel32.NewProc("GetVolumeInformationW")
	getFileAttributesW      = kernel32.NewProc("GetFileAttributesW")
	setFileAttributesW      = kernel32.NewProc("SetFileAttributesW")
	getCurrentProcess       = kernel32.NewProc("GetCurrentProcess")

	// Advapi32 procedures
	openProcessToken       = advapi32.NewProc("OpenProcessToken")
	getTokenInformation    = advapi32.NewProc("GetTokenInformation")
	lookupAccountSidW      = advapi32.NewProc("LookupAccountSidW")
	convertSidToStringSidW = advapi32.NewProc("ConvertSidToStringSidW")
	localFree              = kernel32.NewProc("LocalFree")
)

// Windows constants
const (
	FILE_ATTRIBUTE_HIDDEN    = 0x2
	FILE_ATTRIBUTE_DIRECTORY = 0x10
	FILE_ATTRIBUTE_SYSTEM    = 0x4

	TOKEN_QUERY = 0x0008
	TokenUser   = 1

	INVALID_FILE_ATTRIBUTES = 0xFFFFFFFF
)

// GetSystemRootsWindows uses GetLogicalDriveStringsW for faster drive enumeration.
func (p *PlatformManager) GetSystemRootsWindows() []string {
	buffer := make([]uint16, 256) // Max 26 drives * 4 chars (C:\) + nulls + final null
	buflen := uint32(len(buffer))

	ret, _, err := getLogicalDriveStringsW.Call(uintptr(buflen), uintptr(unsafe.Pointer(&buffer[0])))
	if ret == 0 {
		log.Printf("Failed to get logical drive strings: %v", err)
		// Fallback to slower method if API call fails
		return p.getSystemRootsFallback()
	}

	var roots []string
	current := 0
	for i, val := range buffer {
		if val == 0 && i > current { // Null terminator for a path
			if i > current {
				roots = append(roots, syscall.UTF16ToString(buffer[current:i]))
			}
			current = i + 1
			if current >= len(buffer) || buffer[current] == 0 { // Double null terminator indicates end of list
				break
			}
		}
	}
	return roots
}

// getSystemRootsFallback provides fallback drive enumeration for Windows
func (p *PlatformManager) getSystemRootsFallback() []string {
	var roots []string
	// Fallback to original method if Windows API fails
	ret, _, err := getLogicalDrives.Call()
	if err != nil && ret == 0 {
		// If this also fails, fall back to the original os.Stat method
		for i := 'A'; i <= 'Z'; i++ {
			drive := string(i) + ":\\"
			if _, e := os.Stat(drive); e == nil {
				roots = append(roots, drive)
			}
		}
		return roots
	}

	logicalDrives := uint32(ret)
	for i := 'A'; i <= 'Z'; i++ {
		driveIndex := i - 'A'
		if logicalDrives&(1<<driveIndex) != 0 {
			drive := string(i) + ":\\"
			roots = append(roots, drive)
		}
	}
	return roots
}

// GetWindowsDrivesOptimized uses Windows API for faster drive enumeration with detailed info
func (p *PlatformManager) GetWindowsDrivesOptimized() []DriveInfo {
	var drives []DriveInfo

	// Get all logical drives first
	driveStrings := p.GetSystemRootsWindows()

	for _, driveString := range driveStrings {
		driveInfo := DriveInfo{
			Path:   driveString,
			Letter: string(driveString[0]),
			Name:   "",
		}

		// Try to get volume information using GetVolumeInformationW
		if volumeLabel := p.getVolumeLabel(driveString); volumeLabel != "" {
			driveInfo.Name = volumeLabel + " (" + driveString[:2] + ")"
		} else {
			driveInfo.Name = "Drive " + driveString[:2]
		}

		drives = append(drives, driveInfo)
	}

	return drives
}

// getVolumeLabel gets the volume label for a drive using GetVolumeInformationW
func (p *PlatformManager) getVolumeLabel(drivePath string) string {
	// Convert drive path to UTF16 pointer
	drivePathPtr, err := syscall.UTF16PtrFromString(drivePath)
	if err != nil {
		return ""
	}

	// Buffer for volume name
	volumeNameBuffer := make([]uint16, 261) // MAX_PATH + 1
	volumeNameSize := uint32(len(volumeNameBuffer))

	// Call GetVolumeInformationW
	ret, _, err := getVolumeInformationW.Call(
		uintptr(unsafe.Pointer(drivePathPtr)),
		uintptr(unsafe.Pointer(&volumeNameBuffer[0])),
		uintptr(volumeNameSize),
		0, // Volume serial number (not needed)
		0, // Maximum component length (not needed)
		0, // File system flags (not needed)
		0, // File system name buffer (not needed)
		0, // File system name size (not needed)
	)

	if ret == 0 {
		// API call failed, return empty string
		return ""
	}

	// Convert UTF16 buffer to string
	return syscall.UTF16ToString(volumeNameBuffer)
}

// IsHiddenWindowsNative checks if a file has the Windows hidden attribute using native API
func (p *PlatformManager) IsHiddenWindowsNative(filePath string) bool {
	filePathPtr, err := syscall.UTF16PtrFromString(filePath)
	if err != nil {
		return false
	}

	ret, _, _ := getFileAttributesW.Call(uintptr(unsafe.Pointer(filePathPtr)))
	if ret == INVALID_FILE_ATTRIBUTES {
		return false
	}

	attributes := uint32(ret)
	return (attributes&FILE_ATTRIBUTE_HIDDEN != 0) || (attributes&FILE_ATTRIBUTE_SYSTEM != 0)
}

// HideFileWindowsNative sets the hidden attribute on Windows using native API
func (p *PlatformManager) HideFileWindowsNative(filePath string) bool {
	log.Printf("Setting hidden attribute on Windows using native API: %s", filePath)

	filePathPtr, err := syscall.UTF16PtrFromString(filePath)
	if err != nil {
		log.Printf("Failed to convert file path to UTF16: %v", err)
		return false
	}

	// Get current attributes first
	ret, _, _ := getFileAttributesW.Call(uintptr(unsafe.Pointer(filePathPtr)))
	if ret == INVALID_FILE_ATTRIBUTES {
		log.Printf("Failed to get current file attributes")
		return false
	}

	currentAttributes := uint32(ret)
	newAttributes := currentAttributes | FILE_ATTRIBUTE_HIDDEN

	// Set the new attributes with hidden flag
	ret, _, err = setFileAttributesW.Call(
		uintptr(unsafe.Pointer(filePathPtr)),
		uintptr(newAttributes),
	)

	if ret == 0 {
		log.Printf("Failed to set hidden attribute: %v", err)
		return false
	}

	log.Printf("Successfully set hidden attribute using native API: %s", filePath)
	return true
}

// GetCurrentUserSIDNative gets the current user's SID using native Windows APIs
func (p *PlatformManager) GetCurrentUserSIDNative() (string, error) {
	// Get current process handle
	processHandle, _, err := getCurrentProcess.Call()
	if processHandle == 0 {
		return "", err
	}

	// Open process token
	var tokenHandle syscall.Handle
	ret, _, err := openProcessToken.Call(
		processHandle,
		TOKEN_QUERY,
		uintptr(unsafe.Pointer(&tokenHandle)),
	)
	if ret == 0 {
		return "", err
	}
	defer syscall.CloseHandle(tokenHandle)

	// Get token information size
	var tokenUserSize uint32
	getTokenInformation.Call(
		uintptr(tokenHandle),
		TokenUser,
		0,
		0,
		uintptr(unsafe.Pointer(&tokenUserSize)),
	)

	// Allocate buffer for token user info
	tokenUserBuffer := make([]byte, tokenUserSize)
	ret, _, err = getTokenInformation.Call(
		uintptr(tokenHandle),
		TokenUser,
		uintptr(unsafe.Pointer(&tokenUserBuffer[0])),
		uintptr(tokenUserSize),
		uintptr(unsafe.Pointer(&tokenUserSize)),
	)
	if ret == 0 {
		return "", err
	}

	// Extract SID from token user structure
	// TOKEN_USER structure: first 8 bytes is SID pointer (on 64-bit) or 4 bytes (on 32-bit)
	var sidPtr uintptr
	if unsafe.Sizeof(uintptr(0)) == 8 { // 64-bit
		sidPtr = *(*uintptr)(unsafe.Pointer(&tokenUserBuffer[0]))
	} else { // 32-bit
		sidPtr = uintptr(*(*uint32)(unsafe.Pointer(&tokenUserBuffer[0])))
	}

	// Convert SID to string
	var sidStringPtr uintptr
	ret, _, err = convertSidToStringSidW.Call(
		sidPtr,
		uintptr(unsafe.Pointer(&sidStringPtr)),
	)
	if ret == 0 {
		return "", err
	}
	defer localFree.Call(sidStringPtr)

	// Convert to Go string
	sidString := (*uint16)(unsafe.Pointer(sidStringPtr))
	return syscall.UTF16ToString((*[256]uint16)(unsafe.Pointer(sidString))[:]), nil
}


================================================
File: frontend/src/app.jsx
================================================
import './components/FastNavigation.css';
import { useState, useEffect, useCallback, useMemo } from "preact/hooks";
import { 
    GetHomeDirectory, 
    GetDriveInfo,
    OpenInSystemExplorer
} from "../wailsjs/go/backend/App";

// Import optimized utilities
import { log, warn, error } from "./utils/logger";
import { 
    HEADER_STATS_STYLE,
    PERFORMANCE_INDICATOR_STYLE,
    CURRENT_PATH_INDICATOR_STYLE,
    ERROR_DISMISS_BUTTON_STYLE,
    STATUS_BAR_RIGHT_STYLE,
    LOADING_OVERLAY_STYLE,
    LARGE_ICON_STYLE,
    LOADING_SPINNER_LARGE_STYLE,
    EMPTY_DIRECTORY_STYLE
} from "./utils/styleConstants";

// Import our custom components
import {
    Breadcrumb,
    Sidebar,
    FileItem,
    ContextMenu,
    EmptySpaceContextMenu,
    RetroDialog,
    VirtualizedFileList,
    InlineFolderEditor
} from "./components";

// Import our custom hooks
import {
    useFileOperations,
    useSelection,
    useClipboard,
    useNavigation,
    useDialogs,
    useContextMenus,
    usePerformanceMonitoring,
    useKeyboardShortcuts,
    useDragAndDrop,
    useFolderCreation
} from "./hooks";

// Import our utilities
import { filterFiles } from "./utils/fileUtils";



// Main App component
export function App() {
    // Basic UI state
    const [error, setError] = useState('');
    const [drives, setDrives] = useState([]);
    const [showHiddenFiles, setShowHiddenFiles] = useState(false);

    // Custom hooks
    const { navigationStats, setNavigationStats } = usePerformanceMonitoring();
    

    
    const {
        currentPath,
        directoryContents,
        showLoadingIndicator,
        navigateToPath,
        handleNavigateUp,
        handleRefresh
    } = useNavigation(setError, setNavigationStats);

    const { dialog, showDialog, closeDialog } = useDialogs();

    const {
        selectedFiles,
        handleFileSelect,
        clearSelection,
        selectAll,
        handleArrowNavigation
    } = useSelection();

    const {
        clipboardFiles,
        clipboardOperation,
        handleCopy,
        handleCut,
        clearClipboard,
        isPasteAvailable
    } = useClipboard();

    // Initialize file operations hook
    const fileOperations = useFileOperations(
        currentPath, 
        setError, 
        clearSelection, 
        () => navigateToPath(currentPath), 
        showDialog
    );

    // Folder creation hook
    const {
        creatingFolder,
        tempFolderName,
        editInputRef,
        startFolderCreation,
        cancelFolderCreation,
        confirmFolderCreation,
        handleKeyDown,
        handleInputChange,
        handleInputBlur
    } = useFolderCreation(currentPath, handleRefresh, setError);

    // Computed values
    const filteredDirectories = useMemo(() => 
        directoryContents ? filterFiles(directoryContents.directories, showHiddenFiles) : [], 
        [directoryContents, showHiddenFiles]
    );
    
    const filteredFiles = useMemo(() => 
        directoryContents ? filterFiles(directoryContents.files, showHiddenFiles) : [], 
        [directoryContents, showHiddenFiles]
    );
    
    const allFiles = useMemo(() => 
        [...filteredDirectories, ...filteredFiles], 
        [filteredDirectories, filteredFiles]
    );

    // Context menus hook
    const {
        contextMenu,
        emptySpaceContextMenu,
        handleContextMenu,
        closeContextMenu,
        handleEmptySpaceContextMenu,
        closeEmptySpaceContextMenu,
        handleContextCopy,
        handleContextCut,
        handleContextRename,
        handleContextHide,
        handlePermanentDelete,
        handleOpenPowerShell,
        handleCreateFolder
    } = useContextMenus(
        selectedFiles, 
        allFiles, 
        handleCopy, 
        handleCut, 
        showDialog, 
        fileOperations, 
        currentPath, 
        startFolderCreation
    );

    // Drag and drop hook
    const {
        dragState,
        handleDragStart,
        handleDragOver,
        handleDragEnter,
        handleDragLeave,
        handleDrop,
        handleDragEnd
    } = useDragAndDrop(
        currentPath,
        selectedFiles,
        allFiles,
        setError,
        clearSelection,
        handleRefresh
    );

    // File operation handlers
    const handleFileOpen = useCallback((file) => {
        const result = fileOperations.handleFileOpen(file);
        if (result && result.type === 'navigate') {
            // Use direct navigation for file opens (immediate response)
            navigateToPath(result.path, 'file-open');
        }
    }, [fileOperations, navigateToPath]);

    const handleOpenInExplorer = useCallback(() => {
        if (currentPath) {
            OpenInSystemExplorer(currentPath);
        }
    }, [currentPath]);

    // Clipboard operations
    const handleCopySelected = useCallback(() => {
        const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
        const filePaths = selectedFileObjects.map(file => file.path);
        handleCopy(filePaths);
    }, [selectedFiles, allFiles, handleCopy]);

    const handleCutSelected = useCallback(() => {
        const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
        const filePaths = selectedFileObjects.map(file => file.path);
        handleCut(filePaths);
    }, [selectedFiles, allFiles, handleCut]);

    const handlePaste = useCallback(async () => {
        if (!isPasteAvailable() || !currentPath) return;
        
        try {
            log(`📥 Pasting ${clipboardFiles.length} items to:`, currentPath);
            
            let success = false;
            if (clipboardOperation === 'copy') {
                success = await fileOperations.handleCopyFiles(clipboardFiles);
            } else if (clipboardOperation === 'cut') {
                success = await fileOperations.handleMoveFiles(clipboardFiles);
                if (success) {
                    clearClipboard();
                }
            }
            
            if (!success) {
                setError('Paste operation failed');
            } else {
                // Refresh the directory to show the pasted files immediately
                handleRefresh();
            }
        } catch (err) {
            error('❌ Error during paste operation:', err);
            setError('Failed to paste files: ' + err.message);
        }
    }, [isPasteAvailable, currentPath, clipboardFiles, clipboardOperation, fileOperations, clearClipboard]);

    // Keyboard shortcuts
    useKeyboardShortcuts({
        handleRefresh,
        handleNavigateUp,
        selectedFiles,
        allFiles,
        handleFileOpen,
        selectAll,
        handleCopySelected,
        handleCutSelected,
        handlePaste,
        isPasteAvailable,
        handleArrowNavigation,
        clearSelection,
        closeContextMenu,
        closeEmptySpaceContextMenu
    });

    // Initialize app
    useEffect(() => {
        log('🚀 Zen File Explorer initializing...');
        initializeApp();
    }, []);

    const initializeApp = async () => {
        try {
            setError('');
            
            const homeDir = await GetHomeDirectory();
            if (homeDir) {
                await navigateToPath(homeDir, 'init');
            } else {
                setError('Unable to determine starting directory');
            }
        } catch (err) {
            error('❌ Error initializing app:', err);
            setError('Failed to initialize file explorer: ' + err.message);
        }
    };

    // Load drives
    useEffect(() => {
        GetDriveInfo().then(driveList => {
            setDrives(driveList);
        });
    }, []);

    // Clear selection when path changes
    useEffect(() => {
        clearSelection();
        closeContextMenu();
    }, [currentPath, clearSelection, closeContextMenu]);

    return (
        <div 
            className={`file-explorer ${dragState.isDragging ? 'dragging-active' : ''}`}
            onSelectStart={(e) => e.preventDefault()}
            onDragEnd={handleDragEnd}
            onContextMenu={(e) => {
                // Global fallback to prevent browser context menu
                if (!e.target.closest('.file-item') && !e.target.closest('.context-menu')) {
                    e.preventDefault();
                }
            }}
        >
            {/* Header */}
            <header className="app-header">
                <div className="app-title">Files</div>
                <div style={HEADER_STATS_STYLE}>
                    {showLoadingIndicator && <div className="loading-spinner"></div>}
                    <span className="text-technical">
                        {directoryContents ? 
                            `${filteredDirectories.length} dirs • ${filteredFiles.length} files${!showHiddenFiles ? ' (hidden filtered)' : ''}${selectedFiles.size > 0 ? ` • ${selectedFiles.size} selected` : ''}` : 
                            'Ready'
                        }
                    </span>
                    {/* Performance indicator - Complete UI render timing */}
                    {navigationStats.totalNavigations > 0 && (
                        <span className="text-technical" style={PERFORMANCE_INDICATOR_STYLE}>
                            {navigationStats.lastNavigationTime === 0 ? 
                                'Measuring...' : 
                                `${Math.round(navigationStats.lastNavigationTime)}ms fresh data`
                            }
                            {` (${navigationStats.totalNavigations} real-time loads)`}
                        </span>
                    )}
                </div>
            </header>
            
            {/* Error display */}
            {error && (
                <div className="error-message">
                    <strong>⚠️ Error:</strong> {error}
                    <button onClick={() => setError('')} style={ERROR_DISMISS_BUTTON_STYLE}>
                        Dismiss
                    </button>
                </div>
            )}
            
            {/* Main content */}
            <div className="main-content">
                <Sidebar 
                    currentPath={currentPath}
                    onNavigate={(path) => navigateToPath(path, 'sidebar')}
                    drives={drives}
                />
                
                <div className="content-area">
                    {/* Toolbar */}
                    <div className="toolbar">
                        <button className="toolbar-btn" onClick={handleNavigateUp} disabled={!currentPath}>
                            ⬆️ Up
                        </button>
                        <button className="toolbar-btn" onClick={handleRefresh} disabled={!currentPath}>
                            🔄 Refresh
                        </button>
                        <button className="toolbar-btn" onClick={handleOpenInExplorer} disabled={!currentPath}>
                            🖥️ Open in Explorer
                        </button>
                        <button 
                            className={`toolbar-btn ${showHiddenFiles ? 'active' : ''}`}
                            onClick={() => setShowHiddenFiles(!showHiddenFiles)}
                        >
                            {showHiddenFiles ? '👁️' : '🙈'} Hidden
                        </button>
                    </div>
                    
                    {/* Breadcrumb navigation */}
                    {currentPath && (
                        <Breadcrumb 
                            currentPath={currentPath}
                            onNavigate={(path) => navigateToPath(path, 'breadcrumb')}
                        />
                    )}
                    
                    {/* File list - Use virtual scrolling for better performance */}
                    <div 
                        className="file-list-container"
                        onClick={(e) => {
                            // Check if clicking on empty space (not on a file item)
                            if (e.target === e.currentTarget || e.target.classList.contains('file-list') || e.target.classList.contains('file-list-container')) {
                                clearSelection();
                                closeContextMenu();
                                closeEmptySpaceContextMenu();
                            }
                        }}
                        onContextMenu={(e) => {
                            // Prevent default browser context menu and show our custom one
                            e.preventDefault();
                            
                            // Check if right-clicking on empty space (not on a file item)
                            const isEmptySpace = e.target === e.currentTarget || 
                                                e.target.classList.contains('file-list') || 
                                                e.target.classList.contains('file-list-container') ||
                                                e.target.classList.contains('virtualized-file-list') ||
                                                (!e.target.closest('.file-item'));
                            
                            if (isEmptySpace) {
                                closeContextMenu();
                                closeEmptySpaceContextMenu();
                                handleEmptySpaceContextMenu(e);
                            }
                        }}
                    >
                        {showLoadingIndicator ? (
                            <div className="loading-overlay">
                                <div style={LOADING_OVERLAY_STYLE}>
                                    <div className="loading-spinner" style={LOADING_SPINNER_LARGE_STYLE}></div>
                                    <div className="text-technical">Loading directory...</div>
                                </div>
                            </div>
                        ) : directoryContents ? (
                            allFiles.length > 20 ? (
                                // Use virtual scrolling for large directories
                                <VirtualizedFileList
                                    files={allFiles}
                                    selectedFiles={selectedFiles}
                                    onFileSelect={handleFileSelect}
                                    onFileOpen={handleFileOpen}
                                    onContextMenu={handleContextMenu}
                                    isLoading={false} // Never show loading in file items
                                    clipboardFiles={clipboardFiles}
                                    clipboardOperation={clipboardOperation}
                                    dragState={dragState}
                                    onDragStart={handleDragStart}
                                    onDragOver={handleDragOver}
                                    onDragEnter={handleDragEnter}
                                    onDragLeave={handleDragLeave}
                                    onDrop={handleDrop}
                                    creatingFolder={creatingFolder}
                                    tempFolderName={tempFolderName}
                                    editInputRef={editInputRef}
                                    onFolderKeyDown={handleKeyDown}
                                    onFolderInputChange={handleInputChange}
                                    onFolderInputBlur={handleInputBlur}
                                    onEmptySpaceContextMenu={handleEmptySpaceContextMenu}
                                />
                            ) : (
                                // Use normal rendering for small directories
                                <div 
                                    className="file-list custom-scrollbar"
                                    onContextMenu={(e) => {
                                        // Check if right-clicking on the file list itself (empty space)
                                        if (e.target === e.currentTarget || !e.target.closest('.file-item')) {
                                            e.preventDefault();
                                            closeContextMenu();
                                            closeEmptySpaceContextMenu();
                                            handleEmptySpaceContextMenu(e);
                                        }
                                    }}
                                >
                                    {/* Show inline folder editor if creating folder */}
                                    {creatingFolder && (
                                        <InlineFolderEditor
                                            tempFolderName={tempFolderName}
                                            editInputRef={editInputRef}
                                            onKeyDown={handleKeyDown}
                                            onChange={handleInputChange}
                                            onBlur={handleInputBlur}
                                        />
                                    )}
                                    
                                    {allFiles.map((file, index) => (
                                        <FileItem
                                            key={file.path}
                                            file={file}
                                            fileIndex={index}
                                            onSelect={handleFileSelect}
                                            onOpen={handleFileOpen}
                                            onContextMenu={handleContextMenu}
                                            isLoading={false} // Never show loading in file items
                                            isSelected={selectedFiles.has(index)}
                                            isCut={clipboardOperation === 'cut' && clipboardFiles.includes(file.path)}
                                            isDragOver={dragState.dragOverFolder === file.path}
                                            onDragStart={handleDragStart}
                                            onDragOver={handleDragOver}
                                            onDragEnter={handleDragEnter}
                                            onDragLeave={handleDragLeave}
                                            onDrop={handleDrop}
                                        />
                                    ))}
                                    
                                    {allFiles.length === 0 && !creatingFolder && (
                                        <div style={EMPTY_DIRECTORY_STYLE}>
                                            <div style={LARGE_ICON_STYLE}>📁</div>
                                            <div className="text-technical">Directory is empty</div>
                                        </div>
                                    )}
                                </div>
                            )
                        ) : (
                            <div style={EMPTY_DIRECTORY_STYLE}>
                                <div style={LARGE_ICON_STYLE}>📁</div>
                                <div className="text-technical">Ready</div>
                            </div>
                        )}
                    </div>
                </div>
            </div>
            
            {/* Context Menus and Dialog */}
            <ContextMenu
                visible={contextMenu.visible}
                x={contextMenu.x}
                y={contextMenu.y}
                files={contextMenu.files}
                onClose={closeContextMenu}
                onCopy={handleContextCopy}
                onCut={handleContextCut}
                onRename={handleContextRename}
                onHide={handleContextHide}
                onPermanentDelete={handlePermanentDelete}
            />
            
            <EmptySpaceContextMenu
                visible={emptySpaceContextMenu.visible}
                x={emptySpaceContextMenu.x}
                y={emptySpaceContextMenu.y}
                onClose={closeEmptySpaceContextMenu}
                onOpenPowerShell={handleOpenPowerShell}
                onCreateFolder={handleCreateFolder}
            />
            
            <RetroDialog
                isOpen={dialog.isOpen}
                type={dialog.type}
                title={dialog.title}
                message={dialog.message}
                defaultValue={dialog.defaultValue}
                onConfirm={dialog.onConfirm}
                onCancel={dialog.onCancel}
                onClose={closeDialog}
            />
            
            {/* Status bar */}
            <div className="status-bar">
                <span>
                    Path: {currentPath || 'Not selected'} 
                    {selectedFiles.size > 0 && ` • ${selectedFiles.size} item${selectedFiles.size === 1 ? '' : 's'} selected`}
                    {clipboardFiles.length > 0 && ` • ${clipboardFiles.length} item${clipboardFiles.length === 1 ? '' : 's'} ${clipboardOperation === 'cut' ? 'cut' : 'copied'}`}
                    {dragState.isDragging && ` • Dragging ${dragState.draggedFiles.length} item${dragState.draggedFiles.length === 1 ? '' : 's'} (${dragState.dragOperation === 'copy' ? 'Hold Ctrl to copy' : 'Release Ctrl to move'})`}
                </span>
                <span style={STATUS_BAR_RIGHT_STYLE}>
                    File Explorer • Real-time updates • Drag to folders to move/copy
                </span>
            </div>
        </div>
    );
} 

================================================
File: frontend/src/components/FileItem.jsx
================================================
import { useMemo, useCallback, useRef, useEffect } from "preact/hooks";
import { memo } from "preact/compat";
import { getFileIcon, getFileType } from "../utils/fileUtils.js";
import { log, error } from "../utils/logger";

// Local utility functions (moved from formatUtils)
const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
};

const formatFileSize = (size) => {
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    let unitIndex = 0;
    let fileSize = size;
    
    while (fileSize >= 1024 && unitIndex < units.length - 1) {
        fileSize /= 1024;
        unitIndex++;
    }
    
    return fileSize < 10 && unitIndex > 0 
        ? `${fileSize.toFixed(1)} ${units[unitIndex]}`
        : `${Math.round(fileSize)} ${units[unitIndex]}`;
};

// Memoized File item component
const FileItem = memo(({ 
    file, 
    onSelect, 
    onOpen, 
    isLoading, 
    isSelected, 
    fileIndex, 
    isCut, 
    onContextMenu, 
    onDragStart, 
    onDragOver, 
    onDragEnter, 
    onDragLeave, 
    onDrop, 
    isDragOver,

}) => {
    const icon = useMemo(() => getFileIcon(file.name, file.isDir), [file.name, file.isDir]);
    const type = useMemo(() => getFileType(file.name, file.isDir), [file.name, file.isDir]);
    
    // Refs for click timing and debouncing
    const clickTimeoutRef = useRef(null);
    const lastOpenTimeRef = useRef(0);
    const clickCountRef = useRef(0);
    
    // Configuration for click timing - Made configurable for performance tuning
    const INSTANT_MODE = false; // Set to true for zero-latency mode (disables double-click protection)
    const DOUBLE_CLICK_DELAY = INSTANT_MODE ? 0 : 300; // ms to wait for potential double-click (Windows standard)
    const OPEN_COOLDOWN = INSTANT_MODE ? 100 : 500; // ms cooldown between opens to prevent rapid-fire
    const PERFORMANCE_LOGGING = false; // Set to true to enable performance logs
    
    const handleClick = useCallback((event) => {
        const clickStartTime = PERFORMANCE_LOGGING ? performance.now() : 0;
        log('📋 File clicked:', file.name, 'Path:', file.path, 'IsDir:', file.isDir, 'IsSelected:', isSelected);
        
        if (isLoading) return;
        
        const now = Date.now();
        clickCountRef.current += 1;
        
        // Clear any existing timeout
        if (clickTimeoutRef.current) {
            clearTimeout(clickTimeoutRef.current);
            clickTimeoutRef.current = null;
        }
        
        // Check if this is too soon after last open (cooldown protection)
        if (now - lastOpenTimeRef.current < OPEN_COOLDOWN) {
            log('🛡️ Open cooldown active, ignoring click');
            clickCountRef.current = 0;
            return;
        }
        
        // Handle immediate actions (with modifier keys or unselected files)
        if (event.shiftKey || event.ctrlKey || !isSelected) {
            log('🖱️ Processing selection for:', file.name);
            if (PERFORMANCE_LOGGING) {
                log(`⚡ Immediate response: ${(performance.now() - clickStartTime).toFixed(2)}ms`);
            }
            onSelect(fileIndex, event.shiftKey, event.ctrlKey);
            clickCountRef.current = 0;
            return;
        }
        
        // For selected files without modifier keys, wait to see if it's a double-click
        if (PERFORMANCE_LOGGING) {
            log(`⏱️ Delaying open by ${DOUBLE_CLICK_DELAY}ms to detect double-click`);
        }
        
        clickTimeoutRef.current = setTimeout(() => {
            if (clickCountRef.current === 1) {
                // Single click on selected file - open it
                log('🚀 Single click confirmed, opening:', file.name);
                if (PERFORMANCE_LOGGING) {
                    log(`⚡ Delayed open executed: ${(performance.now() - clickStartTime).toFixed(2)}ms total`);
                }
                lastOpenTimeRef.current = Date.now();
                onOpen(file);
            }
            clickCountRef.current = 0;
        }, DOUBLE_CLICK_DELAY);
    }, [file, isLoading, isSelected, fileIndex, onOpen, onSelect]);
    
    const handleDoubleClick = useCallback((event) => {
        log('🔍 File double-clicked:', file.name, 'Path:', file.path, 'IsDir:', file.isDir);
        
        if (isLoading) return;
        
        const now = Date.now();
        
        // Clear single-click timeout since this is a double-click
        if (clickTimeoutRef.current) {
            clearTimeout(clickTimeoutRef.current);
            clickTimeoutRef.current = null;
        }
        
        // Check cooldown
        if (now - lastOpenTimeRef.current < OPEN_COOLDOWN) {
            log('🛡️ Open cooldown active, ignoring double-click');
            clickCountRef.current = 0;
            return;
        }
        
        // Double click always opens, regardless of selection state
        log('🚀 Double-click confirmed, opening:', file.name);
        lastOpenTimeRef.current = now;
        clickCountRef.current = 0;
        onOpen(file);
    }, [file, isLoading, onOpen]);
    
    // Cleanup timeout on unmount
    useEffect(() => {
        return () => {
            if (clickTimeoutRef.current) {
                clearTimeout(clickTimeoutRef.current);
            }
        };
    }, []);
    
    const handleRightClick = useCallback((event) => {
        event.preventDefault();
        log('🖱️ Right-click on:', file.name, 'IsSelected:', isSelected);
        
        if (!isLoading) {
            // If file is not selected, select it first
            if (!isSelected) {
                onSelect(fileIndex, false, false);
            }
            
            // Show context menu
            onContextMenu(event, file);
        }
    }, [file, isLoading, isSelected, fileIndex, onSelect, onContextMenu]);
    
    const handleDragStart = useCallback((event) => {
        if (isLoading) {
            event.preventDefault();
            return;
        }
        
        // If the dragged item is not selected, select it first
        if (!isSelected) {
            onSelect(fileIndex, false, false);
        }
        
        if (onDragStart) {
            onDragStart(event, file);
        }
    }, [isLoading, isSelected, fileIndex, file, onSelect, onDragStart]);
    
    const handleDragOver = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        event.preventDefault();
        event.dataTransfer.dropEffect = event.ctrlKey ? 'copy' : 'move';
        
        if (onDragOver) {
            onDragOver(event, file);
        }
    }, [file.isDir, isLoading, onDragOver, file]);
    
    const handleDragEnter = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        event.preventDefault();
        if (onDragEnter) {
            onDragEnter(event, file);
        }
    }, [file.isDir, isLoading, onDragEnter, file]);
    
    const handleDragLeave = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        if (onDragLeave) {
            onDragLeave(event, file);
        }
    }, [file.isDir, isLoading, onDragLeave, file]);
    
    const handleDrop = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        event.preventDefault();
        
        try {
            const dragData = JSON.parse(event.dataTransfer.getData('application/json'));
            log('📂 Drop on folder:', file.name, 'Items:', dragData.files?.length, 'Operation:', dragData.operation);
            
            if (onDrop) {
                onDrop(event, file, dragData);
            }
        } catch (err) {
            error('❌ Error parsing drag data:', err);
        }
    }, [file, isLoading, onDrop]);
    

    
    return (
        <div 
            className={`file-item ${isSelected ? 'selected' : ''} ${isLoading ? 'disabled' : ''} ${isCut ? 'cut' : ''} ${isDragOver ? 'drag-over' : ''}`}
            onClick={handleClick}
            onDoubleClick={handleDoubleClick}
            onContextMenu={handleRightClick}
            onSelectStart={(e) => e.preventDefault()}
            draggable={!isLoading}
            onDragStart={handleDragStart}
            onDragOver={handleDragOver}
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
            style={{ 
                cursor: isLoading ? 'wait' : 'pointer',
                opacity: isLoading ? 0.7 : (isCut ? 0.5 : 1) 
            }}
        >
            <div className={`file-icon ${type}`}>
                {icon}
            </div>
            <div className="file-details">
                <div className="file-name">{file.name}</div>
                <div className="file-meta">
                    {file.isDir ? (
                        <span>DIR</span>
                    ) : (
                        <>
                            <span>{formatFileSize(file.size)}</span>
                            <span>{formatDate(file.modTime)}</span>
                        </>
                    )}
                </div>
            </div>
        </div>
    );
});

export { FileItem };
export default FileItem; 

================================================
File: frontend/src/components/EmptySpaceContextMenu.jsx
================================================
import { useRef, useEffect } from "preact/hooks";
import { memo } from "preact/compat";

// Memoized Empty Space Context Menu Component  
const EmptySpaceContextMenu = memo(({ visible, x, y, onClose, onOpenPowerShell, onCreateFolder }) => {
    const menuRef = useRef(null);
    
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
                onClose();
            }
        };
        
        if (visible) {
            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
        }
    }, [visible, onClose]);
    
    if (!visible) return null;
    
    return (
        <div 
            ref={menuRef}
            className="context-menu empty-space-context-menu"
            onSelectStart={(e) => e.preventDefault()}
            style={{ 
                position: 'fixed', 
                left: x, 
                top: y, 
                zIndex: 1000 
            }}
        >
            <div className="context-menu-item" onClick={onCreateFolder}>
                <span className="context-menu-icon">[+]</span>
                <span className="context-menu-text">New Folder</span>
            </div>
            <div className="context-menu-separator"></div>
            <div className="context-menu-item" onClick={onOpenPowerShell}>
                <span className="context-menu-icon">[{'>'}_]</span>
                <span className="context-menu-text">Open PowerShell 7 Here</span>
            </div>
        </div>
    );
});

export { EmptySpaceContextMenu };
export default EmptySpaceContextMenu; 

================================================
File: backend/drives.go
================================================
package backend

import (
	"fmt"
	"log"
	"os"
	"runtime"
)

// NewDriveManager creates a new drive manager instance
func NewDriveManager() *DriveManager {
	return &DriveManager{}
}

// GetDriveInfo returns information about available drives
func (d *DriveManager) GetDriveInfo() []DriveInfo {
	var drives []DriveInfo

	switch runtime.GOOS {
	case "windows":
		drives = d.getWindowsDrives()
	case "darwin":
		drives = d.getMacVolumes()
	case "linux":
		drives = d.getLinuxMountPoints()
	default:
		log.Printf("Drive enumeration not supported on %s", runtime.GOOS)
	}

	return drives
}

// getWindowsDrives returns Windows drive information using optimized API calls
func (d *DriveManager) getWindowsDrives() []DriveInfo {
	// Use the optimized platform manager for drive enumeration
	platformManager := NewPlatformManager()
	return platformManager.GetWindowsDrivesOptimized()
}

// getWindowsDriveType gets the type of Windows drive (if possible)
func (d *DriveManager) getWindowsDriveType(drive string) string {
	// This is a simplified implementation
	// In a more advanced version, you could use Windows API calls
	// to get detailed drive information like volume labels, types, etc.

	// For now, we'll just return empty string
	// Future enhancement: Use syscalls to get actual drive type
	return ""
}

// getMacVolumes returns macOS volume information
func (d *DriveManager) getMacVolumes() []DriveInfo {
	var drives []DriveInfo

	// Add root volume
	drives = append(drives, DriveInfo{
		Path:   "/",
		Letter: "",
		Name:   "Macintosh HD",
	})

	// Add /Volumes if it exists
	if _, err := os.Stat("/Volumes"); err == nil {
		if entries, err := os.ReadDir("/Volumes"); err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					volumePath := fmt.Sprintf("/Volumes/%s", entry.Name())
					drives = append(drives, DriveInfo{
						Path:   volumePath,
						Letter: "",
						Name:   entry.Name(),
					})
				}
			}
		}
	}

	return drives
}

// getLinuxMountPoints returns Linux mount point information
func (d *DriveManager) getLinuxMountPoints() []DriveInfo {
	var drives []DriveInfo

	// Add root filesystem
	drives = append(drives, DriveInfo{
		Path:   "/",
		Letter: "",
		Name:   "Root Filesystem",
	})

	// Add common mount points
	commonMounts := []struct {
		path string
		name string
	}{
		{"/home", "Home"},
		{"/media", "Media"},
		{"/mnt", "Mount"},
		{"/opt", "Optional"},
		{"/usr", "User Programs"},
		{"/var", "Variable Data"},
	}

	for _, mount := range commonMounts {
		if _, err := os.Stat(mount.path); err == nil {
			drives = append(drives, DriveInfo{
				Path:   mount.path,
				Letter: "",
				Name:   mount.name,
			})
		}
	}

	return drives
}

// GetSystemRoots returns system root paths for quick navigation
func (d *DriveManager) GetSystemRoots() []string {
	// Use the optimized platform manager for system roots
	platformManager := NewPlatformManager()
	return platformManager.GetSystemRoots()
}

// GetQuickAccessPaths returns commonly accessed directories for quick navigation
func (d *DriveManager) GetQuickAccessPaths() []DriveInfo {
	var quickPaths []DriveInfo

	switch runtime.GOOS {
	case "windows":
		quickPaths = d.getWindowsQuickAccess()
	case "darwin":
		quickPaths = d.getMacQuickAccess()
	case "linux":
		quickPaths = d.getLinuxQuickAccess()
	}

	return quickPaths
}

// getWindowsQuickAccess returns Windows quick access paths
func (d *DriveManager) getWindowsQuickAccess() []DriveInfo {
	var quickPaths []DriveInfo

	// Get common Windows directories
	homeDir, _ := os.UserHomeDir()

	commonPaths := []struct {
		path string
		name string
	}{
		{homeDir, "Home"},
		{fmt.Sprintf("%s\\Desktop", homeDir), "Desktop"},
		{fmt.Sprintf("%s\\Documents", homeDir), "Documents"},
		{fmt.Sprintf("%s\\Downloads", homeDir), "Downloads"},
		{fmt.Sprintf("%s\\Pictures", homeDir), "Pictures"},
		{fmt.Sprintf("%s\\Music", homeDir), "Music"},
		{fmt.Sprintf("%s\\Videos", homeDir), "Videos"},
		{"C:\\Program Files", "Program Files"},
		{"C:\\Program Files (x86)", "Program Files (x86)"},
		{"C:\\Windows", "Windows"},
	}

	for _, path := range commonPaths {
		if _, err := os.Stat(path.path); err == nil {
			quickPaths = append(quickPaths, DriveInfo{
				Path:   path.path,
				Letter: "",
				Name:   path.name,
			})
		}
	}

	return quickPaths
}

// getMacQuickAccess returns macOS quick access paths
func (d *DriveManager) getMacQuickAccess() []DriveInfo {
	var quickPaths []DriveInfo

	homeDir, _ := os.UserHomeDir()

	commonPaths := []struct {
		path string
		name string
	}{
		{homeDir, "Home"},
		{fmt.Sprintf("%s/Desktop", homeDir), "Desktop"},
		{fmt.Sprintf("%s/Documents", homeDir), "Documents"},
		{fmt.Sprintf("%s/Downloads", homeDir), "Downloads"},
		{fmt.Sprintf("%s/Pictures", homeDir), "Pictures"},
		{fmt.Sprintf("%s/Music", homeDir), "Music"},
		{fmt.Sprintf("%s/Movies", homeDir), "Movies"},
		{"/Applications", "Applications"},
		{"/System", "System"},
		{"/Users", "Users"},
	}

	for _, path := range commonPaths {
		if _, err := os.Stat(path.path); err == nil {
			quickPaths = append(quickPaths, DriveInfo{
				Path:   path.path,
				Letter: "",
				Name:   path.name,
			})
		}
	}

	return quickPaths
}

// getLinuxQuickAccess returns Linux quick access paths
func (d *DriveManager) getLinuxQuickAccess() []DriveInfo {
	var quickPaths []DriveInfo

	homeDir, _ := os.UserHomeDir()

	commonPaths := []struct {
		path string
		name string
	}{
		{homeDir, "Home"},
		{fmt.Sprintf("%s/Desktop", homeDir), "Desktop"},
		{fmt.Sprintf("%s/Documents", homeDir), "Documents"},
		{fmt.Sprintf("%s/Downloads", homeDir), "Downloads"},
		{fmt.Sprintf("%s/Pictures", homeDir), "Pictures"},
		{fmt.Sprintf("%s/Music", homeDir), "Music"},
		{fmt.Sprintf("%s/Videos", homeDir), "Videos"},
		{"/usr", "User Programs"},
		{"/opt", "Optional Software"},
		{"/etc", "Configuration"},
		{"/var", "Variable Data"},
	}

	for _, path := range commonPaths {
		if _, err := os.Stat(path.path); err == nil {
			quickPaths = append(quickPaths, DriveInfo{
				Path:   path.path,
				Letter: "",
				Name:   path.name,
			})
		}
	}

	return quickPaths
}


================================================
File: frontend/src/components/Sidebar.jsx
================================================
import { useState, useEffect, useMemo, useCallback } from "preact/hooks";
import { memo } from "preact/compat";
import { GetHomeDirectory } from "../../wailsjs/go/backend/App";

// Memoized Sidebar component
const Sidebar = memo(({ currentPath, onNavigate, drives = [] }) => {
    const [homeDir, setHomeDir] = useState('');
    
    useEffect(() => {
        GetHomeDirectory().then(setHomeDir);
    }, []);
    
    // Use proper path separators for the current OS
    const pathSep = homeDir.includes('\\') ? '\\' : '/';
    
    const quickAccess = useMemo(() => [
        { name: 'Home', path: homeDir, icon: '🏠' },
        { name: 'Desktop', path: homeDir + pathSep + 'Desktop', icon: '🖥️' },
        { name: 'Documents', path: homeDir + pathSep + 'Documents', icon: '📁' },
        { name: 'Downloads', path: homeDir + pathSep + 'Downloads', icon: '⬇️' },
    ].filter(item => item.path), [homeDir, pathSep]);
    
    const handleQuickAccessClick = useCallback((path) => {
        onNavigate(path);
    }, [onNavigate]);
    
    const handleDriveClick = useCallback((path) => {
        onNavigate(path);
    }, [onNavigate]);
    
    return (
        <div className="sidebar" onSelectStart={(e) => e.preventDefault()}>
            <div className="sidebar-section">
                <div className="sidebar-title">Quick Access</div>
                {quickAccess.map((item) => (
                    <div 
                        key={item.path}
                        className={`sidebar-item ${currentPath === item.path ? 'active' : ''}`}
                        onClick={() => handleQuickAccessClick(item.path)}
                    >
                        <span className="sidebar-icon">{item.icon}</span>
                        {item.name}
                    </div>
                ))}
            </div>
            
            {drives.length > 0 && (
                <div className="sidebar-section">
                    <div className="sidebar-title">Drives</div>
                    {drives.map((drive) => (
                        <div 
                            key={drive.path}
                            className={`sidebar-item ${currentPath === drive.path ? 'active' : ''}`}
                            onClick={() => handleDriveClick(drive.path)}
                        >
                            <span className="sidebar-icon">💽</span>
                            {drive.name}
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
});

export { Sidebar };
export default Sidebar; 

================================================
File: frontend/src/components/RetroDialog.jsx
================================================
import { useState, useRef, useEffect, useCallback } from "preact/hooks";
import { memo } from "preact/compat";

// Memoized 8-bit Dialog Component
const RetroDialog = memo(({ isOpen, type, title, message, defaultValue, onConfirm, onCancel, onClose }) => {
    const [inputValue, setInputValue] = useState(defaultValue || '');
    const inputRef = useRef(null);
    
    useEffect(() => {
        setInputValue(defaultValue || '');
    }, [defaultValue]);
    
    useEffect(() => {
        if (isOpen && type === 'prompt' && inputRef.current) {
            inputRef.current.focus();
            inputRef.current.select();
        }
    }, [isOpen, type]);
    
    useEffect(() => {
        const handleKeyDown = (e) => {
            if (!isOpen) return;
            
            if (e.key === 'Escape') {
                onCancel();
            } else if (e.key === 'Enter') {
                if (type === 'prompt') {
                    onConfirm(inputValue);
                } else {
                    onConfirm();
                }
            }
        };
        
        if (isOpen) {
            document.addEventListener('keydown', handleKeyDown);
            return () => document.removeEventListener('keydown', handleKeyDown);
        }
    }, [isOpen, type, inputValue, onConfirm, onCancel]);
    
    const handleInputChange = useCallback((e) => {
        setInputValue(e.target.value);
    }, []);
    
    const handleConfirm = useCallback(() => {
        if (type === 'prompt') {
            onConfirm(inputValue);
        } else {
            onConfirm();
        }
    }, [type, inputValue, onConfirm]);
    
    if (!isOpen) return null;
    
    return (
        <div className="retro-dialog-overlay" onSelectStart={(e) => e.preventDefault()}>
            <div className={`retro-dialog ${type === 'prompt' ? 'prompt-type' : ''} ${type === 'delete' ? 'delete-type' : ''}`} onSelectStart={(e) => e.preventDefault()}>
                {/* Dialog header */}
                <div className="retro-dialog-header">
                    <div className="retro-dialog-title">{title || 'SYSTEM MESSAGE'}</div>
                    <button 
                        className="retro-dialog-close"
                        onClick={onCancel}
                        title="CLOSE [ESC]"
                    >
                        ✕
                    </button>
                </div>
                
                {/* Dialog content */}
                <div className="retro-dialog-content">
                    <div className="retro-dialog-icon">
                        {type === 'confirm' && '⚠️'}
                        {type === 'prompt' && '✏️'}
                        {type === 'alert' && 'ℹ️'}
                        {type === 'error' && '❌'}
                        {type === 'success' && '✅'}
                        {type === 'delete' && '🗑️'}
                    </div>
                    <div className="retro-dialog-message">
                        {message.split('\n').map((line, index) => (
                            <div key={index}>{line}</div>
                        ))}
                    </div>
                    
                    {type === 'prompt' && (
                        <div className="retro-dialog-input-container">
                            <input
                                ref={inputRef}
                                type="text"
                                value={inputValue}
                                onChange={handleInputChange}
                                className="retro-dialog-input"
                                placeholder="ENTER VALUE..."
                            />
                        </div>
                    )}
                </div>
                
                {/* Dialog buttons */}
                <div className="retro-dialog-buttons">
                    {type === 'prompt' ? (
                        <>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-primary"
                                onClick={handleConfirm}
                            >
                                [ENTER] CONFIRM
                            </button>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-secondary"
                                onClick={onCancel}
                            >
                                [ESC] CANCEL
                            </button>
                        </>
                    ) : type === 'confirm' || type === 'delete' ? (
                        <>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-primary"
                                onClick={handleConfirm}
                            >
                                [ENTER] YES
                            </button>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-secondary"
                                onClick={onCancel}
                            >
                                [ESC] NO
                            </button>
                        </>
                    ) : (
                        <button 
                            className="retro-dialog-btn retro-dialog-btn-primary"
                            onClick={handleConfirm}
                        >
                            [ENTER] OK
                        </button>
                    )}
                </div>
            </div>
        </div>
    );
});

export { RetroDialog };
export default RetroDialog; 

================================================
File: frontend/src/components/FastNavigation.css
================================================
/* Fast Navigation CSS Optimizations - Zen Theme */

/* Disable text selection for all fast navigation elements */
.file-list-container,
.file-list,
.loading-overlay,
.app-header,
.loading-spinner,
.nav-segment,
.sidebar-item,
.file-item,
.toolbar-btn,
.context-menu,
.status-bar,
.error-message {
    user-select: none !important;
    -webkit-user-select: none !important;
    -moz-user-select: none !important;
    -ms-user-select: none !important;
    -webkit-touch-callout: none !important;
    -webkit-tap-highlight-color: transparent !important;
}

.file-list-container {
    position: relative;
    flex: 1;
    overflow: hidden;
    contain: layout style paint;
    /* Fix height calculation issues */
    min-height: 0;
    background: var(--zen-surface);
    border-radius: var(--zen-radius-md);
}

.file-list {
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
    
    /* Optimize scrolling performance */
    scroll-behavior: smooth;
    overscroll-behavior: contain;
    
    /* GPU acceleration */
    transform: translateZ(0);
    will-change: scroll-position;
    
    /* Prevent horizontal scrollbar issues */
    max-width: 100%;
    
    /* Zen spacing */
    padding: var(--zen-space-xl);
    gap: var(--zen-space-xs);
}

/* Instant loading feedback with zen styling */
.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(250, 250, 250, 0.9);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: var(--zen-space-lg);
    z-index: 100;
    color: var(--zen-text-tertiary);
    
    /* Instant appearance */
    animation: fadeInFast 150ms ease-out;
}

@keyframes fadeInFast {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Responsive header elements */
.app-header {
    transition: background-color 150ms ease;
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}

.app-header.loading {
    background-color: rgba(248, 249, 250, 0.95);
}

/* Fast loading spinner with zen design */
.loading-spinner {
    width: 1.5rem;
    height: 1.5rem;
    border: 2px solid var(--zen-border);
    border-top: 2px solid var(--zen-primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    
    /* Smooth animation */
    transform-origin: center;
    will-change: transform;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Instant visual feedback for navigation */
.nav-segment, .sidebar-item {
    transition: all 150ms ease;
    cursor: pointer;
    border-radius: var(--zen-radius);
}

.nav-segment:hover, .sidebar-item:hover:not(.active) {
    background-color: var(--zen-surface-hover);
    color: var(--zen-text-primary);
    transform: translateX(2px);
}

.nav-segment:active, .sidebar-item:active:not(.active) {
    transform: translateX(1px);
    background-color: var(--zen-surface-active);
}

/* Enhanced active sidebar item hover feedback */
.sidebar-item.active:hover {
    background-color: var(--zen-primary-alpha-hover);
    transform: translateX(2px);
}

.sidebar-item.active:active {
    background-color: var(--zen-primary-alpha);
    transform: translateX(1px);
}

/* File item hover effects for instant feedback */
.file-item {
    transition: background-color 150ms ease, border-color 150ms ease, color 150ms ease, opacity 150ms ease;
    cursor: pointer;
    border-radius: var(--zen-radius-md);
    min-height: 3.5rem;
    padding: var(--zen-space-lg);
    border: 1px solid transparent;
    box-sizing: border-box;
}

.file-item:hover:not(.selected) {
    background-color: rgba(79, 70, 229, 0.04);
    border-color: var(--zen-border);
    /* Pure color-based feedback - no transforms to prevent overlapping */
}

.file-item:active:not(.selected) {
    background-color: var(--zen-surface-active);
    /* Pure color-based feedback - no transforms to prevent overlapping */
}

/* Selected state with zen styling */
.file-item.selected {
    background-color: var(--zen-primary-alpha);
    border-color: var(--zen-primary);
    color: var(--zen-primary);
    /* Pure color-based feedback - no transforms to prevent overlapping */
}

/* Enhanced selected state hover feedback */
.file-item.selected:hover {
    background-color: var(--zen-primary-alpha-hover);
    border-color: var(--zen-primary);
    /* Pure color-based feedback - no dimension changes */
}

.file-item.selected:active {
    background-color: var(--zen-primary-alpha);
    border-color: var(--zen-primary);
    opacity: 0.8;
    /* Pure color-based feedback - no transforms to prevent overlapping */
}

/* Optimized breadcrumb transitions */
.nav-breadcrumb {
    /* Smooth scrolling for long paths */
    scroll-behavior: smooth;
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;
    scrollbar-width: none;
    -ms-overflow-style: none;
    
    /* Zen spacing */
    padding: var(--zen-space-lg) var(--zen-space-xl);
    background: var(--zen-surface);
    border-bottom: 1px solid var(--zen-border-light);
}

.nav-breadcrumb::-webkit-scrollbar {
    display: none;
}

/* Toolbar button responsiveness */
.toolbar-btn {
    transition: all 150ms ease;
    border-radius: var(--zen-radius);
    padding: var(--zen-space-sm) var(--zen-space-lg);
    border: 1px solid var(--zen-border);
    background: transparent;
    color: var(--zen-text-secondary);
    min-height: 2.25rem;
}

.toolbar-btn:hover:not(:disabled) {
    background-color: var(--zen-surface-hover);
    border-color: var(--zen-border-focus);
    color: var(--zen-text-primary);
    transform: translateY(-1px);
    box-shadow: var(--zen-shadow-sm);
}

.toolbar-btn:active:not(:disabled) {
    transform: translateY(0);
    background-color: var(--zen-surface-active);
    box-shadow: none;
}

.toolbar-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Context menu instant appearance with zen styling */
.context-menu {
    animation: contextMenuAppear 150ms ease-out;
    transform-origin: top left;
    background: var(--zen-surface);
    border: 1px solid var(--zen-border);
    border-radius: var(--zen-radius-md);
    box-shadow: var(--zen-shadow-lg);
    backdrop-filter: blur(16px);
    -webkit-backdrop-filter: blur(16px);
    padding: var(--zen-space-sm);
}

@keyframes contextMenuAppear {
    from {
        opacity: 0;
        transform: scale(0.95) translateY(-5px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

/* Status bar with zen styling */
.status-bar {
    transition: background-color 150ms ease;
    background: var(--zen-surface);
    border-top: 1px solid var(--zen-border-light);
    color: var(--zen-text-secondary);
    font-size: var(--zen-text-xs);
    padding: var(--zen-space-md) var(--zen-space-xl);
}

/* Error message with zen styling */
.error-message {
    animation: slideInFromTop 200ms ease-out;
    background: rgba(220, 38, 38, 0.1);
    border-left: 4px solid var(--zen-error);
    color: var(--zen-error);
    border-radius: var(--zen-radius);
    margin: var(--zen-space-lg);
    padding: var(--zen-space-lg) var(--zen-space-xl);
}

@keyframes slideInFromTop {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
    .loading-overlay {
        background: rgba(26, 35, 50, 0.9);
    }
    
    .app-header.loading {
        background-color: rgba(26, 35, 50, 0.95);
    }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
    }
    
    .loading-spinner {
        animation: none;
    }
}

/* Global override to prevent file item hover overlapping */
.virtualized-file-list .file-item,
.file-list .file-item {
    /* Ensure all file items are contained and don't expand */
    contain: layout style paint !important;
    overflow: hidden !important;
}

.virtualized-file-list .file-item:hover,
.virtualized-file-list .file-item:active,
.virtualized-file-list .file-item.selected,
.virtualized-file-list .file-item.selected:hover {
    /* Absolutely no transforms in virtualized lists */
    transform: none !important;
    box-shadow: none !important;
} 

================================================
File: backend/platform_fallback.go
================================================
//go:build !windows

package backend

import (
	"fmt"
)

// Native Windows API stub implementations for non-Windows platforms
func (p *PlatformManager) IsHiddenWindowsNative(filePath string) bool {
	// This should not be called on non-Windows platforms
	return false
}

func (p *PlatformManager) HideFileWindowsNative(filePath string) bool {
	// This should not be called on non-Windows platforms
	return false
}

func (p *PlatformManager) GetCurrentUserSIDNative() (string, error) {
	return "", fmt.Errorf("native SID retrieval only available on Windows")
}


================================================
File: frontend/src/components/VirtualizedFileList.css
================================================
/* Virtualized File List Performance Optimizations - Zen Theme */
/* TEMPORARILY DISABLED - Using normal file list styling instead */

/*
.virtualized-file-list {
    /* Use GPU acceleration for smooth scrolling */
    transform: translateZ(0);
    will-change: scroll-position;
    
    /* Optimize rendering */
    contain: layout style paint;
    
    /* Prevent layout thrashing */
    overflow-anchor: none;
    
    /* Enhanced spacing for zen design */
    padding: var(--zen-space-xl);
    gap: var(--zen-space-sm);
}

.virtualized-file-list .file-item {
    /* Optimize positioning for virtual scrolling */
    contain: layout style paint;
    
    /* Prevent unnecessary reflows */
    box-sizing: border-box;
    
    /* Use only essential properties for performance - no transform animations */
    will-change: background-color, border-color;
    
    /* Zen spacing and design */
    margin-bottom: var(--zen-space-sm);
    border-radius: var(--zen-radius-md);
    min-height: 3.5rem;
    
    /* Ensure consistent hover behavior in virtualized list */
    transition: background-color 150ms ease, border-color 150ms ease, color 150ms ease, opacity 150ms ease;
}
*/

/* Keep scrollbar optimizations */
.file-list::-webkit-scrollbar {
    width: 6px;
    background-color: transparent;
}

.file-list::-webkit-scrollbar-track {
    background-color: transparent;
    border-radius: 3px;
}

.file-list::-webkit-scrollbar-thumb {
    background-color: var(--zen-border);
    border-radius: 3px;
}

.file-list::-webkit-scrollbar-thumb:hover {
    background-color: var(--zen-border-focus);
}

/* Prevent horizontal scrollbar from appearing */
.file-list::-webkit-scrollbar-horizontal {
    display: none;
}

/* Keep performance optimizations but remove custom positioning */
/*
.virtual-file-item {
    position: absolute;
    width: 100%;
    
    /* Prevent text selection during fast scrolling */
    user-select: none;
    
    /* Optimize for frequent updates */
    contain: layout style paint;
    
    /* Prevent subpixel rendering issues */
    transform: translateZ(0);
    
    /* Zen design spacing */
    padding: var(--zen-space-lg);
    border-radius: var(--zen-radius-md);
}
*/

/* Loading state optimizations */
.file-list .loading-overlay {
    /* Use backdrop-filter for better performance */
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    
    /* Optimize positioning */
    position: absolute;
    inset: 0;
    
    /* Prevent interaction during loading */
    pointer-events: none;
    
    /* Use flexbox for centering with zen spacing */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: var(--zen-space-lg);
    
    /* Zen theme background */
    background: rgba(250, 250, 250, 0.8);
    color: var(--zen-text-tertiary);
}

/* Memory-efficient animations with zen timing */
@media (prefers-reduced-motion: no-preference) {
    .file-list .file-item {
        transition: opacity 150ms ease-out, background-color 150ms ease-out, border-color 150ms ease-out;
    }
}

/* High DPI optimizations */
@media (-webkit-min-device-pixel-ratio: 2) {
    .file-list {
        /* Optimize for high DPI displays */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }
}

/* Dark mode support for loading overlay */
@media (prefers-color-scheme: dark) {
    .file-list .loading-overlay {
        background: rgba(26, 35, 50, 0.8);
    }
}

/* Remove all the complex override CSS since we're using normal file list styling now */
/* All the transform and positioning overrides are no longer needed */ 

================================================
File: frontend/src/components/InlineFolderEditor.jsx
================================================
import { memo } from "preact/compat";

// Inline folder editor component with 8-bit retro styling
const InlineFolderEditor = memo(({ 
    tempFolderName,
    editInputRef,
    onKeyDown,
    onChange,
    onBlur
}) => {
    return (
        <div className="file-item creating-folder">
            <div className="file-icon folder">
                📁
            </div>
            <div className="file-details">
                <div className="file-name">
                    <input
                        ref={editInputRef}
                        type="text"
                        value={tempFolderName}
                        onChange={onChange}
                        onKeyDown={onKeyDown}
                        onBlur={onBlur}
                        className="folder-name-input"
                        maxLength={255}
                        spellCheck={false}
                        autoComplete="off"
                    />
                </div>
                <div className="file-meta">
                    <span>DIR • Creating...</span>
                </div>
            </div>
        </div>
    );
});

export { InlineFolderEditor };
export default InlineFolderEditor; 

================================================
File: frontend/src/components/ContextMenu.jsx
================================================
import { useRef, useEffect } from "preact/hooks";
import { memo } from "preact/compat";

// Memoized Context Menu Component
const ContextMenu = memo(({ visible, x, y, files, onClose, onPermanentDelete, onCopy, onCut, onRename, onHide }) => {
    const menuRef = useRef(null);
    
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
                onClose();
            }
        };
        
        if (visible) {
            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
        }
    }, [visible, onClose]);
    
    if (!visible) return null;
    
    return (
        <div 
            ref={menuRef}
            className="context-menu"
            onSelectStart={(e) => e.preventDefault()}
            style={{ 
                position: 'fixed', 
                left: x, 
                top: y, 
                zIndex: 1000 
            }}
        >
            <div className="context-menu-item" onClick={onCopy}>
                <span className="context-menu-icon">[C]</span>
                <span className="context-menu-text">Copy ({files.length})</span>
            </div>
            <div className="context-menu-item" onClick={onCut}>
                <span className="context-menu-icon">[X]</span>
                <span className="context-menu-text">Cut ({files.length})</span>
            </div>
            <div className="context-menu-separator"></div>
            {files.length === 1 && (
                <div className="context-menu-item" onClick={onRename}>
                    <span className="context-menu-icon">[F2]</span>
                    <span className="context-menu-text">Rename</span>
                </div>
            )}
            <div className="context-menu-separator"></div>
            <div className="context-menu-item" onClick={onHide} style={{ color: 'var(--zen-text-secondary)' }}>
                <span className="context-menu-icon">[H]</span>
                <span className="context-menu-text">Hide ({files.length})</span>
            </div>
            <div className="context-menu-item" onClick={onPermanentDelete} style={{ color: 'var(--zen-error)' }}>
                <span className="context-menu-icon">[!]</span>
                <span className="context-menu-text">Delete ({files.length})</span>
            </div>
        </div>
    );
});

export { ContextMenu };
export default ContextMenu; 

================================================
File: frontend/src/hooks/useDialogs.js
================================================
import { useState, useCallback } from "preact/hooks";

export function useDialogs() {
    const [dialog, setDialog] = useState({
        isOpen: false,
        type: 'alert',
        title: '',
        message: '',
        defaultValue: '',
        onConfirm: () => {},
        onCancel: () => {}
    });

    const showDialog = useCallback((type, title, message, defaultValue = '', onConfirm = () => {}, onCancel = () => {}) => {
        setDialog({
            isOpen: true,
            type,
            title,
            message,
            defaultValue,
            onConfirm: (value) => {
                setDialog(prev => ({ ...prev, isOpen: false }));
                onConfirm(value);
            },
            onCancel: () => {
                setDialog(prev => ({ ...prev, isOpen: false }));
                onCancel();
            }
        });
    }, []);

    const closeDialog = useCallback(() => {
        setDialog(prev => ({ ...prev, isOpen: false }));
    }, []);

    return {
        dialog,
        showDialog,
        closeDialog
    };
} 

================================================
File: frontend/src/hooks/useClipboard.js
================================================
import { useState, useCallback } from "preact/hooks";

export const useClipboard = () => {
    const [clipboardFiles, setClipboardFiles] = useState([]);
    const [clipboardOperation, setClipboardOperation] = useState(''); // 'copy' or 'cut'

    const handleCopy = useCallback((filePaths) => {
        setClipboardFiles(filePaths);
        setClipboardOperation('copy');
        
        console.log('📋 Copied to clipboard:', filePaths);
        console.log(`📄 ${filePaths.length} item${filePaths.length === 1 ? '' : 's'} copied`);
    }, []);

    const handleCut = useCallback((filePaths) => {
        setClipboardFiles(filePaths);
        setClipboardOperation('cut');
        
        console.log('✂️ Cut to clipboard:', filePaths);
        console.log(`✂️ ${filePaths.length} item${filePaths.length === 1 ? '' : 's'} cut`);
    }, []);

    const clearClipboard = useCallback(() => {
        setClipboardFiles([]);
        setClipboardOperation('');
    }, []);

    const isPasteAvailable = useCallback(() => {
        return clipboardFiles.length > 0 && clipboardOperation !== '';
    }, [clipboardFiles.length, clipboardOperation]);

    return {
        clipboardFiles,
        clipboardOperation,
        handleCopy,
        handleCut,
        clearClipboard,
        isPasteAvailable
    };
}; 

================================================
File: frontend/src/components/index.js
================================================
// Component exports for cleaner imports
export { Breadcrumb } from './Breadcrumb';
export { Sidebar } from './Sidebar';
export { FileItem } from './FileItem';
export { ContextMenu } from './ContextMenu';
export { EmptySpaceContextMenu } from './EmptySpaceContextMenu';
export { RetroDialog } from './RetroDialog';
export { VirtualizedFileList } from './VirtualizedFileList';
export { InlineFolderEditor } from './InlineFolderEditor'; 

================================================
File: backend/types.go
================================================
package backend

import (
	"context"
	"time"
)

// FileInfo represents file/directory information
type FileInfo struct {
	Name        string    `json:"name"`
	Path        string    `json:"path"`
	IsDir       bool      `json:"isDir"`
	Size        int64     `json:"size"`
	ModTime     time.Time `json:"modTime"`
	Permissions string    `json:"permissions"`
	Extension   string    `json:"extension"`
	IsHidden    bool      `json:"isHidden"`
}

// DirectoryContents represents the contents of a directory
type DirectoryContents struct {
	CurrentPath string     `json:"currentPath"`
	ParentPath  string     `json:"parentPath"`
	Files       []FileInfo `json:"files"`
	Directories []FileInfo `json:"directories"`
	TotalFiles  int        `json:"totalFiles"`
	TotalDirs   int        `json:"totalDirs"`
}

// NavigationResponse represents navigation result
type NavigationResponse struct {
	Success bool              `json:"success"`
	Message string            `json:"message"`
	Data    DirectoryContents `json:"data"`
}

// DriveInfo represents information about a system drive
type DriveInfo struct {
	Path   string `json:"path"`
	Letter string `json:"letter"`
	Name   string `json:"name"`
}

// Interfaces for dependency injection and better testability

// FileSystemManagerInterface defines the file system operations contract
type FileSystemManagerInterface interface {
	ListDirectory(path string) NavigationResponse
	GetFileInfo(path string) (FileInfo, error)
	CreateFileInfo(basePath string, name string) FileInfo
	IsHidden(path string) bool
	GetExtension(name string) string
	NavigateToPath(path string) NavigationResponse
	NavigateUp(currentPath string) NavigationResponse
	CreateDirectory(path, name string) NavigationResponse
	ValidatePath(path string) error
	FileExists(path string) bool
}

// FileOperationsManagerInterface defines file operations contract
type FileOperationsManagerInterface interface {
	CopyFiles(sourcePaths []string, destDir string) bool
	MoveFiles(sourcePaths []string, destDir string) bool
	DeleteFiles(filePaths []string) bool
	MoveFilesToRecycleBin(filePaths []string) bool
	RenameFile(oldPath, newName string) bool
	HideFiles(filePaths []string) bool
	OpenFile(filePath string) bool
}

// PlatformManagerInterface defines OS-specific operations contract
type PlatformManagerInterface interface {
	GetHomeDirectory() string
	GetCurrentWorkingDirectory() string
	GetSystemRoots() []string
	OpenInSystemExplorer(path string) bool
	IsHiddenWindows(filePath string) bool
	IsHiddenMac(filePath string) bool
	IsHiddenLinux(filePath string) bool
	IsHidden(filePath string) bool
	GetExtension(name string) string
	HideFile(filePath string) bool
	OpenFile(filePath string) bool
	FormatFileSize(size int64) string
	// Native Windows API methods
	IsHiddenWindowsNative(filePath string) bool
	HideFileWindowsNative(filePath string) bool
	GetCurrentUserSIDNative() (string, error)
}

// DriveManagerInterface defines drive management contract
type DriveManagerInterface interface {
	GetDriveInfo() []DriveInfo
	GetQuickAccessPaths() []DriveInfo
}

// TerminalManagerInterface defines terminal operations contract
type TerminalManagerInterface interface {
	OpenPowerShellHere(directoryPath string) bool
	OpenTerminalHere(directoryPath string) bool
	GetAvailableTerminals() []string
	ExecuteCommand(command string, workingDir string) error
}

// App struct - Main application structure with dependency injection
type App struct {
	ctx        context.Context
	filesystem FileSystemManagerInterface
	fileOps    FileOperationsManagerInterface
	platform   PlatformManagerInterface
	drives     DriveManagerInterface
	terminal   TerminalManagerInterface
}

// FileSystemManager implementation
type FileSystemManager struct {
	platform     PlatformManagerInterface
	ctx          context.Context
	eventEmitter *EventEmitter
}

// FileOperationsManager implementation
type FileOperationsManager struct {
	platform PlatformManagerInterface
}

// PlatformManager implementation
type PlatformManager struct{}

// DriveManager implementation
type DriveManager struct{}

// TerminalManager implementation
type TerminalManager struct{}


================================================
File: frontend/src/hooks/useFileOperations.js
================================================
import { useCallback } from "preact/hooks";
import { log, warn, error } from "../utils/logger";
import { 
    CopyFiles,
    MoveFiles,
    DeleteFiles,
    MoveFilesToRecycleBin,
    RenameFile,
    OpenFile,
    OpenInSystemExplorer,
    OpenPowerShellHere,
    HideFiles
} from "../../wailsjs/go/backend/App";

export const useFileOperations = (currentPath, setError, clearSelection, handleRefresh, showDialog) => {
    const handleFileOpen = useCallback((file) => {
        log('🔍 Opening file/folder:', file);
        log('📊 File properties - Name:', file.name, 'IsDir:', file.isDir, 'Path:', file.path);
        
        try {
            if (file.isDir) {
                log('📁 Navigating to folder:', file.path);
                // This will be handled by the parent component
                return { type: 'navigate', path: file.path };
            } else {
                log('📄 Opening file with default application:', file.path);
                const success = OpenFile(file.path);
                if (!success) {
                    warn('⚠️ Failed to open file with default application, falling back to explorer');
                    OpenInSystemExplorer(file.path);
                }
            }
        } catch (err) {
            error('❌ Error opening file:', err);
            setError('Failed to open file: ' + err.message);
        }
    }, [setError]);

    const handleCopyFiles = useCallback(async (filePaths) => {
        if (filePaths.length === 0 || !currentPath) return false;

        try {
            log(`📥 Copying ${filePaths.length} items to:`, currentPath);
            
            const success = await CopyFiles(filePaths, currentPath);
            
            if (success) {
                log('✅ Copy operation successful');
                clearSelection();
                setTimeout(() => {
                    log('🔄 Refreshing directory after copy operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                error('❌ Copy operation failed');
                setError(`Failed to copy files to "${currentPath}". This may be due to:
• Insufficient permissions (try running as administrator)
• Destination folder is read-only
• Not enough disk space
• Files are in use by another application`);
                return false;
            }
        } catch (err) {
            error('❌ Error during copy operation:', err);
            setError('Failed to copy files: ' + err.message);
            return false;
        }
    }, [currentPath, setError, clearSelection, handleRefresh]);

    const handleMoveFiles = useCallback(async (filePaths) => {
        if (filePaths.length === 0 || !currentPath) return false;

        try {
            log(`📥 Moving ${filePaths.length} items to:`, currentPath);
            
            const success = await MoveFiles(filePaths, currentPath);
            
            if (success) {
                log('✅ Move operation successful');
                clearSelection();
                setTimeout(() => {
                    log('🔄 Refreshing directory after move operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                error('❌ Move operation failed');
                setError(`Failed to move files to "${currentPath}". This may be due to:
• Insufficient permissions (try running as administrator)
• Destination folder is read-only
• Files are in use by another application
• Cannot move across different drive types`);
                return false;
            }
        } catch (err) {
            error('❌ Error during move operation:', err);
            setError('Failed to move files: ' + err.message);
            return false;
        }
    }, [currentPath, setError, clearSelection, handleRefresh]);

    const handleRecycleBinDelete = useCallback(async (filePaths) => {
        try {
            log('🗑️ Moving files to recycle bin:', filePaths);
            
            const success = await MoveFilesToRecycleBin(filePaths);
            
            if (success) {
                log('✅ Move to recycle bin successful');
                clearSelection();
                setTimeout(() => {
                    log('🔄 Refreshing directory after recycle bin operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                error('❌ Move to recycle bin failed');
                setError('Failed to move files to recycle bin');
                return false;
            }
        } catch (err) {
            error('❌ Error during recycle bin operation:', err);
            setError('Failed to move files to recycle bin: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    const handlePermanentDelete = useCallback(async (filePaths) => {
        try {
            log('🗑️ Permanently deleting files:', filePaths);
            
            const success = await DeleteFiles(filePaths);
            
            if (success) {
                log('✅ Permanent delete operation successful');
                clearSelection();
                setTimeout(() => {
                    log('🔄 Refreshing directory after permanent delete operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                error('❌ Permanent delete operation failed');
                setError('Failed to permanently delete files');
                return false;
            }
        } catch (err) {
            error('❌ Error during permanent delete operation:', err);
            setError('Failed to permanently delete files: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    const handleRename = useCallback(async (filePath, newName) => {
        try {
            log('✏️ Renaming file:', filePath, 'to:', newName);
            
            const success = await RenameFile(filePath, newName);
            
            if (success) {
                log('✅ Rename operation successful');
                clearSelection();
                setTimeout(() => {
                    log('🔄 Refreshing directory after rename operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                error('❌ Rename operation failed');
                setError(`Failed to rename "${filePath}". This may be due to:
• A file with that name already exists
• Insufficient permissions
• Invalid characters in the new name
• File is in use by another application`);
                return false;
            }
        } catch (err) {
            error('❌ Error during rename operation:', err);
            setError('Failed to rename file: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    const handleOpenPowerShell = useCallback(async () => {
        if (!currentPath) {
            warn('⚠️ No current path available for PowerShell');
            return;
        }
        
        try {
            log('🔧 Opening PowerShell 7 in:', currentPath);
            
            const success = await OpenPowerShellHere(currentPath);
            
            if (!success) {
                warn('⚠️ Failed to open PowerShell 7');
                setError('Failed to open PowerShell 7. Please ensure PowerShell 7 is installed at the default location.');
            } else {
                log('✅ PowerShell 7 opened successfully in:', currentPath);
            }
        } catch (err) {
            error('❌ Error opening PowerShell 7:', err);
            setError('Failed to open PowerShell 7: ' + err.message);
        }
    }, [currentPath, setError]);

    const handleHideFiles = useCallback(async (filePaths) => {
        try {
            log('👁️ Hiding files:', filePaths);
            
            const success = await HideFiles(filePaths);
            
            if (success) {
                log('✅ Hide files operation successful');
                clearSelection();
                setTimeout(() => {
                    log('🔄 Refreshing directory after hide operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                error('❌ Hide files operation failed');
                setError(`Failed to hide files. This may be due to:
• Insufficient permissions (try running as administrator)
• Files are in use by another application
• Files are on a network drive or external storage`);
                return false;
            }
        } catch (err) {
            error('❌ Error during hide files operation:', err);
            setError('Failed to hide files: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    return {
        handleFileOpen,
        handleCopyFiles,
        handleMoveFiles,
        handleRecycleBinDelete,
        handlePermanentDelete,
        handleRename,
        handleOpenPowerShell,
        handleHideFiles
    };
}; 


================================================
File: frontend/src/hooks/useContextMenus.js
================================================
import { useState, useCallback } from "preact/hooks";

export function useContextMenus(selectedFiles, allFiles, handleCopy, handleCut, showDialog, fileOperations, currentPath, onCreateFolder) {
    // Context menu states
    const [contextMenu, setContextMenu] = useState({ visible: false, x: 0, y: 0, files: [] });
    const [emptySpaceContextMenu, setEmptySpaceContextMenu] = useState({ visible: false, x: 0, y: 0 });

    // Context menu handlers
    const handleContextMenu = useCallback((event, file) => {
        const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
        
        const contextFiles = selectedFiles.size > 0 && selectedFileObjects.some(f => f.path === file.path) 
            ? selectedFileObjects 
            : [file];
        
        setContextMenu({
            visible: true,
            x: event.clientX,
            y: event.clientY,
            files: contextFiles
        });
    }, [selectedFiles, allFiles]);

    const closeContextMenu = useCallback(() => {
        setContextMenu({ visible: false, x: 0, y: 0, files: [] });
    }, []);

    const handleEmptySpaceContextMenu = useCallback((event) => {
        event.preventDefault();
        setEmptySpaceContextMenu({
            visible: true,
            x: event.clientX,
            y: event.clientY
        });
    }, []);

    const closeEmptySpaceContextMenu = useCallback(() => {
        setEmptySpaceContextMenu({ visible: false, x: 0, y: 0 });
    }, []);

    // Context menu actions
    const handleContextCopy = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        handleCopy(filePaths);
        closeContextMenu();
    }, [contextMenu.files, handleCopy, closeContextMenu]);

    const handleContextCut = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        handleCut(filePaths);
        closeContextMenu();
    }, [contextMenu.files, handleCut, closeContextMenu]);

    const handleContextRename = useCallback(() => {
        if (contextMenu.files.length !== 1) {
            closeContextMenu();
            return;
        }
        
        const file = contextMenu.files[0];
        closeContextMenu();
        
        showDialog(
            'prompt',
            'RENAME FILE',
            `RENAME "${file.name}" TO:`,
            file.name,
            (newName) => {
                if (newName && newName !== file.name && newName.trim() !== '') {
                    fileOperations.handleRename(file.path, newName.trim());
                }
            }
        );
    }, [contextMenu.files, closeContextMenu, showDialog, fileOperations]);

    const handleContextHide = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        closeContextMenu();
        
        showDialog(
            'confirm',
            'HIDE FILES',
            `HIDE ${filePaths.length} ITEM${filePaths.length === 1 ? '' : 'S'}?\n\nHidden files will not be visible unless "Show Hidden Files" is enabled.`,
            '',
            () => {
                fileOperations.handleHideFiles(filePaths);
            }
        );
    }, [contextMenu.files, closeContextMenu, showDialog, fileOperations]);

    const handlePermanentDelete = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        closeContextMenu();
        showDialog('delete', '⚠️ PERMANENT DELETE WARNING', `Permanently delete ${filePaths.length} items? This cannot be undone!`, '', 
            () => {
                fileOperations.handlePermanentDelete(filePaths);
            });
    }, [contextMenu.files, closeContextMenu, showDialog, fileOperations]);

    const handleOpenPowerShell = useCallback(() => {
        closeEmptySpaceContextMenu();
        fileOperations.handleOpenPowerShell();
    }, [closeEmptySpaceContextMenu, fileOperations]);

    const handleCreateFolder = useCallback(() => {
        closeEmptySpaceContextMenu();
        if (onCreateFolder) {
            onCreateFolder();
        }
    }, [closeEmptySpaceContextMenu, onCreateFolder]);

    return {
        contextMenu,
        emptySpaceContextMenu,
        handleContextMenu,
        closeContextMenu,
        handleEmptySpaceContextMenu,
        closeEmptySpaceContextMenu,
        handleContextCopy,
        handleContextCut,
        handleContextRename,
        handleContextHide,
        handlePermanentDelete,
        handleOpenPowerShell,
        handleCreateFolder
    };
} 

================================================
File: backend/terminal.go
================================================
package backend

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"runtime"
	"syscall"
	"unsafe"
)

var (
	shell32Terminal  = syscall.NewLazyDLL("shell32.dll")
	kernel32Terminal = syscall.NewLazyDLL("kernel32.dll")

	// Shell32 procedures for terminal operations
	shellExecuteW = shell32Terminal.NewProc("ShellExecuteW")

	// Constants for ShellExecuteW
	SW_SHOWNORMAL = 1
)

// NewTerminalManager creates a new terminal manager instance
func NewTerminalManager() *TerminalManager {
	return &TerminalManager{}
}

// OpenPowerShellHere opens PowerShell 7 in the specified directory using optimized methods
func (t *TerminalManager) OpenPowerShellHere(directoryPath string) bool {
	log.Printf("Opening PowerShell 7 in directory: %s", directoryPath)

	// Validate the directory path
	if directoryPath == "" {
		log.Printf("Error: Empty directory path provided")
		return false
	}

	// Check if directory exists
	if _, err := os.Stat(directoryPath); os.IsNotExist(err) {
		log.Printf("Error: Directory does not exist: %s", directoryPath)
		return false
	}

	if runtime.GOOS == "windows" {
		return t.openWindowsTerminalOptimized(directoryPath, "powershell")
	}

	return t.openWindowsTerminal(directoryPath)
}

// OpenTerminalHere opens the system's default terminal in the specified directory
func (t *TerminalManager) OpenTerminalHere(directoryPath string) bool {
	log.Printf("Opening terminal in directory: %s", directoryPath)

	// Validate the directory path
	if directoryPath == "" {
		log.Printf("Error: Empty directory path provided")
		return false
	}

	// Check if directory exists
	if _, err := os.Stat(directoryPath); os.IsNotExist(err) {
		log.Printf("Error: Directory does not exist: %s", directoryPath)
		return false
	}

	switch runtime.GOOS {
	case "windows":
		return t.openWindowsTerminalOptimized(directoryPath, "default")
	case "darwin":
		return t.openMacTerminal(directoryPath)
	case "linux":
		return t.openLinuxTerminal(directoryPath)
	default:
		log.Printf("Unsupported operating system: %s", runtime.GOOS)
		return false
	}
}

// openWindowsTerminalOptimized uses ShellExecuteW for better performance and reliability
func (t *TerminalManager) openWindowsTerminalOptimized(directoryPath string, terminalType string) bool {
	var executable string
	var parameters string

	switch terminalType {
	case "powershell":
		// Try PowerShell 7 first, fallback to Windows PowerShell
		pwshPath := "C:\\Program Files\\PowerShell\\7\\pwsh.exe"
		if _, err := os.Stat(pwshPath); err == nil {
			executable = pwshPath
		} else {
			executable = "powershell.exe"
		}
		parameters = "-NoExit"
	case "cmd":
		executable = "cmd.exe"
		parameters = "/K"
	case "wt":
		executable = "wt.exe"
		parameters = fmt.Sprintf("-d \"%s\"", directoryPath)
		directoryPath = "" // Don't set working directory since wt handles it
	default:
		// Default to PowerShell
		return t.openWindowsTerminalOptimized(directoryPath, "powershell")
	}

	log.Printf("Using ShellExecuteW to open: %s with params: %s in directory: %s", executable, parameters, directoryPath)

	// Convert strings to UTF16 pointers
	executableUTF16, err := syscall.UTF16PtrFromString(executable)
	if err != nil {
		log.Printf("Failed to convert executable to UTF16: %v", err)
		return t.openWindowsTerminalFallback(directoryPath, terminalType)
	}

	var parametersUTF16 *uint16
	if parameters != "" {
		parametersUTF16, err = syscall.UTF16PtrFromString(parameters)
		if err != nil {
			log.Printf("Failed to convert parameters to UTF16: %v", err)
			return t.openWindowsTerminalFallback(directoryPath, terminalType)
		}
	}

	var directoryUTF16 *uint16
	if directoryPath != "" {
		directoryUTF16, err = syscall.UTF16PtrFromString(directoryPath)
		if err != nil {
			log.Printf("Failed to convert directory to UTF16: %v", err)
			return t.openWindowsTerminalFallback(directoryPath, terminalType)
		}
	}

	// Call ShellExecuteW
	ret, _, err := shellExecuteW.Call(
		0, // hwnd (no parent window)
		0, // lpOperation (default "open")
		uintptr(unsafe.Pointer(executableUTF16)),
		uintptr(unsafe.Pointer(parametersUTF16)),
		uintptr(unsafe.Pointer(directoryUTF16)),
		uintptr(SW_SHOWNORMAL),
	)

	if ret <= 32 {
		log.Printf("ShellExecuteW failed with return code %d: %v", ret, err)
		return t.openWindowsTerminalFallback(directoryPath, terminalType)
	}

	log.Printf("Successfully opened terminal using ShellExecuteW")
	return true
}

// openWindowsTerminalFallback provides fallback using exec.Command
func (t *TerminalManager) openWindowsTerminalFallback(directoryPath string, terminalType string) bool {
	log.Printf("Using fallback method for terminal opening")

	switch terminalType {
	case "powershell":
		return t.openWindowsTerminal(directoryPath)
	case "cmd":
		return t.OpenCommandPromptHere(directoryPath)
	case "wt":
		return t.OpenWindowsTerminalApp(directoryPath)
	default:
		return t.openWindowsTerminal(directoryPath)
	}
}

// openWindowsTerminal opens PowerShell in Windows (original implementation for fallback)
func (t *TerminalManager) openWindowsTerminal(directoryPath string) bool {
	// PowerShell 7 executable path
	pwshPath := "C:\\Program Files\\PowerShell\\7\\pwsh.exe"

	// Check if PowerShell 7 exists, fallback to Windows PowerShell if not
	if _, err := os.Stat(pwshPath); os.IsNotExist(err) {
		log.Printf("PowerShell 7 not found, falling back to Windows PowerShell")
		pwshPath = "powershell.exe"
	}

	log.Printf("Using PowerShell executable: %s", pwshPath)

	// Use the most reliable method: -NoExit without -Command, just set working directory
	cmd := exec.Command(pwshPath, "-NoExit")

	// Set the working directory for the process - this is the key!
	cmd.Dir = directoryPath

	// Create new console window that stays open
	cmd.SysProcAttr = &syscall.SysProcAttr{
		HideWindow:    false,      // We want to show PowerShell window
		CreationFlags: 0x00000010, // CREATE_NEW_CONSOLE - create new console window
	}

	log.Printf("PowerShell command: %s %v in directory: %s", pwshPath, cmd.Args[1:], directoryPath)

	// Start the command
	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening PowerShell: %v", err)
		return false
	}

	log.Printf("Successfully opened PowerShell in directory: %s", directoryPath)
	return true
}

// openMacTerminal opens Terminal in macOS
func (t *TerminalManager) openMacTerminal(directoryPath string) bool {
	// macOS: Open Terminal with the specified directory
	cmd := exec.Command("osascript", "-e", fmt.Sprintf(`tell app "Terminal" to do script "cd '%s'"`, directoryPath))

	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening macOS Terminal: %v", err)
		return false
	}

	log.Printf("Successfully opened Terminal in directory: %s", directoryPath)
	return true
}

// openLinuxTerminal opens terminal in Linux
func (t *TerminalManager) openLinuxTerminal(directoryPath string) bool {
	// Linux: Try to open terminal in the directory
	// Try different terminal emulators in order of preference
	terminals := [][]string{
		{"gnome-terminal", "--working-directory", directoryPath},
		{"konsole", "--workdir", directoryPath},
		{"xfce4-terminal", "--working-directory", directoryPath},
		{"xterm", "-e", fmt.Sprintf("cd '%s' && bash", directoryPath)},
		{"urxvt", "-e", fmt.Sprintf("bash -c 'cd \"%s\" && bash'", directoryPath)},
		{"terminator", "--working-directory", directoryPath},
	}

	for _, terminalCmd := range terminals {
		if _, err := exec.LookPath(terminalCmd[0]); err == nil {
			cmd := exec.Command(terminalCmd[0], terminalCmd[1:]...)
			err := cmd.Start()
			if err == nil {
				log.Printf("Successfully opened %s in directory: %s", terminalCmd[0], directoryPath)
				return true
			}
			log.Printf("Failed to open %s: %v", terminalCmd[0], err)
		}
	}

	log.Printf("No suitable terminal emulator found")
	return false
}

// OpenCommandPromptHere opens Command Prompt in Windows (alternative to PowerShell)
func (t *TerminalManager) OpenCommandPromptHere(directoryPath string) bool {
	if runtime.GOOS != "windows" {
		log.Printf("Command Prompt is only available on Windows")
		return false
	}

	log.Printf("Opening Command Prompt in directory: %s", directoryPath)

	// Validate the directory path
	if directoryPath == "" {
		log.Printf("Error: Empty directory path provided")
		return false
	}

	// Check if directory exists
	if _, err := os.Stat(directoryPath); os.IsNotExist(err) {
		log.Printf("Error: Directory does not exist: %s", directoryPath)
		return false
	}

	// Try optimized method first
	if t.openWindowsTerminalOptimized(directoryPath, "cmd") {
		return true
	}

	// Fallback to original method
	cmd := exec.Command("cmd.exe", "/K", fmt.Sprintf("cd /d \"%s\"", directoryPath))

	// Create new console window
	cmd.SysProcAttr = &syscall.SysProcAttr{
		HideWindow:    false,
		CreationFlags: 0x00000010, // CREATE_NEW_CONSOLE
	}

	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening Command Prompt: %v", err)
		return false
	}

	log.Printf("Successfully opened Command Prompt in directory: %s", directoryPath)
	return true
}

// OpenWindowsTerminalApp opens Windows Terminal app (if available)
func (t *TerminalManager) OpenWindowsTerminalApp(directoryPath string) bool {
	if runtime.GOOS != "windows" {
		log.Printf("Windows Terminal is only available on Windows")
		return false
	}

	log.Printf("Opening Windows Terminal app in directory: %s", directoryPath)

	// Try optimized method first
	if t.openWindowsTerminalOptimized(directoryPath, "wt") {
		return true
	}

	// Fallback to original method
	cmd := exec.Command("wt.exe", "-d", directoryPath)

	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening Windows Terminal: %v", err)
		// Fallback to PowerShell
		log.Printf("Falling back to PowerShell")
		return t.OpenPowerShellHere(directoryPath)
	}

	log.Printf("Successfully opened Windows Terminal in directory: %s", directoryPath)
	return true
}

// GetAvailableTerminals returns a list of available terminal applications
func (t *TerminalManager) GetAvailableTerminals() []string {
	var terminals []string

	switch runtime.GOOS {
	case "windows":
		// Check for available Windows terminals
		terminalPaths := []struct {
			path string
			name string
		}{
			{"C:\\Program Files\\PowerShell\\7\\pwsh.exe", "PowerShell 7"},
			{"powershell.exe", "Windows PowerShell"},
			{"cmd.exe", "Command Prompt"},
			{"wt.exe", "Windows Terminal"},
		}

		for _, term := range terminalPaths {
			if term.name == "Windows Terminal" {
				// Special check for Windows Terminal
				if _, err := exec.LookPath("wt.exe"); err == nil {
					terminals = append(terminals, term.name)
				}
			} else if _, err := os.Stat(term.path); err == nil || term.name == "Windows PowerShell" || term.name == "Command Prompt" {
				terminals = append(terminals, term.name)
			}
		}

	case "darwin":
		terminals = append(terminals, "Terminal", "iTerm2")

	case "linux":
		// Check for common Linux terminals
		linuxTerminals := []string{
			"gnome-terminal", "konsole", "xfce4-terminal",
			"xterm", "urxvt", "terminator", "alacritty", "kitty",
		}

		for _, term := range linuxTerminals {
			if _, err := exec.LookPath(term); err == nil {
				terminals = append(terminals, term)
			}
		}
	}

	return terminals
}

// ExecuteCommand executes a command in the specified working directory
func (t *TerminalManager) ExecuteCommand(command string, workingDir string) error {
	log.Printf("Executing command: %s in directory: %s", command, workingDir)

	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "windows":
		cmd = exec.Command("cmd", "/C", command)
	default:
		cmd = exec.Command("sh", "-c", command)
	}

	if workingDir != "" {
		cmd.Dir = workingDir
	}

	// Hide window for background execution
	if runtime.GOOS == "windows" {
		cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}
	}

	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("Command execution failed: %v, output: %s", err, string(output))
		return err
	}

	log.Printf("Command executed successfully, output: %s", string(output))
	return nil
}


================================================
File: frontend/src/hooks/usePerformanceMonitoring.js
================================================
import { useState } from "preact/hooks";

export function usePerformanceMonitoring() {
    const [navigationStats, setNavigationStats] = useState({
        totalNavigations: 0,
        averageTime: 0,
        lastNavigationTime: 0
    });

    return {
        navigationStats,
        setNavigationStats
    };
} 

================================================
File: frontend/src/main.jsx
================================================
import {render} from 'preact';
import {App} from './app';
import './style.css';

render(<App/>, document.getElementById('app'));

================================================
File: frontend/src/hooks/useFolderCreation.js
================================================
import { useState, useCallback, useRef } from "preact/hooks";
import { CreateDirectory } from "../../wailsjs/go/backend/App";
import { log, error } from "../utils/logger";

export function useFolderCreation(currentPath, onRefresh, setError) {
    const [creatingFolder, setCreatingFolder] = useState(false);
    const [tempFolderName, setTempFolderName] = useState("New folder");
    const editInputRef = useRef(null);

    const startFolderCreation = useCallback(() => {
        if (!currentPath) return;
        
        setCreatingFolder(true);
        setTempFolderName("New folder");
        
        // Focus the input in the next tick
        setTimeout(() => {
            if (editInputRef.current) {
                editInputRef.current.focus();
                editInputRef.current.select();
            }
        }, 100);
    }, [currentPath]);

    const cancelFolderCreation = useCallback(() => {
        setCreatingFolder(false);
        setTempFolderName("New folder");
    }, []);

    const confirmFolderCreation = useCallback(async () => {
        if (!currentPath || !tempFolderName.trim()) {
            cancelFolderCreation();
            return;
        }

        const folderName = tempFolderName.trim();
        
        try {
            log(`📁 Creating folder: "${folderName}" in ${currentPath}`);
            
            const response = await CreateDirectory(currentPath, folderName);
            
            if (response && response.success) {
                log(`✅ Folder created successfully: ${folderName}`);
                
                // Refresh directory to show the new folder
                onRefresh();
                
                setCreatingFolder(false);
                setTempFolderName("New folder");
            } else {
                const errorMsg = response?.message || 'Failed to create folder';
                error('❌ Folder creation failed:', errorMsg);
                setError(`Failed to create folder: ${errorMsg}`);
                cancelFolderCreation();
            }
        } catch (err) {
            error('❌ Error creating folder:', err);
            setError(`Error creating folder: ${err.message}`);
            cancelFolderCreation();
        }
    }, [currentPath, tempFolderName, onRefresh, setError, cancelFolderCreation]);

    const handleKeyDown = useCallback((e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            confirmFolderCreation();
        } else if (e.key === 'Escape') {
            e.preventDefault();
            cancelFolderCreation();
        }
    }, [confirmFolderCreation, cancelFolderCreation]);

    const handleInputChange = useCallback((e) => {
        setTempFolderName(e.target.value);
    }, []);

    const handleInputBlur = useCallback(() => {
        // Delay to allow for clicks on other elements
        setTimeout(() => {
            if (creatingFolder) {
                confirmFolderCreation();
            }
        }, 100);
    }, [creatingFolder, confirmFolderCreation]);

    return {
        creatingFolder,
        tempFolderName,
        editInputRef,
        startFolderCreation,
        cancelFolderCreation,
        confirmFolderCreation,
        handleKeyDown,
        handleInputChange,
        handleInputBlur
    };
} 

================================================
File: frontend/src/components/VirtualizedFileList.jsx
================================================
import { useState, useEffect, useCallback, useMemo, useRef, useLayoutEffect } from "preact/hooks";
import { memo } from "preact/compat";
import { FileItem } from "./FileItem";
import { InlineFolderEditor } from "./InlineFolderEditor";
import { rafThrottle } from "../utils/debounce";
import { log } from "../utils/logger";
import { 
    EMPTY_DIRECTORY_STYLE, 
    LARGE_ICON_STYLE,
    FLEX_COLUMN_STYLE,
    FLEX_CENTER_STYLE
} from "../utils/styleConstants";

// Virtual scrolling configuration  
const ITEM_HEIGHT = 64; // Height of each file item in pixels (3.5rem + 1rem padding = 72px, but actual rendered is smaller)
const BUFFER_SIZE = 5; // Number of items to render outside visible area
const CONTAINER_HEIGHT = 400; // Default container height

// Pre-compiled styles for optimal performance
const CONTAINER_STYLE = {
    overflowY: 'auto',
    overflowX: 'hidden',
    position: 'relative'
};

const VIRTUAL_CONTAINER_STYLE = {
    position: 'relative'
};

const VIRTUAL_ITEM_STYLE_BASE = {
    position: 'absolute',
    left: 0,
    right: 0,
    height: ITEM_HEIGHT
};

const EMPTY_STATE_CONTAINER_STYLE = {
    ...FLEX_COLUMN_STYLE,
    ...FLEX_CENTER_STYLE,
    height: '100%',
    color: 'var(--blueprint-text-muted)'
};

const VirtualizedFileList = memo(({ 
    files, 
    selectedFiles,
    onFileSelect,
    onFileOpen,
    onContextMenu,
    isLoading,
    clipboardFiles,
    clipboardOperation,
    containerHeight,
    dragState,
    onDragStart,
    onDragOver,
    onDragEnter,
    onDragLeave,
    onDrop,
    // Folder creation props
    creatingFolder,
    tempFolderName,
    editInputRef,
    onFolderKeyDown,
    onFolderInputChange,
    onFolderInputBlur,
    // Empty space context menu props
    onEmptySpaceContextMenu,

}) => {
    const [scrollTop, setScrollTop] = useState(0);
    const [measuredHeight, setMeasuredHeight] = useState(CONTAINER_HEIGHT);
    const containerRef = useRef(null);
    
    // Measure container height once with useLayoutEffect
    useLayoutEffect(() => {
        if (containerRef.current) {
            const height = containerRef.current.clientHeight;
            if (height !== measuredHeight) {
                setMeasuredHeight(height);
                log('📏 VirtualizedFileList: Measured container height:', height);
            }
        }
    }, [measuredHeight]);
    
    // Calculate visible range - memoized for performance
    const visibleRange = useMemo(() => {
        const effectiveHeight = containerHeight || measuredHeight;
        const visibleStart = Math.floor(scrollTop / ITEM_HEIGHT);
        const visibleEnd = Math.min(
            files.length - 1,
            Math.ceil((scrollTop + effectiveHeight) / ITEM_HEIGHT)
        );
        
        // Add buffer for smooth scrolling
        const startIndex = Math.max(0, visibleStart - BUFFER_SIZE);
        const endIndex = Math.min(files.length - 1, visibleEnd + BUFFER_SIZE);
        
        return { startIndex, endIndex, visibleStart, visibleEnd };
    }, [scrollTop, containerHeight, measuredHeight, files.length]);
    
    // Get visible items - simplified to match normal list structure
    const visibleItems = useMemo(() => {
        const { startIndex, endIndex } = visibleRange;
        return files.slice(startIndex, endIndex + 1).map((file, index) => ({
            file,
            index: startIndex + index
        }));
    }, [files, visibleRange]);
    
    // RAF-throttled scroll handler for smooth performance
    const handleScroll = useCallback(rafThrottle((event) => {
        // Use requestAnimationFrame to batch layout reads
        requestAnimationFrame(() => {
            const newScrollTop = event.target.scrollTop;
            setScrollTop(newScrollTop);
        });
    }), []);
    
    // Scroll to item (for keyboard navigation) - optimized with measured height
    const scrollToItem = useCallback((index) => {
        if (containerRef.current) {
            const effectiveHeight = containerHeight || measuredHeight;
            const targetScrollTop = index * ITEM_HEIGHT;
            const containerScrollTop = containerRef.current.scrollTop;
            const containerBottom = containerScrollTop + effectiveHeight;
            
            // Only scroll if item is not visible
            if (targetScrollTop < containerScrollTop) {
                containerRef.current.scrollTop = targetScrollTop;
            } else if (targetScrollTop + ITEM_HEIGHT > containerBottom) {
                containerRef.current.scrollTop = targetScrollTop - effectiveHeight + ITEM_HEIGHT;
            }
        }
    }, [containerHeight, measuredHeight]);
    
    // For now, let's disable virtual scrolling height calculation and use natural flow
    // const totalHeight = (files.length + (creatingFolder ? 1 : 0)) * ITEM_HEIGHT;
    
        // Optimize file item click handlers - Fixed to prevent double-opens
    const handleFileClick = useCallback((fileIndex, event) => {
        // Always handle selection for virtualized list - FileItem will handle opening logic
        onFileSelect(fileIndex, event.shiftKey, event.ctrlKey);
        
        // Scroll to item if needed
        if (event.shiftKey || event.ctrlKey) {
            scrollToItem(fileIndex);
        }
    }, [onFileSelect, scrollToItem]);

    const handleFileDoubleClick = useCallback((file) => {
        onFileOpen(file);
    }, [onFileOpen]);
    
    const handleFileContextMenu = useCallback((event, file) => {
        onContextMenu(event, file);
    }, [onContextMenu]);
    
    // Compute container style once
    const containerStyle = useMemo(() => ({
        ...CONTAINER_STYLE,
        height: containerHeight || '100%'
    }), [containerHeight]);
    
    // Remove virtual container positioning for now
    // const virtualContainerStyle = useMemo(() => ({
    //     ...VIRTUAL_CONTAINER_STYLE,
    //     height: totalHeight
    // }), [totalHeight]);

    return (
        <div 
            ref={containerRef}
            className="file-list custom-scrollbar"
            style={containerStyle}
            onScroll={handleScroll}
            onContextMenu={(e) => {
                // Check if right-clicking on empty space in virtual list
                if (e.target === e.currentTarget || !e.target.closest('.file-item')) {
                    e.preventDefault();
                    if (onEmptySpaceContextMenu) {
                        onEmptySpaceContextMenu(e);
                    }
                }
            }}
        >
            {/* Show inline folder editor if creating folder */}
            {creatingFolder && (
                <InlineFolderEditor
                    tempFolderName={tempFolderName}
                    editInputRef={editInputRef}
                    onKeyDown={onFolderKeyDown}
                    onChange={onFolderInputChange}
                    onBlur={onFolderInputBlur}
                />
            )}
            
            {/* Render only visible items - same structure as normal list */}
            {visibleItems.map(({ file, index }) => (
                <FileItem
                    key={`${file.path}-${index}`}
                    file={file}
                    fileIndex={index}
                    onSelect={handleFileClick}
                    onOpen={handleFileDoubleClick}
                    onContextMenu={handleFileContextMenu}
                    isLoading={isLoading}
                    isSelected={selectedFiles.has(index)}
                    isCut={clipboardOperation === 'cut' && clipboardFiles.includes(file.path)}
                    isDragOver={dragState?.dragOverFolder === file.path}
                    onDragStart={onDragStart}
                    onDragOver={onDragOver}
                    onDragEnter={onDragEnter}
                    onDragLeave={onDragLeave}
                    onDrop={onDrop}
                />
            ))}
            
            {/* Empty state */}
            {files.length === 0 && !creatingFolder && (
                <div style={EMPTY_STATE_CONTAINER_STYLE}>
                    <div style={LARGE_ICON_STYLE}>📁</div>
                    <div className="text-technical">Directory is empty</div>
                </div>
            )}
        </div>
    );
});

export { VirtualizedFileList }; 

================================================
File: frontend/src/utils/debounce.js
================================================
// Debounce utility to prevent excessive function calls
export function debounce(func, wait, immediate = false) {
    let timeout;
    
    return function executedFunction(...args) {
        const later = () => {
            timeout = null;
            if (!immediate) func.apply(this, args);
        };
        
        const callNow = immediate && !timeout;
        
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        
        if (callNow) func.apply(this, args);
    };
}

// Enhanced throttle utility for high-frequency events
export function throttle(func, limit) {
    let inThrottle;
    
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// RAF-based throttle for smooth animations and scroll handling
export function rafThrottle(func) {
    let rafId = null;
    let lastArgs = null;
    
    return function(...args) {
        lastArgs = args;
        
        if (rafId === null) {
            rafId = requestAnimationFrame(() => {
                func.apply(this, lastArgs);
                rafId = null;
            });
        }
    };
}

// RequestIdleCallback wrapper with fallback
export function idleCallback(func, options = {}) {
    if (typeof requestIdleCallback !== 'undefined') {
        return requestIdleCallback(func, options);
    } else {
        // Fallback for browsers without requestIdleCallback
        return setTimeout(func, 1);
    }
}

// Batch DOM reads to avoid layout thrashing
export function batchReads(readFunctions) {
    return new Promise(resolve => {
        requestAnimationFrame(() => {
            const results = readFunctions.map(fn => fn());
            resolve(results);
        });
    });
}

// Batch DOM writes to optimize rendering
export function batchWrites(writeFunctions) {
    requestAnimationFrame(() => {
        writeFunctions.forEach(fn => fn());
    });
}

// Specialized debounce for navigation operations (super fast)
export const debouncedNavigate = debounce((navigateFunc, path) => {
    navigateFunc(path);
}, 50); // Much faster for responsive navigation

// Specialized RAF throttle for scroll events (smoother than timer-based)
export const rafThrottledScroll = rafThrottle((scrollFunc, event) => {
    scrollFunc(event);
});

// Legacy throttle for scroll events (keeping for compatibility)
export const throttledScroll = throttle((scrollFunc, event) => {
    scrollFunc(event);
}, 16); // ~60fps

// Specialized debounce for file operations
export const debouncedFileOperation = debounce((operationFunc, ...args) => {
    operationFunc(...args);
}, 75); // Slightly faster for better responsiveness 

================================================
File: frontend/src/hooks/useKeyboardShortcuts.js
================================================
import { useEffect, useMemo } from "preact/hooks";
import { throttle } from "../utils/debounce";

export function useKeyboardShortcuts({
    handleRefresh,
    handleNavigateUp,
    selectedFiles,
    allFiles,
    handleFileOpen,
    selectAll,
    handleCopySelected,
    handleCutSelected,
    handlePaste,
    isPasteAvailable,
    handleArrowNavigation,
    clearSelection,
    closeContextMenu,
    closeEmptySpaceContextMenu
}) {
    // Optimized keyboard shortcuts
    const keyboardHandler = useMemo(
        () => throttle((event) => {
            if (event.key === 'F5') {
                event.preventDefault();
                handleRefresh();
            } else if (event.key === 'Backspace' && !event.target.matches('input, textarea')) {
                event.preventDefault();
                handleNavigateUp();
            } else if (event.key === 'Enter' && selectedFiles.size > 0) {
                event.preventDefault();
                const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
                selectedFileObjects.forEach(file => handleFileOpen(file));
            } else if (event.ctrlKey && event.key === 'a' && !event.target.matches('input, textarea')) {
                event.preventDefault();
                selectAll(allFiles.length);
            } else if (event.ctrlKey && event.key === 'c' && selectedFiles.size > 0) {
                event.preventDefault();
                handleCopySelected();
            } else if (event.ctrlKey && event.key === 'x' && selectedFiles.size > 0) {
                event.preventDefault();
                handleCutSelected();
            } else if (event.ctrlKey && event.key === 'v' && isPasteAvailable()) {
                event.preventDefault();
                handlePaste();
            } else if (event.key === 'ArrowUp' && !event.target.matches('input, textarea')) {
                event.preventDefault();
                handleArrowNavigation('up', allFiles);
            } else if (event.key === 'ArrowDown' && !event.target.matches('input, textarea')) {
                event.preventDefault();
                handleArrowNavigation('down', allFiles);
            } else if (event.key === 'Escape') {
                clearSelection();
                closeContextMenu();
                closeEmptySpaceContextMenu();
            }
        }, 50), // Faster response for keyboard
        [
            handleRefresh, 
            handleNavigateUp, 
            selectedFiles, 
            allFiles, 
            handleFileOpen, 
            selectAll, 
            handleCopySelected, 
            handleCutSelected, 
            handlePaste, 
            isPasteAvailable, 
            handleArrowNavigation, 
            clearSelection, 
            closeContextMenu, 
            closeEmptySpaceContextMenu
        ]
    );

    // Keyboard shortcuts
    useEffect(() => {
        window.addEventListener('keydown', keyboardHandler);
        return () => window.removeEventListener('keydown', keyboardHandler);
    }, [keyboardHandler]);
} 

================================================
File: backend/events.go
================================================
package backend

import (
	"context"
	"log"

	"github.com/wailsapp/wails/v2/pkg/runtime"
)

// EventEmitter handles Wails runtime events
type EventEmitter struct {
	ctx context.Context
}

// NewEventEmitter creates a new event emitter
func NewEventEmitter(ctx context.Context) *EventEmitter {
	return &EventEmitter{ctx: ctx}
}

// EmitDirectoryHydrate emits a directory hydration event to the frontend
func (e *EventEmitter) EmitDirectoryHydrate(fileInfo FileInfo) {
	if e.ctx != nil {
		runtime.EventsEmit(e.ctx, "DirectoryHydrate", fileInfo)
		log.Printf("📡 Emitted hydration event for: %s", fileInfo.Name)
	}
}

// EmitDirectoryBatch emits a batch of directory entries to the frontend
func (e *EventEmitter) EmitDirectoryBatch(entries []FileInfo) {
	if e.ctx != nil {
		runtime.EventsEmit(e.ctx, "DirectoryBatch", entries)
		log.Printf("📡 Emitted batch of %d entries", len(entries))
	}
}

// EmitDirectoryComplete signals that directory loading is complete
func (e *EventEmitter) EmitDirectoryComplete(path string, totalFiles, totalDirs int) {
	if e.ctx != nil {
		runtime.EventsEmit(e.ctx, "DirectoryComplete", map[string]interface{}{
			"path":       path,
			"totalFiles": totalFiles,
			"totalDirs":  totalDirs,
		})
		log.Printf("📡 Emitted directory complete for: %s (%d files, %d dirs)", path, totalFiles, totalDirs)
	}
}


================================================
File: frontend/src/hooks/useDragAndDrop.js
================================================
import { useState, useCallback, useRef } from "preact/hooks";
import { CopyFiles, MoveFiles } from "../../wailsjs/go/backend/App";

export const useDragAndDrop = (currentPath, selectedFiles, allFiles, setError, clearSelection, handleRefresh) => {
    const [dragState, setDragState] = useState({
        isDragging: false,
        draggedFiles: [],
        draggedPaths: [],
        dragOperation: 'move', // 'move' or 'copy'
        dragOverFolder: null,
        dragStartPosition: { x: 0, y: 0 }
    });

    const dragPreviewRef = useRef(null);
    const dragTimeoutRef = useRef(null);

    // Start drag operation
    const handleDragStart = useCallback((event, file) => {
        console.log('🎯 Drag started for:', file.name);

        // Get all selected files or just the dragged file
        let draggedFiles = [];
        let draggedPaths = [];

        if (selectedFiles.has(allFiles.findIndex(f => f.path === file.path))) {
            // Dragging selected files
            draggedFiles = Array.from(selectedFiles).map(index => allFiles[index]);
        } else {
            // Dragging unselected file
            draggedFiles = [file];
        }

        draggedPaths = draggedFiles.map(f => f.path);

        // Set drag operation based on modifier keys
        const operation = event.ctrlKey ? 'copy' : 'move';

        // Create drag data
        const dragData = {
            files: draggedPaths,
            operation: operation,
            source: currentPath,
            fileNames: draggedFiles.map(f => f.name)
        };

        // Set drag effect
        event.dataTransfer.effectAllowed = event.ctrlKey ? 'copy' : 'move';
        event.dataTransfer.setData('application/json', JSON.stringify(dragData));
        event.dataTransfer.setData('text/plain', draggedFiles.map(f => f.name).join(', '));

        // Create custom drag preview
        const dragPreview = createDragPreview(draggedFiles, operation);
        if (dragPreview) {
            document.body.appendChild(dragPreview);
            event.dataTransfer.setDragImage(dragPreview, 20, 20);
            dragPreviewRef.current = dragPreview;
        }

        // Update drag state
        setDragState({
            isDragging: true,
            draggedFiles,
            draggedPaths,
            dragOperation: operation,
            dragOverFolder: null,
            dragStartPosition: { x: event.clientX, y: event.clientY }
        });

        console.log(`🎯 Dragging ${draggedFiles.length} items with operation: ${operation}`);
    }, [currentPath, selectedFiles, allFiles]);

    // Handle drag over folder
    const handleDragOver = useCallback((event, targetFolder) => {
        if (!dragState.isDragging || !targetFolder.isDir) return;

        event.preventDefault();
        
        // Update drop effect based on current modifier keys
        const operation = event.ctrlKey ? 'copy' : 'move';
        event.dataTransfer.dropEffect = operation;

        // Update drag operation if it changed
        if (operation !== dragState.dragOperation) {
            setDragState(prev => ({ ...prev, dragOperation: operation }));
        }

        // Set visual feedback for drop target
        if (dragState.dragOverFolder !== targetFolder.path) {
            setDragState(prev => ({ ...prev, dragOverFolder: targetFolder.path }));
        }
    }, [dragState.isDragging, dragState.dragOperation, dragState.dragOverFolder]);

    // Handle drag enter
    const handleDragEnter = useCallback((event, targetFolder) => {
        if (!targetFolder.isDir) return;
        
        event.preventDefault();
        
        // Clear any existing timeout
        if (dragTimeoutRef.current) {
            clearTimeout(dragTimeoutRef.current);
            dragTimeoutRef.current = null;
        }

        setDragState(prev => ({ ...prev, dragOverFolder: targetFolder.path }));
    }, []);

    // Handle drag leave
    const handleDragLeave = useCallback((event, targetFolder) => {
        if (!targetFolder.isDir) return;

        // Add small delay to prevent flicker when moving between child elements
        dragTimeoutRef.current = setTimeout(() => {
            const rect = event.currentTarget.getBoundingClientRect();
            const x = event.clientX;
            const y = event.clientY;

            // Only clear if we're actually outside the element
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                setDragState(prev => ({ 
                    ...prev, 
                    dragOverFolder: prev.dragOverFolder === targetFolder.path ? null : prev.dragOverFolder 
                }));
            }
        }, 100);
    }, []);

    // Handle drop operation
    const handleDrop = useCallback(async (event, targetFolder, dragData) => {
        event.preventDefault();
        
        if (!targetFolder.isDir) {
            console.warn('⚠️ Cannot drop on non-directory:', targetFolder.name);
            return;
        }

        const { files: sourcePaths, operation, source } = dragData;
        
        // Prevent dropping on itself or into same directory
        if (source === targetFolder.path) {
            console.log('ℹ️ Dropping in same directory, ignoring');
            return;
        }

        // Prevent dropping a folder into itself or its subdirectories
        const isInvalidDrop = sourcePaths.some(srcPath => {
            return targetFolder.path.startsWith(srcPath + '/') || targetFolder.path.startsWith(srcPath + '\\') || targetFolder.path === srcPath;
        });

        if (isInvalidDrop) {
            setError('Cannot move or copy a folder into itself or its subdirectories');
            return;
        }

        try {
            console.log(`🎯 Dropping ${sourcePaths.length} items into:`, targetFolder.path);
            console.log(`📋 Operation: ${operation}`);

            let success = false;

            if (operation === 'copy') {
                success = await CopyFiles(sourcePaths, targetFolder.path);
            } else {
                success = await MoveFiles(sourcePaths, targetFolder.path);
            }

            if (success) {
                console.log(`✅ ${operation} operation successful`);
                
                // If we moved files, clear selection
                if (operation === 'move') {
                    clearSelection();
                }
                
                // Refresh current directory
                setTimeout(() => {
                    handleRefresh();
                }, 100);
                
            } else {
                setError(`Failed to ${operation} files to "${targetFolder.name}"`);
            }

        } catch (err) {
            console.error(`❌ Error during ${operation} operation:`, err);
            setError(`Failed to ${operation} files: ${err.message}`);
        }
    }, [setError, clearSelection, handleRefresh]);

    // Handle drag end
    const handleDragEnd = useCallback(() => {
        console.log('🎯 Drag operation ended');

        // Clean up drag preview
        if (dragPreviewRef.current) {
            document.body.removeChild(dragPreviewRef.current);
            dragPreviewRef.current = null;
        }

        // Clear timeout
        if (dragTimeoutRef.current) {
            clearTimeout(dragTimeoutRef.current);
            dragTimeoutRef.current = null;
        }

        // Reset drag state
        setDragState({
            isDragging: false,
            draggedFiles: [],
            draggedPaths: [],
            dragOperation: 'move',
            dragOverFolder: null,
            dragStartPosition: { x: 0, y: 0 }
        });
    }, []);

    // Create custom drag preview
    const createDragPreview = (files, operation) => {
        const preview = document.createElement('div');
        preview.style.cssText = `
            position: absolute;
            top: -1000px;
            left: -1000px;
            background: var(--blueprint-surface);
            border: 1px solid var(--blueprint-border);
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            color: var(--blueprint-text);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 300px;
        `;

        const icon = operation === 'copy' ? '📄' : '🔄';
        const action = operation === 'copy' ? 'Copy' : 'Move';
        
        if (files.length === 1) {
            preview.innerHTML = `${icon} ${action} "${files[0].name}"`;
        } else {
            preview.innerHTML = `${icon} ${action} ${files.length} items`;
        }

        return preview;
    };

    return {
        dragState,
        handleDragStart,
        handleDragOver,
        handleDragEnter,
        handleDragLeave,
        handleDrop,
        handleDragEnd
    };
};

export default useDragAndDrop; 

================================================
File: frontend/src/utils/logger.js
================================================
// Logger utility to gate console logging in production
export const debug = process.env.NODE_ENV !== 'production';

export const log = (...args) => { 
    if (debug) console.log(...args); 
};

export const warn = (...args) => { 
    if (debug) console.warn(...args); 
};

export const error = (...args) => { 
    if (debug) console.error(...args); 
};

export const time = (label) => { 
    if (debug) console.time(label); 
};

export const timeEnd = (label) => { 
    if (debug) console.timeEnd(label); 
};

export const group = (label) => { 
    if (debug) console.group(label); 
};

export const groupEnd = () => { 
    if (debug) console.groupEnd(); 
}; 

================================================
File: frontend/src/hooks/useSelection.js
================================================
import { useState, useCallback } from "preact/hooks";
import { log } from "../utils/logger";

export const useSelection = () => {
    const [selectedFiles, setSelectedFiles] = useState(new Set());
    const [lastSelectedIndex, setLastSelectedIndex] = useState(-1);

    const handleFileSelect = useCallback((fileIndex, isShiftKey, isCtrlKey) => {
        log('📋 File selection:', fileIndex, 'Shift:', isShiftKey, 'Ctrl:', isCtrlKey);
        
        setSelectedFiles(prevSelected => {
            const newSelected = new Set(prevSelected);
            
            if (isShiftKey && lastSelectedIndex !== -1) {
                // Range selection
                const start = Math.min(lastSelectedIndex, fileIndex);
                const end = Math.max(lastSelectedIndex, fileIndex);
                
                for (let i = start; i <= end; i++) {
                    newSelected.add(i);
                }
            } else if (isCtrlKey) {
                // Toggle selection
                if (newSelected.has(fileIndex)) {
                    newSelected.delete(fileIndex);
                } else {
                    newSelected.add(fileIndex);
                }
            } else {
                // Single selection
                newSelected.clear();
                newSelected.add(fileIndex);
            }
            
            return newSelected;
        });
        
        setLastSelectedIndex(fileIndex);
    }, [lastSelectedIndex]);

    const clearSelection = useCallback(() => {
        setSelectedFiles(new Set());
        setLastSelectedIndex(-1);
        log('📋 Cleared selection');
    }, []);

    const selectAll = useCallback((totalFiles) => {
        const allIndices = new Set();
        for (let i = 0; i < totalFiles; i++) {
            allIndices.add(i);
        }
        setSelectedFiles(allIndices);
        log('📋 Selected all files:', allIndices.size);
    }, []);

    const handleArrowNavigation = useCallback((direction, allFiles) => {
        if (allFiles.length === 0) return;
        
        let targetIndex;
        
        if (selectedFiles.size === 1) {
            // Move from current selection
            const currentIndex = Array.from(selectedFiles)[0];
            
            if (direction === 'up') {
                targetIndex = currentIndex > 0 ? currentIndex - 1 : allFiles.length - 1; // Wrap to bottom
            } else {
                targetIndex = currentIndex < allFiles.length - 1 ? currentIndex + 1 : 0; // Wrap to top
            }
        } else {
            // No selection or multiple selections - select first/last item
            if (direction === 'up') {
                targetIndex = allFiles.length - 1; // Select last item
            } else {
                targetIndex = 0; // Select first item
            }
        }
        
        log(`⬆️⬇️ Arrow navigation ${direction}: moving to index ${targetIndex} (${allFiles[targetIndex]?.name})`);
        
        // Select the target file
        setSelectedFiles(new Set([targetIndex]));
        setLastSelectedIndex(targetIndex);
        
        return targetIndex;
    }, [selectedFiles]);

    return {
        selectedFiles,
        lastSelectedIndex,
        handleFileSelect,
        clearSelection,
        selectAll,
        handleArrowNavigation
    };
}; 

================================================
File: frontend/src/utils/fileUtils.js
================================================
// Optimized file type detection using pre-compiled maps
import { 
    SPECIFIC_FILE_MAP, 
    EXTENSION_TYPE_MAP, 
    DEFAULT_FILE_TYPE,
    SPECIAL_FOLDER_MAP, 
    TYPE_ICON_MAP, 
    DEFAULT_FILE_ICON, 
    DEFAULT_FOLDER_ICON 
} from './fileTypeMaps.js';

export const getFileType = (fileName, isDir) => {
    if (isDir) return 'folder';
    
    const baseName = fileName.toLowerCase();
    
    // Check specific file mappings first (highest priority)
    if (SPECIFIC_FILE_MAP[baseName]) return SPECIFIC_FILE_MAP[baseName];
    
    // Check extension mappings
    const ext = fileName.split('.').pop()?.toLowerCase();
    return EXTENSION_TYPE_MAP[ext] || DEFAULT_FILE_TYPE;
};

export const getFileIcon = (fileName, isDir) => {
    if (isDir) {
        const folderName = fileName.toLowerCase();
        return SPECIAL_FOLDER_MAP[folderName] || DEFAULT_FOLDER_ICON;
    }
    
    const type = getFileType(fileName, false);
    return TYPE_ICON_MAP[type] || DEFAULT_FILE_ICON;
};

// Filter function for hidden and system files
export const filterFiles = (files, showHiddenFiles) => {
    if (!files) return [];
    if (showHiddenFiles) return files;
    
    return files.filter(file => {
        // Most important: Check the isHidden property from the backend
        if (file.isHidden) return false;
        
        // Hide files that start with . (hidden files) - redundant but kept for safety
        if (file.name.startsWith('.')) return false;
        
        // Hide common Windows system files
        const systemFiles = [
            'NTUSER.DAT', 'ntuser.dat.LOG1', 'ntuser.dat.LOG2', 'ntuser.ini',
            'Application Data', 'Cookies', 'Local Settings', 'My Documents',
            'NetHood', 'PrintHood', 'Recent', 'SendTo', 'Start Menu', 'Templates'
        ];
        
        if (systemFiles.includes(file.name)) return false;
        
        // Hide files with system file extensions and patterns
        const hiddenPatterns = [
            /^NTUSER\.DAT/i,
            /\.TM\.blf$/i,
            /\.TMContainer.*\.regtrans-ms$/i,
            /^thumbs\.db$/i,
            /^desktop\.ini$/i
        ];
        
        return !hiddenPatterns.some(pattern => pattern.test(file.name));
    });
}; 

================================================
File: frontend/wailsjs/go/models.ts
================================================
export namespace backend {
	
	export class FileInfo {
	    name: string;
	    path: string;
	    isDir: boolean;
	    size: number;
	    // Go type: time
	    modTime: any;
	    permissions: string;
	    extension: string;
	    isHidden: boolean;
	
	    static createFrom(source: any = {}) {
	        return new FileInfo(source);
	    }
	
	    constructor(source: any = {}) {
	        if ('string' === typeof source) source = JSON.parse(source);
	        this.name = source["name"];
	        this.path = source["path"];
	        this.isDir = source["isDir"];
	        this.size = source["size"];
	        this.modTime = this.convertValues(source["modTime"], null);
	        this.permissions = source["permissions"];
	        this.extension = source["extension"];
	        this.isHidden = source["isHidden"];
	    }
	
		convertValues(a: any, classs: any, asMap: boolean = false): any {
		    if (!a) {
		        return a;
		    }
		    if (a.slice && a.map) {
		        return (a as any[]).map(elem => this.convertValues(elem, classs));
		    } else if ("object" === typeof a) {
		        if (asMap) {
		            for (const key of Object.keys(a)) {
		                a[key] = new classs(a[key]);
		            }
		            return a;
		        }
		        return new classs(a);
		    }
		    return a;
		}
	}
	export class DirectoryContents {
	    currentPath: string;
	    parentPath: string;
	    files: FileInfo[];
	    directories: FileInfo[];
	    totalFiles: number;
	    totalDirs: number;
	
	    static createFrom(source: any = {}) {
	        return new DirectoryContents(source);
	    }
	
	    constructor(source: any = {}) {
	        if ('string' === typeof source) source = JSON.parse(source);
	        this.currentPath = source["currentPath"];
	        this.parentPath = source["parentPath"];
	        this.files = this.convertValues(source["files"], FileInfo);
	        this.directories = this.convertValues(source["directories"], FileInfo);
	        this.totalFiles = source["totalFiles"];
	        this.totalDirs = source["totalDirs"];
	    }
	
		convertValues(a: any, classs: any, asMap: boolean = false): any {
		    if (!a) {
		        return a;
		    }
		    if (a.slice && a.map) {
		        return (a as any[]).map(elem => this.convertValues(elem, classs));
		    } else if ("object" === typeof a) {
		        if (asMap) {
		            for (const key of Object.keys(a)) {
		                a[key] = new classs(a[key]);
		            }
		            return a;
		        }
		        return new classs(a);
		    }
		    return a;
		}
	}
	
	export class NavigationResponse {
	    success: boolean;
	    message: string;
	    data: DirectoryContents;
	
	    static createFrom(source: any = {}) {
	        return new NavigationResponse(source);
	    }
	
	    constructor(source: any = {}) {
	        if ('string' === typeof source) source = JSON.parse(source);
	        this.success = source["success"];
	        this.message = source["message"];
	        this.data = this.convertValues(source["data"], DirectoryContents);
	    }
	
		convertValues(a: any, classs: any, asMap: boolean = false): any {
		    if (!a) {
		        return a;
		    }
		    if (a.slice && a.map) {
		        return (a as any[]).map(elem => this.convertValues(elem, classs));
		    } else if ("object" === typeof a) {
		        if (asMap) {
		            for (const key of Object.keys(a)) {
		                a[key] = new classs(a[key]);
		            }
		            return a;
		        }
		        return new classs(a);
		    }
		    return a;
		}
	}

}



================================================
File: frontend/wailsjs/go/backend/App.js
================================================
// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Â MODIWL
// This file is automatically generated. DO NOT EDIT

export function CopyFiles(arg1, arg2) {
  return window['go']['backend']['App']['CopyFiles'](arg1, arg2);
}

export function CreateDirectory(arg1, arg2) {
  return window['go']['backend']['App']['CreateDirectory'](arg1, arg2);
}

export function DeleteFiles(arg1) {
  return window['go']['backend']['App']['DeleteFiles'](arg1);
}

export function DeletePath(arg1) {
  return window['go']['backend']['App']['DeletePath'](arg1);
}

export function ExecuteCommand(arg1, arg2) {
  return window['go']['backend']['App']['ExecuteCommand'](arg1, arg2);
}

export function FileExists(arg1) {
  return window['go']['backend']['App']['FileExists'](arg1);
}

export function FormatFileSize(arg1) {
  return window['go']['backend']['App']['FormatFileSize'](arg1);
}

export function GetAvailableTerminals() {
  return window['go']['backend']['App']['GetAvailableTerminals']();
}

export function GetCurrentWorkingDirectory() {
  return window['go']['backend']['App']['GetCurrentWorkingDirectory']();
}

export function GetDriveInfo() {
  return window['go']['backend']['App']['GetDriveInfo']();
}

export function GetFileDetails(arg1) {
  return window['go']['backend']['App']['GetFileDetails'](arg1);
}

export function GetHomeDirectory() {
  return window['go']['backend']['App']['GetHomeDirectory']();
}

export function GetQuickAccessPaths() {
  return window['go']['backend']['App']['GetQuickAccessPaths']();
}

export function GetSystemRoots() {
  return window['go']['backend']['App']['GetSystemRoots']();
}

export function HealthCheck() {
  return window['go']['backend']['App']['HealthCheck']();
}

export function HideFiles(arg1) {
  return window['go']['backend']['App']['HideFiles'](arg1);
}

export function IsHidden(arg1) {
  return window['go']['backend']['App']['IsHidden'](arg1);
}

export function ListDirectory(arg1) {
  return window['go']['backend']['App']['ListDirectory'](arg1);
}

export function MoveFiles(arg1, arg2) {
  return window['go']['backend']['App']['MoveFiles'](arg1, arg2);
}

export function MoveFilesToRecycleBin(arg1) {
  return window['go']['backend']['App']['MoveFilesToRecycleBin'](arg1);
}

export function NavigateToPath(arg1) {
  return window['go']['backend']['App']['NavigateToPath'](arg1);
}

export function NavigateUp(arg1) {
  return window['go']['backend']['App']['NavigateUp'](arg1);
}

export function OpenFile(arg1) {
  return window['go']['backend']['App']['OpenFile'](arg1);
}

export function OpenInSystemExplorer(arg1) {
  return window['go']['backend']['App']['OpenInSystemExplorer'](arg1);
}

export function OpenPowerShellHere(arg1) {
  return window['go']['backend']['App']['OpenPowerShellHere'](arg1);
}

export function OpenTerminalHere(arg1) {
  return window['go']['backend']['App']['OpenTerminalHere'](arg1);
}

export function PrefetchDirectory(arg1) {
  return window['go']['backend']['App']['PrefetchDirectory'](arg1);
}

export function RenameFile(arg1, arg2) {
  return window['go']['backend']['App']['RenameFile'](arg1, arg2);
}

export function ValidatePath(arg1) {
  return window['go']['backend']['App']['ValidatePath'](arg1);
}


================================================
File: frontend/src/hooks/index.js
================================================
// Custom hooks for the File Explorer
export { useNavigation } from './useNavigation';
export { useDialogs } from './useDialogs';
export { useContextMenus } from './useContextMenus';
export { usePerformanceMonitoring } from './usePerformanceMonitoring';
export { useKeyboardShortcuts } from './useKeyboardShortcuts';
export { useDragAndDrop } from './useDragAndDrop';
export { useFolderCreation } from './useFolderCreation';


// Re-export existing hooks
export { useFileOperations } from './useFileOperations';
export { useSelection } from './useSelection';
export { useClipboard } from './useClipboard'; 

================================================
File: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        'wails-dark': 'rgba(27, 38, 54, 1)',
      },
      fontFamily: {
        'jetbrains': ['JetBrains Mono', 'monospace'],
      },
    },
  },
  plugins: [],
}



================================================
File: backend/filesystem_stream.go
================================================
//go:build windows

package backend

import (
	"os"
	"path/filepath"
	"strings"
	"syscall"
)

// BasicEntry holds minimal info for instant UI rendering
type BasicEntry struct {
	Name      string `json:"name"`
	Path      string `json:"path"`
	IsDir     bool   `json:"isDir"`
	Extension string `json:"extension"`
	IsHidden  bool   `json:"isHidden"`
}

// HydratedEntry holds complete file information for background processing
type HydratedEntry struct {
	BasicEntry
	Size        int64  `json:"size"`
	ModTime     int64  `json:"modTime"` // Unix timestamp for faster JSON serialization
	Permissions string `json:"permissions"`
}

// listDirectoryBasic uses Win32 FindFirstFileExW to get Name+Attrs in one syscall
// This is significantly faster than os.ReadDir + per-file stat calls
func listDirectoryBasic(dir string) ([]BasicEntry, error) {
	search := filepath.Join(dir, "*")
	searchPtr, err := syscall.UTF16PtrFromString(search)
	if err != nil {
		return nil, err
	}

	var fd syscall.Win32finddata
	handle, err := syscall.FindFirstFile(searchPtr, &fd)
	if err != nil {
		return nil, err
	}
	defer syscall.FindClose(handle)

	// Pre-allocate with reasonable capacity
	entries := make([]BasicEntry, 0, 64)

	for {
		name := syscall.UTF16ToString(fd.FileName[:])

		// Skip current and parent directory entries
		if name == "." || name == ".." {
			err = syscall.FindNextFile(handle, &fd)
			if err != nil {
				if err == syscall.ERROR_NO_MORE_FILES {
					break
				}
				return entries, err // Return partial results on error
			}
			continue
		}

		// Extract file attributes from Win32 data
		attr := fd.FileAttributes
		isDir := attr&syscall.FILE_ATTRIBUTE_DIRECTORY != 0
		isHidden := attr&syscall.FILE_ATTRIBUTE_HIDDEN != 0 ||
			attr&syscall.FILE_ATTRIBUTE_SYSTEM != 0

		// Get extension for files only
		var ext string
		if !isDir {
			ext = strings.ToLower(strings.TrimPrefix(filepath.Ext(name), "."))
		}

		entry := BasicEntry{
			Name:      name,
			Path:      filepath.Join(dir, name),
			IsDir:     isDir,
			IsHidden:  isHidden,
			Extension: ext,
		}

		entries = append(entries, entry)

		err = syscall.FindNextFile(handle, &fd)
		if err != nil {
			if err == syscall.ERROR_NO_MORE_FILES {
				break
			}
			return entries, err // Return partial results on error
		}
	}

	return entries, nil
}

// listDirectoryBasicFallback provides fallback for non-Windows systems
func listDirectoryBasicFallback(dir string, platform PlatformManagerInterface) ([]BasicEntry, error) {
	// Use os package for cross-platform compatibility
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	basic := make([]BasicEntry, 0, len(entries))
	for _, entry := range entries {
		name := entry.Name()
		fullPath := filepath.Join(dir, name)

		// Use entry.Info() to get file info
		info, err := entry.Info()
		if err != nil {
			continue // Skip files we can't stat
		}

		isDir := info.IsDir()
		isHidden := platform.IsHidden(fullPath)

		var ext string
		if !isDir && len(name) > 0 {
			ext = strings.ToLower(strings.TrimPrefix(filepath.Ext(name), "."))
		}

		basic = append(basic, BasicEntry{
			Name:      name,
			Path:      fullPath,
			IsDir:     isDir,
			IsHidden:  isHidden,
			Extension: ext,
		})
	}

	return basic, nil
}


================================================
File: frontend/wailsjs/runtime/package.json
================================================
{
  "name": "@wailsapp/runtime",
  "version": "2.0.0",
  "description": "Wails Javascript runtime library",
  "main": "runtime.js",
  "types": "runtime.d.ts",
  "scripts": {
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/wailsapp/wails.git"
  },
  "keywords": [
    "Wails",
    "Javascript",
    "Go"
  ],
  "author": "Lea Anthony <lea.anthony@gmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/wailsapp/wails/issues"
  },
  "homepage": "https://github.com/wailsapp/wails#readme"
}


================================================
File: frontend/src/hooks/useNavigation.js
================================================
import { useState, useCallback, useRef, useEffect } from "preact/hooks";
import { NavigateToPath } from "../../wailsjs/go/backend/App";
import { EventsOn, EventsOff } from "../../wailsjs/runtime/runtime";
import { log, error } from "../utils/logger";

export function useNavigation(setError, setNavigationStats) {
    const [currentPath, setCurrentPath] = useState('');
    const [directoryContents, setDirectoryContents] = useState(null);
    const [isActuallyLoading, setIsActuallyLoading] = useState(true);
    const [showLoadingIndicator, setShowLoadingIndicator] = useState(false);
    
    // Performance tracking refs
    const navigationStartTime = useRef(null);
    const loadingTimeout = useRef(null);
    const renderCompleteCallback = useRef(null);

    // Smart loading indicator management
    const showSmartLoadingIndicator = useCallback(() => {
        // Clear any existing timeout
        if (loadingTimeout.current) {
            clearTimeout(loadingTimeout.current);
        }
        
        // Only show loading after 150ms delay for perceived speed
        loadingTimeout.current = setTimeout(() => {
            if (isActuallyLoading) {
                setShowLoadingIndicator(true);
            }
        }, 150);
    }, [isActuallyLoading]);

    const hideLoadingIndicator = useCallback(() => {
        if (loadingTimeout.current) {
            clearTimeout(loadingTimeout.current);
            loadingTimeout.current = null;
        }
        setShowLoadingIndicator(false);
    }, []);

    // Helper function to measure render completion time
    const measureRenderTime = useCallback((startTime, source = 'unknown') => {
        // Wait for multiple animation frames to ensure rendering is complete
        // This accounts for: DOM updates, style calculations, layout, paint, and composite
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    const totalTime = Date.now() - startTime;
                    const renderPhaseTime = totalTime - (source === 'backend' ? 0 : 0); // Can track backend vs render split if needed
                    
                    // Update performance stats with the complete UI render time
                    setNavigationStats(prev => ({
                        totalNavigations: prev.totalNavigations + 1,
                        averageTime: (prev.averageTime * prev.totalNavigations + totalTime) / (prev.totalNavigations + 1),
                        lastNavigationTime: totalTime
                    }));
                    
                    log(`✅ Complete navigation with UI render: ${totalTime}ms total (includes backend + rendering)`);
                    
                    // Clear the callback reference
                    renderCompleteCallback.current = null;
                });
            });
        });
    }, [setNavigationStats]);

    // Navigate to path with real-time fresh data
    const navigateToPath = useCallback(async (path, source = 'user') => {
        log(`🧭 Navigation request: ${path} (${source}) - Real-time mode`);
        navigationStartTime.current = Date.now();
        
        // Clear any pending render completion callback
        if (renderCompleteCallback.current) {
            renderCompleteCallback.current = null;
        }
        
        // Set measuring state to show progress in UI
        setNavigationStats(prev => ({
            ...prev,
            lastNavigationTime: 0 // This will trigger "Measuring..." display
        }));
        
        try {
            setError('');
            
            // Always fetch fresh data from backend (no caching)
            setIsActuallyLoading(true);
            showSmartLoadingIndicator();
            
            // Backend call with optimized timeout
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Navigation timeout')), 5000);
            });
            
            const navigationPromise = NavigateToPath(path);
            const response = await Promise.race([navigationPromise, timeoutPromise]);
            
            if (response && response.success) {
                const backendTime = Date.now() - navigationStartTime.current;
                log(`📊 Fresh backend response received in ${backendTime}ms, starting UI render...`);
                
                setCurrentPath(response.data.currentPath);
                setDirectoryContents(response.data);
                
                // Measure render completion time for fresh data
                measureRenderTime(navigationStartTime.current, 'backend');
                
            } else {
                const errorMsg = response?.message || 'Unknown navigation error';
                setError(errorMsg);
                error('❌ Navigation failed:', errorMsg);
            }
        } catch (err) {
            error('❌ Navigation error:', err);
            setError('Failed to navigate: ' + err.message);
        } finally {
            setIsActuallyLoading(false);
            hideLoadingIndicator();
        }
    }, [setError, measureRenderTime, showSmartLoadingIndicator, hideLoadingIndicator]);

    // Navigate up
    const handleNavigateUp = useCallback(async () => {
        if (!currentPath) return;
        
        try {
            // Calculate parent path
            const parentPath = currentPath.includes('\\') 
                ? currentPath.split('\\').slice(0, -1).join('\\')
                : currentPath.split('/').slice(0, -1).join('/');
                
            if (parentPath && parentPath !== currentPath) {
                await navigateToPath(parentPath, 'navigate-up');
            }
        } catch (err) {
            error('❌ Navigate up error:', err);
            setError('Failed to navigate up: ' + err.message);
        }
    }, [currentPath, navigateToPath, setError]);

    const handleRefresh = useCallback(() => {
        if (currentPath) {
            navigateToPath(currentPath, 'refresh');
        }
    }, [currentPath, navigateToPath]);

    // Listen for progressive hydration events
    useEffect(() => {
        const unsubscribeHydrate = EventsOn("DirectoryHydrate", (fileInfo) => {
            log(`🔄 Hydrating file: ${fileInfo.name}`);
            
            setDirectoryContents(prev => {
                if (!prev) return prev;
                
                // Find and update the matching entry
                const allFiles = [...prev.directories, ...prev.files];
                const updatedFiles = allFiles.map(file => 
                    file.path === fileInfo.path ? fileInfo : file
                );
                
                // Split back into directories and files
                const directories = updatedFiles.filter(f => f.isDir);
                const files = updatedFiles.filter(f => !f.isDir);
                
                return {
                    ...prev,
                    directories,
                    files,
                    totalDirs: directories.length,
                    totalFiles: files.length
                };
            });
        });

        const unsubscribeComplete = EventsOn("DirectoryComplete", (data) => {
            log(`✅ Directory hydration completed: ${data.path} (${data.totalFiles} files processed)`);
            
            // Update performance stats to reflect completion
            setNavigationStats(prev => ({
                ...prev,
                lastHydrationTime: Date.now()
            }));
        });
        
        return () => {
            EventsOff("DirectoryHydrate");
            EventsOff("DirectoryComplete");
        };
    }, [setNavigationStats]);

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            if (loadingTimeout.current) {
                clearTimeout(loadingTimeout.current);
            }
            if (renderCompleteCallback.current) {
                renderCompleteCallback.current = null;
            }
        };
    }, []);

    return {
        currentPath,
        directoryContents,
        isActuallyLoading,
        showLoadingIndicator,
        navigateToPath,
        handleNavigateUp,
        handleRefresh
    };
} 

================================================
File: frontend/src/utils/styleConstants.js
================================================
// Pre-compiled style constants for zen minimalist theme
// These styles are computed once at module load time for optimal performance

// Common positioning and layout styles
export const FIXED_POSITION_STYLE = {
    position: 'fixed',
    zIndex: 1000
};

export const CONTEXT_MENU_STYLE = {
    position: 'fixed',
    zIndex: 1000,
    background: 'var(--zen-surface)',
    border: '1px solid var(--zen-border)',
    borderRadius: 'var(--zen-radius-md)',
    boxShadow: 'var(--zen-shadow-lg)',
    minWidth: '200px',
    padding: 'var(--zen-space-sm)',
    backdropFilter: 'blur(16px)',
    WebkitBackdropFilter: 'blur(16px)'
};

export const LOADING_OVERLAY_STYLE = {
    textAlign: 'center',
    padding: 'var(--zen-space-3xl) var(--zen-space-2xl)',
    color: 'var(--zen-text-tertiary)',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: 'var(--zen-space-lg)'
};

export const EMPTY_DIRECTORY_STYLE = {
    textAlign: 'center',
    padding: 'var(--zen-space-3xl) var(--zen-space-2xl)',
    color: 'var(--zen-text-tertiary)',
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: 'var(--zen-space-lg)'
};

export const LARGE_ICON_STYLE = {
    fontSize: '3rem',
    marginBottom: 'var(--zen-space-lg)',
    opacity: 0.5
};

export const LOADING_SPINNER_LARGE_STYLE = {
    width: '2rem',
    height: '2rem',
    marginBottom: 'var(--zen-space-lg)',
    border: '2px solid var(--zen-border)',
    borderTop: '2px solid var(--zen-primary)',
    borderRadius: '50%'
};

export const HEADER_STATS_STYLE = {
    marginLeft: 'auto',
    display: 'flex',
    alignItems: 'center',
    gap: 'var(--zen-space-lg)',
    fontSize: 'var(--zen-text-sm)',
    color: 'var(--zen-text-secondary)'
};

export const PERFORMANCE_INDICATOR_STYLE = {
    fontSize: 'var(--zen-text-xs)',
    opacity: 0.6,
    color: 'var(--zen-text-tertiary)',
    fontWeight: 500
};

export const CURRENT_PATH_INDICATOR_STYLE = {
    fontSize: 'var(--zen-text-sm)',
    opacity: 0.7,
    maxWidth: '200px',
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    color: 'var(--zen-text-secondary)'
};

export const ERROR_DISMISS_BUTTON_STYLE = {
    marginLeft: 'var(--zen-space-lg)',
    background: 'none',
    border: 'none',
    color: 'inherit',
    textDecoration: 'underline',
    cursor: 'pointer',
    fontSize: 'var(--zen-text-sm)',
    padding: 'var(--zen-space-sm)',
    borderRadius: 'var(--zen-radius-sm)',
    transition: 'all 150ms ease'
};

export const STATUS_BAR_RIGHT_STYLE = {
    marginLeft: 'auto',
    fontSize: 'var(--zen-text-xs)',
    color: 'var(--zen-text-tertiary)'
};

// Animation and transition styles - More zen and subtle
export const TRANSFORM_TRANSITION_STYLE = {
    transition: 'transform 200ms ease-out, opacity 200ms ease-out',
    willChange: 'transform'
};

export const OPACITY_TRANSITION_STYLE = {
    transition: 'opacity 200ms ease-out'
};

// Layout helpers - More spacious
export const FLEX_CENTER_STYLE = {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 'var(--zen-space-md)'
};

export const FLEX_COLUMN_STYLE = {
    display: 'flex',
    flexDirection: 'column',
    gap: 'var(--zen-space-md)'
};

export const FLEX_ROW_STYLE = {
    display: 'flex',
    flexDirection: 'row',
    alignItems: 'center',
    gap: 'var(--zen-space-md)'
};

// Spacing using zen variables
export const SMALL_MARGIN_STYLE = { margin: 'var(--zen-space-sm)' };
export const MEDIUM_MARGIN_STYLE = { margin: 'var(--zen-space-lg)' };
export const LARGE_MARGIN_STYLE = { margin: 'var(--zen-space-xl)' };

export const SMALL_PADDING_STYLE = { padding: 'var(--zen-space-sm)' };
export const MEDIUM_PADDING_STYLE = { padding: 'var(--zen-space-lg)' };
export const LARGE_PADDING_STYLE = { padding: 'var(--zen-space-xl)' };

// Text styles - More refined typography
export const MONOSPACE_STYLE = {
    fontFamily: "'JetBrains Mono', ui-monospace, 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace",
    fontSize: 'var(--zen-text-sm)',
    lineHeight: 1.5
};

export const TECHNICAL_TEXT_STYLE = {
    fontFamily: "inherit",
    fontSize: 'var(--zen-text-xs)',
    opacity: 0.8,
    color: 'var(--zen-text-tertiary)',
    fontWeight: 500
};

// Hidden/disabled styles
export const HIDDEN_STYLE = { display: 'none' };
export const INVISIBLE_STYLE = { visibility: 'hidden' };
export const DISABLED_STYLE = { 
    opacity: 0.5, 
    pointerEvents: 'none' 
};

// Drag and drop styles - More zen
export const DRAG_OVER_STYLE = {
    background: 'var(--zen-primary-alpha-hover)',
    borderColor: 'var(--zen-primary)',
    transform: 'scale(1.02)',
    boxShadow: 'var(--zen-shadow-md)'
};

export const DRAG_PREVIEW_STYLE = {
    opacity: 0.6,
    transform: 'rotate(-2deg) scale(0.95)',
    filter: 'none'
};

// File item styles - Refined and spacious
export const FILE_ITEM_SELECTED_STYLE = {
    background: 'var(--zen-primary-alpha)',
    borderColor: 'var(--zen-primary)',
    color: 'var(--zen-primary)',
    transform: 'translateY(-1px)',
    boxShadow: 'var(--zen-shadow)'
};

export const FILE_ITEM_CUT_STYLE = {
    opacity: 0.6,
    filter: 'grayscale(30%)',
    borderStyle: 'dashed'
}; 

================================================
File: main.go
================================================
package main

import (
	"embed"

	"github.com/wailsapp/wails/v2"
	"github.com/wailsapp/wails/v2/pkg/options"
	"github.com/wailsapp/wails/v2/pkg/options/assetserver"

	"lightning_explorer/backend"
)

//go:embed all:frontend/dist
var assets embed.FS

func main() {
	// Create an instance of the app structure
	app := backend.NewApp()

	// Create application with options
	err := wails.Run(&options.App{
		Title:  "Lightning Explorer",
		Width:  1400,
		Height: 900,
		AssetServer: &assetserver.Options{
			Assets: assets,
		},
		BackgroundColour: &options.RGBA{R: 27, G: 38, B: 54, A: 1},
		OnStartup:        app.Startup,
		Bind: []interface{}{
			app,
		},
	})

	if err != nil {
		println("Error:", err.Error())
	}
}


================================================
File: frontend/wailsjs/go/backend/App.d.ts
================================================
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Â MODIWL
// This file is automatically generated. DO NOT EDIT
import {backend} from '../models';

export function CopyFiles(arg1:Array<string>,arg2:string):Promise<boolean>;

export function CreateDirectory(arg1:string,arg2:string):Promise<backend.NavigationResponse>;

export function DeleteFiles(arg1:Array<string>):Promise<boolean>;

export function DeletePath(arg1:string):Promise<backend.NavigationResponse>;

export function ExecuteCommand(arg1:string,arg2:string):Promise<boolean>;

export function FileExists(arg1:string):Promise<boolean>;

export function FormatFileSize(arg1:number):Promise<string>;

export function GetAvailableTerminals():Promise<Array<string>>;

export function GetCurrentWorkingDirectory():Promise<string>;

export function GetDriveInfo():Promise<Array<Record<string, any>>>;

export function GetFileDetails(arg1:string):Promise<backend.FileInfo>;

export function GetHomeDirectory():Promise<string>;

export function GetQuickAccessPaths():Promise<Array<Record<string, any>>>;

export function GetSystemRoots():Promise<Array<string>>;

export function HealthCheck():Promise<Record<string, any>>;

export function HideFiles(arg1:Array<string>):Promise<boolean>;

export function IsHidden(arg1:string):Promise<boolean>;

export function ListDirectory(arg1:string):Promise<backend.NavigationResponse>;

export function MoveFiles(arg1:Array<string>,arg2:string):Promise<boolean>;

export function MoveFilesToRecycleBin(arg1:Array<string>):Promise<boolean>;

export function NavigateToPath(arg1:string):Promise<backend.NavigationResponse>;

export function NavigateUp(arg1:string):Promise<backend.NavigationResponse>;

export function OpenFile(arg1:string):Promise<boolean>;

export function OpenInSystemExplorer(arg1:string):Promise<boolean>;

export function OpenPowerShellHere(arg1:string):Promise<boolean>;

export function OpenTerminalHere(arg1:string):Promise<boolean>;

export function PrefetchDirectory(arg1:string):Promise<backend.NavigationResponse>;

export function RenameFile(arg1:string,arg2:string):Promise<boolean>;

export function ValidatePath(arg1:string):Promise<boolean>;


================================================
File: frontend/src/utils/fileTypeMaps.js
================================================
// Pre-compiled file type and icon maps for optimal performance
// These are constants that are computed once at module load time

// Specific file mappings (highest priority)
export const SPECIFIC_FILE_MAP = {
    'readme': 'readme',
    'readme.md': 'readme',
    'readme.txt': 'readme',
    'license': 'license',
    'license.md': 'license',
    'license.txt': 'license',
    'dockerfile': 'docker',
    'docker-compose.yml': 'docker',
    'docker-compose.yaml': 'docker',
    'makefile': 'build',
    'cmake.txt': 'build',
    'package.json': 'nodejs',
    'package-lock.json': 'nodejs',
    'yarn.lock': 'nodejs',
    'pom.xml': 'java',
    'build.gradle': 'java',
    'cargo.toml': 'rust',
    'go.mod': 'go',
    'requirements.txt': 'python',
    'pipfile': 'python',
    '.gitignore': 'git',
    '.gitmodules': 'git',
    '.env': 'config',
    '.env.local': 'config',
    '.env.example': 'config'
};

// Extension to type mappings
export const EXTENSION_TYPE_MAP = {
    // Web technologies
    'js': 'javascript', 'mjs': 'javascript', 'cjs': 'javascript',
    'jsx': 'react', 'tsx': 'react',
    'ts': 'typescript',
    'html': 'html', 'htm': 'html',
    'css': 'css', 'scss': 'sass', 'sass': 'sass', 'less': 'css',
    'vue': 'vue', 'svelte': 'svelte',
    'php': 'php', 'phtml': 'php',
    
    // System languages
    'c': 'c', 'h': 'c',
    'cpp': 'cpp', 'cxx': 'cpp', 'cc': 'cpp', 'hpp': 'cpp',
    'cs': 'csharp', 'csx': 'csharp',
    'java': 'java', 'class': 'java', 'jar': 'java',
    'go': 'go',
    'rs': 'rust', 'rlib': 'rust',
    'swift': 'swift',
    'kt': 'kotlin', 'kts': 'kotlin',
    'dart': 'dart',
    
    // Scripting languages
    'py': 'python', 'pyw': 'python', 'pyc': 'python',
    'rb': 'ruby', 'rbw': 'ruby',
    'pl': 'perl', 'pm': 'perl',
    'lua': 'lua',
    'r': 'r', 'rdata': 'r',
    'jl': 'julia',
    
    // Windows scripts
    'ps1': 'powershell', 'psm1': 'powershell',
    'bat': 'batch', 'cmd': 'batch',
    
    // Assembly and low-level
    'asm': 'assembly', 's': 'assembly',
    
    // Database
    'sql': 'database', 'mysql': 'database', 'pgsql': 'database',
    'db': 'database', 'sqlite': 'database', 'sqlite3': 'database',
    
    // Configuration and data
    'json': 'json', 'jsonc': 'json',
    'xml': 'xml', 'xsd': 'xml', 'xsl': 'xml',
    'yaml': 'yaml', 'yml': 'yaml',
    'toml': 'config', 'ini': 'config', 'cfg': 'config', 'conf': 'config',
    'properties': 'config', 'env': 'config',
    
    // Images
    'jpg': 'image', 'jpeg': 'image',
    'png': 'image',
    'gif': 'gif',
    'svg': 'vector',
    'bmp': 'image',
    'webp': 'image',
    'ico': 'icon',
    'tiff': 'image', 'tif': 'image',
    'raw': 'camera', 'cr2': 'camera', 'nef': 'camera', 'arw': 'camera',
    'psd': 'photoshop', 'psb': 'photoshop',
    'ai': 'illustrator',
    'sketch': 'design',
    'fig': 'figma',
    'xd': 'xd',
    
    // Audio files
    'mp3': 'audio', 'm4a': 'audio', 'aac': 'audio',
    'wav': 'audio', 'flac': 'audio', 'ogg': 'audio',
    'wma': 'audio', 'aiff': 'audio',
    'midi': 'music', 'mid': 'music',
    
    // Video files
    'mp4': 'video', 'm4v': 'video',
    'avi': 'video', 'mkv': 'video', 'mov': 'video',
    'wmv': 'video', 'flv': 'video', 'webm': 'video',
    '3gp': 'video', 'mpg': 'video', 'mpeg': 'video',
    
    // Documents
    'pdf': 'pdf',
    'doc': 'word', 'docx': 'word',
    'xls': 'excel', 'xlsx': 'excel', 'csv': 'csv',
    'ppt': 'powerpoint', 'pptx': 'powerpoint',
    'odt': 'document', 'ods': 'document', 'odp': 'document',
    'rtf': 'document',
    'txt': 'text',
    'md': 'markdown', 'markdown': 'markdown',
    'tex': 'latex', 'bib': 'latex',
    'epub': 'ebook', 'mobi': 'ebook', 'azw': 'ebook',
    
    // Archives
    'zip': 'archive', 'rar': 'archive', '7z': 'archive',
    'cab': 'archive', 'iso': 'disc',
    
    // Executables
    'exe': 'executable', 'msi': 'installer',
    
    // Fonts
    'ttf': 'font', 'otf': 'font', 'woff': 'font', 'woff2': 'font',
    'eot': 'font', 'fon': 'font',
    
    // 3D and CAD
    'obj': '3d', 'fbx': '3d', 'dae': '3d', 'blend': 'blender',
    'max': '3d', '3ds': '3d', 'stl': '3d', 'ply': '3d',
    'dwg': 'cad', 'dxf': 'cad', 'step': 'cad', 'iges': 'cad'
};

// Special folder icons
export const SPECIAL_FOLDER_MAP = {
    'node_modules': '📦',
    '.git': '🔀',
    '.vscode': '🔵',
    '.idea': '💡',
    'dist': '📦',
    'build': '🔨',
    'src': '📂',
    'assets': '🎨',
    'images': '🖼️',
    'img': '🖼️',
    'css': '🎨',
    'js': '📜',
    'components': '🧩',
    'utils': '🔧',
    'config': '⚙️',
    'docs': '📚',
    'documentation': '📚',
    'test': '🧪',
    'tests': '🧪',
    '__pycache__': '🐍',
    'venv': '🐍',
    'env': '🌍',
    'bin': '⚙️',
    'lib': '📚',
    'include': '📂',
    'public': '🌐',
    'private': '🔒',
    'temp': '🗂️',
    'tmp': '🗂️',
    'cache': '💾',
    'log': '📝',
    'logs': '📝'
};

// Type to icon mappings
export const TYPE_ICON_MAP = {
    // Programming languages
    'javascript': '🟨',
    'typescript': '🔷',
    'react': '⚛️',
    'vue': '💚',
    'svelte': '🧡',
    'html': '🌐',
    'css': '🎨',
    'sass': '💅',
    'php': '🐘',
    'python': '🐍',
    'java': '☕',
    'csharp': '🔷',
    'cpp': '⚙️',
    'c': '🔧',
    'go': '🐹',
    'rust': '🦀',
    'swift': '🐦',
    'kotlin': '🟣',
    'dart': '🎯',
    'ruby': '💎',
    'perl': '🐪',
    'lua': '🌙',
    'r': '📊',
    'julia': '🔴',
    'powershell': '💙',
    'batch': '⚫',
    'assembly': '🔩',
    
    // Data and config
    'json': '📋',
    'xml': '📄',
    'yaml': '📝',
    'database': '🗄️',
    'config': '⚙️',
    
    // Special files
    'readme': '📖',
    'license': '📜',
    'docker': '🐳',
    'build': '🔨',
    'nodejs': '💚',
    'git': '🔀',
    
    // Images
    'image': '🖼️',
    'gif': '🎞️',
    'vector': '🎨',
    'icon': '🔳',
    'camera': '📷',
    'photoshop': '🎨',
    'illustrator': '🎨',
    'design': '🎨',
    'figma': '🎨',
    'xd': '🎨',
    
    // Media
    'audio': '🎵',
    'music': '🎼',
    'video': '🎬',
    
    // Documents
    'pdf': '📕',
    'word': '📘',
    'excel': '📗',
    'csv': '📊',
    'powerpoint': '📙',
    'document': '📄',
    'text': '📝',
    'markdown': '📝',
    'latex': '📖',
    'ebook': '📚',
    
    // Archives and packages
    'archive': '📦',
    'package': '📦',
    'disc': '💿',
    
    // Executables
    'executable': '⚡',
    'installer': '📦',
    'batch': '⚫',
    
    // Fonts
    'font': '🔤',
    
    // 3D and design
    '3d': '🎲',
    'blender': '🎲',
    'cad': '📐',
    
    // Default
    'file': '📄',
    'folder': '📁'
};

// Default constants
export const DEFAULT_FILE_ICON = '📄';
export const DEFAULT_FOLDER_ICON = '📁';
export const DEFAULT_FILE_TYPE = 'file'; 

================================================
File: backend/filesystem.go
================================================
package backend

import (
	"context"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"
)

// NewFileSystemManager creates a new filesystem manager instance
func NewFileSystemManager(platform PlatformManagerInterface) *FileSystemManager {
	return &FileSystemManager{
		platform: platform,
	}
}

// SetContext sets the Wails context for event emission
func (fs *FileSystemManager) SetContext(ctx context.Context) {
	fs.ctx = ctx
	fs.eventEmitter = NewEventEmitter(ctx)
}

// ListDirectory lists the contents of a directory with streaming optimization
func (fs *FileSystemManager) ListDirectory(path string) NavigationResponse {
	startTime := time.Now()
	log.Printf("📂 Listing directory with streaming: %s", path)

	if path == "" {
		path = fs.platform.GetHomeDirectory()
	}

	// Clean and validate path
	path = filepath.Clean(path)

	// Quick existence check first
	info, err := os.Stat(path)
	if err != nil {
		return NavigationResponse{
			Success: false,
			Message: fmt.Sprintf("Cannot access path: %v", err),
		}
	}

	if !info.IsDir() {
		return NavigationResponse{
			Success: false,
			Message: "Path is not a directory",
		}
	}

	// Use optimized enumeration
	basicEntries, err := listDirectoryBasic(path)
	if err != nil {
		return NavigationResponse{
			Success: false,
			Message: fmt.Sprintf("Cannot read directory: %v", err),
		}
	}

	// Filter out skipped files
	var filteredEntries []BasicEntry
	for _, entry := range basicEntries {
		if !fs.shouldSkipFile(entry.Name) {
			filteredEntries = append(filteredEntries, entry)
		}
	}

	// Split into first page and rest for background processing
	const pageSize = 100
	firstPage := filteredEntries
	var rest []BasicEntry

	if len(filteredEntries) > pageSize {
		firstPage = filteredEntries[:pageSize]
		rest = filteredEntries[pageSize:]
	}

	// Convert first page to FileInfo with minimal data
	files := make([]FileInfo, 0, pageSize/2)
	directories := make([]FileInfo, 0, pageSize/2)

	for _, entry := range firstPage {
		// Create minimal FileInfo for immediate display
		fileInfo := FileInfo{
			Name:        entry.Name,
			Path:        entry.Path,
			IsDir:       entry.IsDir,
			Extension:   entry.Extension,
			IsHidden:    entry.IsHidden,
			Size:        0,           // Defer size calculation
			ModTime:     time.Time{}, // Defer mod time
			Permissions: "",          // Defer permissions
		}

		if entry.IsDir {
			directories = append(directories, fileInfo)
		} else {
			files = append(files, fileInfo)
		}
	}

	// Sort first page for immediate display
	sort.Slice(directories, func(i, j int) bool {
		return strings.ToLower(directories[i].Name) < strings.ToLower(directories[j].Name)
	})
	sort.Slice(files, func(i, j int) bool {
		return strings.ToLower(files[i].Name) < strings.ToLower(files[j].Name)
	})

	// Get parent path
	parentPath := filepath.Dir(path)
	if parentPath == path {
		parentPath = ""
	}

	// Build immediate response
	contents := DirectoryContents{
		CurrentPath: path,
		ParentPath:  parentPath,
		Files:       files,
		Directories: directories,
		TotalFiles:  len(files),
		TotalDirs:   len(directories),
	}

	// Start background hydration if we have remaining entries
	if len(rest) > 0 {
		go fs.hydrateRemainingEntries(path, rest)
	}

	processingTime := time.Since(startTime)
	log.Printf("✅ First page listed in %v: %s (%d dirs, %d files, %d deferred)",
		processingTime, path, len(directories), len(files), len(rest))

	return NavigationResponse{
		Success: true,
		Message: fmt.Sprintf("Directory listed (first page) in %v", processingTime),
		Data:    contents,
	}
}

// hydrateRemainingEntries processes remaining entries in background
func (fs *FileSystemManager) hydrateRemainingEntries(basePath string, entries []BasicEntry) {
	log.Printf("🔄 Starting background hydration for %d entries", len(entries))

	for _, entry := range entries {
		// Get full file info with stat data
		info, err := os.Stat(entry.Path)
		if err != nil {
			log.Printf("⚠️ Failed to stat %s: %v", entry.Path, err)
			continue
		}

		// Create complete FileInfo
		fileInfo := FileInfo{
			Name:        entry.Name,
			Path:        entry.Path,
			IsDir:       entry.IsDir,
			Size:        info.Size(),
			ModTime:     info.ModTime(),
			Permissions: info.Mode().String(),
			Extension:   entry.Extension,
			IsHidden:    entry.IsHidden,
		}

		// Emit hydration event to frontend
		if fs.eventEmitter != nil {
			fs.eventEmitter.EmitDirectoryHydrate(fileInfo)
		}
	}

	// Emit completion event
	if fs.eventEmitter != nil {
		fs.eventEmitter.EmitDirectoryComplete(basePath, len(entries), 0)
	}

	log.Printf("✅ Background hydration completed for %s", basePath)
}

// processEntriesSync processes directory entries synchronously with optimizations
func (fs *FileSystemManager) processEntriesSync(path string, entries []os.DirEntry, files, directories []FileInfo) ([]FileInfo, []FileInfo) {
	for _, entry := range entries {
		// Skip processing certain system files early for performance
		name := entry.Name()
		if fs.shouldSkipFile(name) {
			continue
		}

		fileInfo := fs.CreateFileInfoOptimized(path, name, entry)

		if fileInfo.IsDir {
			directories = append(directories, fileInfo)
		} else {
			files = append(files, fileInfo)
		}
	}
	return files, directories
}

// processEntriesConcurrent processes directory entries concurrently with worker pool
func (fs *FileSystemManager) processEntriesConcurrent(path string, entries []os.DirEntry) ([]FileInfo, []FileInfo) {
	// Optimized worker pool size based on entry count and CPU cores
	numWorkers := 6 // Sweet spot for most systems
	if len(entries) < 200 {
		numWorkers = 3
	}

	type workItem struct {
		entry os.DirEntry
		index int
	}

	type result struct {
		fileInfo FileInfo
		isDir    bool
		index    int
	}

	entryChan := make(chan workItem, len(entries))
	resultChan := make(chan result, len(entries))

	// Start worker goroutines
	var wg sync.WaitGroup
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for item := range entryChan {
				// Skip certain files early
				if fs.shouldSkipFile(item.entry.Name()) {
					continue
				}

				fileInfo := fs.CreateFileInfoOptimized(path, item.entry.Name(), item.entry)
				resultChan <- result{
					fileInfo: fileInfo,
					isDir:    fileInfo.IsDir,
					index:    item.index,
				}
			}
		}()
	}

	// Send work items
	go func() {
		defer close(entryChan)
		for i, entry := range entries {
			entryChan <- workItem{entry: entry, index: i}
		}
	}()

	// Close result channel when all workers are done
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Collect results
	files := make([]FileInfo, 0, len(entries)/2)
	directories := make([]FileInfo, 0, len(entries)/2)

	for res := range resultChan {
		if res.isDir {
			directories = append(directories, res.fileInfo)
		} else {
			files = append(files, res.fileInfo)
		}
	}

	return files, directories
}

// shouldSkipFile determines if a file should be skipped for performance
func (fs *FileSystemManager) shouldSkipFile(name string) bool {
	// Skip certain system files that are typically not needed
	skipPatterns := []string{
		"$RECYCLE.BIN",
		"System Volume Information",
		"pagefile.sys",
		"hiberfil.sys",
		"swapfile.sys",
		".DS_Store",
		".Trashes",
		".Spotlight-V100",
	}

	for _, pattern := range skipPatterns {
		if strings.EqualFold(name, pattern) {
			return true
		}
	}

	return false
}

// CreateFileInfoOptimized creates FileInfo with performance optimizations
func (fs *FileSystemManager) CreateFileInfoOptimized(basePath string, name string, entry os.DirEntry) FileInfo {
	fullPath := filepath.Join(basePath, name)

	// Use DirEntry info when possible to avoid extra stat calls
	var info os.FileInfo
	var err error

	if entry != nil {
		info, err = entry.Info()
	} else {
		info, err = os.Stat(fullPath)
	}

	if err != nil {
		log.Printf("Warning: Error getting file info for %s: %v", fullPath, err)
		// Return basic info even on error
		return FileInfo{
			Name:     name,
			Path:     fullPath,
			IsDir:    entry != nil && entry.IsDir(),
			IsHidden: fs.platform.IsHidden(fullPath),
		}
	}

	return FileInfo{
		Name:        name,
		Path:        fullPath,
		IsDir:       info.IsDir(),
		Size:        info.Size(),
		ModTime:     info.ModTime(),
		Permissions: info.Mode().String(),
		Extension:   fs.platform.GetExtension(name),
		IsHidden:    fs.platform.IsHidden(fullPath),
	}
}

// CreateFileInfo creates FileInfo from file path and name (backward compatibility)
func (fs *FileSystemManager) CreateFileInfo(basePath string, name string) FileInfo {
	return fs.CreateFileInfoOptimized(basePath, name, nil)
}

// GetFileInfo returns detailed information about a specific file
func (fs *FileSystemManager) GetFileInfo(filePath string) (FileInfo, error) {
	log.Printf("Getting file details for: %s", filePath)

	info, err := os.Stat(filePath)
	if err != nil {
		log.Printf("Error getting file details: %v", err)
		return FileInfo{}, err
	}

	return FileInfo{
		Name:        filepath.Base(filePath),
		Path:        filePath,
		IsDir:       info.IsDir(),
		Size:        info.Size(),
		ModTime:     info.ModTime(),
		Permissions: info.Mode().String(),
		Extension:   fs.platform.GetExtension(filepath.Base(filePath)),
		IsHidden:    fs.platform.IsHidden(filePath),
	}, nil
}

// IsHidden checks if a file/directory is hidden
func (fs *FileSystemManager) IsHidden(path string) bool {
	return fs.platform.IsHidden(path)
}

// GetExtension returns the file extension
func (fs *FileSystemManager) GetExtension(name string) string {
	return fs.platform.GetExtension(name)
}

// NavigateToPath navigates to a specific path with enhanced logging
func (fs *FileSystemManager) NavigateToPath(path string) NavigationResponse {
	log.Printf("🧭 Navigation request: %s", path)
	return fs.ListDirectory(path)
}

// NavigateUp navigates to the parent directory with path validation
func (fs *FileSystemManager) NavigateUp(currentPath string) NavigationResponse {
	if currentPath == "" {
		return NavigationResponse{
			Success: false,
			Message: "No current path provided",
		}
	}

	parentPath := filepath.Dir(currentPath)
	if parentPath == currentPath {
		// Already at root
		return NavigationResponse{
			Success: false,
			Message: "Already at root directory",
		}
	}

	log.Printf("⬆️ Navigate up: %s -> %s", currentPath, parentPath)
	return fs.ListDirectory(parentPath)
}

// FileExists checks if a file exists
func (fs *FileSystemManager) FileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

// CreateDirectory creates a new directory
func (fs *FileSystemManager) CreateDirectory(path, name string) NavigationResponse {
	fullPath := filepath.Join(path, name)

	err := os.MkdirAll(fullPath, 0755)
	if err != nil {
		return NavigationResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to create directory: %v", err),
		}
	}

	log.Printf("📁 Directory created: %s", fullPath)
	return NavigationResponse{
		Success: true,
		Message: "Directory created successfully",
	}
}

// ValidatePath checks if a path is valid and accessible with optimized validation
func (fs *FileSystemManager) ValidatePath(path string) error {
	if path == "" {
		return fmt.Errorf("path cannot be empty")
	}

	info, err := os.Stat(path)
	if err != nil {
		return fmt.Errorf("cannot access path: %v", err)
	}

	if !info.IsDir() {
		return fmt.Errorf("path is not a directory")
	}

	return nil
}


================================================
File: frontend/wailsjs/runtime/runtime.js
================================================
/*
 _       __      _ __
| |     / /___ _(_) /____
| | /| / / __ `/ / / ___/
| |/ |/ / /_/ / / (__  )
|__/|__/\__,_/_/_/____/
The electron alternative for Go
(c) Lea Anthony 2019-present
*/

export function LogPrint(message) {
    window.runtime.LogPrint(message);
}

export function LogTrace(message) {
    window.runtime.LogTrace(message);
}

export function LogDebug(message) {
    window.runtime.LogDebug(message);
}

export function LogInfo(message) {
    window.runtime.LogInfo(message);
}

export function LogWarning(message) {
    window.runtime.LogWarning(message);
}

export function LogError(message) {
    window.runtime.LogError(message);
}

export function LogFatal(message) {
    window.runtime.LogFatal(message);
}

export function EventsOnMultiple(eventName, callback, maxCallbacks) {
    return window.runtime.EventsOnMultiple(eventName, callback, maxCallbacks);
}

export function EventsOn(eventName, callback) {
    return EventsOnMultiple(eventName, callback, -1);
}

export function EventsOff(eventName, ...additionalEventNames) {
    return window.runtime.EventsOff(eventName, ...additionalEventNames);
}

export function EventsOnce(eventName, callback) {
    return EventsOnMultiple(eventName, callback, 1);
}

export function EventsEmit(eventName) {
    let args = [eventName].slice.call(arguments);
    return window.runtime.EventsEmit.apply(null, args);
}

export function WindowReload() {
    window.runtime.WindowReload();
}

export function WindowReloadApp() {
    window.runtime.WindowReloadApp();
}

export function WindowSetAlwaysOnTop(b) {
    window.runtime.WindowSetAlwaysOnTop(b);
}

export function WindowSetSystemDefaultTheme() {
    window.runtime.WindowSetSystemDefaultTheme();
}

export function WindowSetLightTheme() {
    window.runtime.WindowSetLightTheme();
}

export function WindowSetDarkTheme() {
    window.runtime.WindowSetDarkTheme();
}

export function WindowCenter() {
    window.runtime.WindowCenter();
}

export function WindowSetTitle(title) {
    window.runtime.WindowSetTitle(title);
}

export function WindowFullscreen() {
    window.runtime.WindowFullscreen();
}

export function WindowUnfullscreen() {
    window.runtime.WindowUnfullscreen();
}

export function WindowIsFullscreen() {
    return window.runtime.WindowIsFullscreen();
}

export function WindowGetSize() {
    return window.runtime.WindowGetSize();
}

export function WindowSetSize(width, height) {
    window.runtime.WindowSetSize(width, height);
}

export function WindowSetMaxSize(width, height) {
    window.runtime.WindowSetMaxSize(width, height);
}

export function WindowSetMinSize(width, height) {
    window.runtime.WindowSetMinSize(width, height);
}

export function WindowSetPosition(x, y) {
    window.runtime.WindowSetPosition(x, y);
}

export function WindowGetPosition() {
    return window.runtime.WindowGetPosition();
}

export function WindowHide() {
    window.runtime.WindowHide();
}

export function WindowShow() {
    window.runtime.WindowShow();
}

export function WindowMaximise() {
    window.runtime.WindowMaximise();
}

export function WindowToggleMaximise() {
    window.runtime.WindowToggleMaximise();
}

export function WindowUnmaximise() {
    window.runtime.WindowUnmaximise();
}

export function WindowIsMaximised() {
    return window.runtime.WindowIsMaximised();
}

export function WindowMinimise() {
    window.runtime.WindowMinimise();
}

export function WindowUnminimise() {
    window.runtime.WindowUnminimise();
}

export function WindowSetBackgroundColour(R, G, B, A) {
    window.runtime.WindowSetBackgroundColour(R, G, B, A);
}

export function ScreenGetAll() {
    return window.runtime.ScreenGetAll();
}

export function WindowIsMinimised() {
    return window.runtime.WindowIsMinimised();
}

export function WindowIsNormal() {
    return window.runtime.WindowIsNormal();
}

export function BrowserOpenURL(url) {
    window.runtime.BrowserOpenURL(url);
}

export function Environment() {
    return window.runtime.Environment();
}

export function Quit() {
    window.runtime.Quit();
}

export function Hide() {
    window.runtime.Hide();
}

export function Show() {
    window.runtime.Show();
}

export function ClipboardGetText() {
    return window.runtime.ClipboardGetText();
}

export function ClipboardSetText(text) {
    return window.runtime.ClipboardSetText(text);
}

/**
 * Callback for OnFileDrop returns a slice of file path strings when a drop is finished.
 *
 * @export
 * @callback OnFileDropCallback
 * @param {number} x - x coordinate of the drop
 * @param {number} y - y coordinate of the drop
 * @param {string[]} paths - A list of file paths.
 */

/**
 * OnFileDrop listens to drag and drop events and calls the callback with the coordinates of the drop and an array of path strings.
 *
 * @export
 * @param {OnFileDropCallback} callback - Callback for OnFileDrop returns a slice of file path strings when a drop is finished.
 * @param {boolean} [useDropTarget=true] - Only call the callback when the drop finished on an element that has the drop target style. (--wails-drop-target)
 */
export function OnFileDrop(callback, useDropTarget) {
    return window.runtime.OnFileDrop(callback, useDropTarget);
}

/**
 * OnFileDropOff removes the drag and drop listeners and handlers.
 */
export function OnFileDropOff() {
    return window.runtime.OnFileDropOff();
}

export function CanResolveFilePaths() {
    return window.runtime.CanResolveFilePaths();
}

export function ResolveFilePaths(files) {
    return window.runtime.ResolveFilePaths(files);
}

================================================
File: frontend/vite.config.js
================================================
import {defineConfig} from 'vite'
import preact from '@preact/preset-vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [preact()]
})


================================================
File: backend/filesystem_stream_fallback.go
================================================
//go:build !windows

package backend

import (
	"os"
	"path/filepath"
	"strings"
)

// BasicEntry holds minimal info for instant UI rendering
type BasicEntry struct {
	Name      string `json:"name"`
	Path      string `json:"path"`
	IsDir     bool   `json:"isDir"`
	Extension string `json:"extension"`
	IsHidden  bool   `json:"isHidden"`
}

// HydratedEntry holds complete file information for background processing
type HydratedEntry struct {
	BasicEntry
	Size        int64  `json:"size"`
	ModTime     int64  `json:"modTime"` // Unix timestamp for faster JSON serialization
	Permissions string `json:"permissions"`
}

// listDirectoryBasic provides the same interface as Windows version but uses standard Go calls
func listDirectoryBasic(dir string) ([]BasicEntry, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	basic := make([]BasicEntry, 0, len(entries))
	for _, entry := range entries {
		name := entry.Name()
		fullPath := filepath.Join(dir, name)

		// Use entry.Info() to get file info
		info, err := entry.Info()
		if err != nil {
			continue // Skip files we can't stat
		}

		isDir := info.IsDir()

		// Basic hidden file detection for Unix systems
		isHidden := strings.HasPrefix(name, ".")

		var ext string
		if !isDir && len(name) > 0 {
			ext = strings.ToLower(strings.TrimPrefix(filepath.Ext(name), "."))
		}

		basic = append(basic, BasicEntry{
			Name:      name,
			Path:      fullPath,
			IsDir:     isDir,
			IsHidden:  isHidden,
			Extension: ext,
		})
	}

	return basic, nil
}


================================================
File: frontend/wailsjs/runtime/runtime.d.ts
================================================
/*
 _       __      _ __
| |     / /___ _(_) /____
| | /| / / __ `/ / / ___/
| |/ |/ / /_/ / / (__  )
|__/|__/\__,_/_/_/____/
The electron alternative for Go
(c) Lea Anthony 2019-present
*/

export interface Position {
    x: number;
    y: number;
}

export interface Size {
    w: number;
    h: number;
}

export interface Screen {
    isCurrent: boolean;
    isPrimary: boolean;
    width : number
    height : number
}

// Environment information such as platform, buildtype, ...
export interface EnvironmentInfo {
    buildType: string;
    platform: string;
    arch: string;
}

// [EventsEmit](https://wails.io/docs/reference/runtime/events#eventsemit)
// emits the given event. Optional data may be passed with the event.
// This will trigger any event listeners.
export function EventsEmit(eventName: string, ...data: any): void;

// [EventsOn](https://wails.io/docs/reference/runtime/events#eventson) sets up a listener for the given event name.
export function EventsOn(eventName: string, callback: (...data: any) => void): () => void;

// [EventsOnMultiple](https://wails.io/docs/reference/runtime/events#eventsonmultiple)
// sets up a listener for the given event name, but will only trigger a given number times.
export function EventsOnMultiple(eventName: string, callback: (...data: any) => void, maxCallbacks: number): () => void;

// [EventsOnce](https://wails.io/docs/reference/runtime/events#eventsonce)
// sets up a listener for the given event name, but will only trigger once.
export function EventsOnce(eventName: string, callback: (...data: any) => void): () => void;

// [EventsOff](https://wails.io/docs/reference/runtime/events#eventsoff)
// unregisters the listener for the given event name.
export function EventsOff(eventName: string, ...additionalEventNames: string[]): void;

// [EventsOffAll](https://wails.io/docs/reference/runtime/events#eventsoffall)
// unregisters all listeners.
export function EventsOffAll(): void;

// [LogPrint](https://wails.io/docs/reference/runtime/log#logprint)
// logs the given message as a raw message
export function LogPrint(message: string): void;

// [LogTrace](https://wails.io/docs/reference/runtime/log#logtrace)
// logs the given message at the `trace` log level.
export function LogTrace(message: string): void;

// [LogDebug](https://wails.io/docs/reference/runtime/log#logdebug)
// logs the given message at the `debug` log level.
export function LogDebug(message: string): void;

// [LogError](https://wails.io/docs/reference/runtime/log#logerror)
// logs the given message at the `error` log level.
export function LogError(message: string): void;

// [LogFatal](https://wails.io/docs/reference/runtime/log#logfatal)
// logs the given message at the `fatal` log level.
// The application will quit after calling this method.
export function LogFatal(message: string): void;

// [LogInfo](https://wails.io/docs/reference/runtime/log#loginfo)
// logs the given message at the `info` log level.
export function LogInfo(message: string): void;

// [LogWarning](https://wails.io/docs/reference/runtime/log#logwarning)
// logs the given message at the `warning` log level.
export function LogWarning(message: string): void;

// [WindowReload](https://wails.io/docs/reference/runtime/window#windowreload)
// Forces a reload by the main application as well as connected browsers.
export function WindowReload(): void;

// [WindowReloadApp](https://wails.io/docs/reference/runtime/window#windowreloadapp)
// Reloads the application frontend.
export function WindowReloadApp(): void;

// [WindowSetAlwaysOnTop](https://wails.io/docs/reference/runtime/window#windowsetalwaysontop)
// Sets the window AlwaysOnTop or not on top.
export function WindowSetAlwaysOnTop(b: boolean): void;

// [WindowSetSystemDefaultTheme](https://wails.io/docs/next/reference/runtime/window#windowsetsystemdefaulttheme)
// *Windows only*
// Sets window theme to system default (dark/light).
export function WindowSetSystemDefaultTheme(): void;

// [WindowSetLightTheme](https://wails.io/docs/next/reference/runtime/window#windowsetlighttheme)
// *Windows only*
// Sets window to light theme.
export function WindowSetLightTheme(): void;

// [WindowSetDarkTheme](https://wails.io/docs/next/reference/runtime/window#windowsetdarktheme)
// *Windows only*
// Sets window to dark theme.
export function WindowSetDarkTheme(): void;

// [WindowCenter](https://wails.io/docs/reference/runtime/window#windowcenter)
// Centers the window on the monitor the window is currently on.
export function WindowCenter(): void;

// [WindowSetTitle](https://wails.io/docs/reference/runtime/window#windowsettitle)
// Sets the text in the window title bar.
export function WindowSetTitle(title: string): void;

// [WindowFullscreen](https://wails.io/docs/reference/runtime/window#windowfullscreen)
// Makes the window full screen.
export function WindowFullscreen(): void;

// [WindowUnfullscreen](https://wails.io/docs/reference/runtime/window#windowunfullscreen)
// Restores the previous window dimensions and position prior to full screen.
export function WindowUnfullscreen(): void;

// [WindowIsFullscreen](https://wails.io/docs/reference/runtime/window#windowisfullscreen)
// Returns the state of the window, i.e. whether the window is in full screen mode or not.
export function WindowIsFullscreen(): Promise<boolean>;

// [WindowSetSize](https://wails.io/docs/reference/runtime/window#windowsetsize)
// Sets the width and height of the window.
export function WindowSetSize(width: number, height: number): void;

// [WindowGetSize](https://wails.io/docs/reference/runtime/window#windowgetsize)
// Gets the width and height of the window.
export function WindowGetSize(): Promise<Size>;

// [WindowSetMaxSize](https://wails.io/docs/reference/runtime/window#windowsetmaxsize)
// Sets the maximum window size. Will resize the window if the window is currently larger than the given dimensions.
// Setting a size of 0,0 will disable this constraint.
export function WindowSetMaxSize(width: number, height: number): void;

// [WindowSetMinSize](https://wails.io/docs/reference/runtime/window#windowsetminsize)
// Sets the minimum window size. Will resize the window if the window is currently smaller than the given dimensions.
// Setting a size of 0,0 will disable this constraint.
export function WindowSetMinSize(width: number, height: number): void;

// [WindowSetPosition](https://wails.io/docs/reference/runtime/window#windowsetposition)
// Sets the window position relative to the monitor the window is currently on.
export function WindowSetPosition(x: number, y: number): void;

// [WindowGetPosition](https://wails.io/docs/reference/runtime/window#windowgetposition)
// Gets the window position relative to the monitor the window is currently on.
export function WindowGetPosition(): Promise<Position>;

// [WindowHide](https://wails.io/docs/reference/runtime/window#windowhide)
// Hides the window.
export function WindowHide(): void;

// [WindowShow](https://wails.io/docs/reference/runtime/window#windowshow)
// Shows the window, if it is currently hidden.
export function WindowShow(): void;

// [WindowMaximise](https://wails.io/docs/reference/runtime/window#windowmaximise)
// Maximises the window to fill the screen.
export function WindowMaximise(): void;

// [WindowToggleMaximise](https://wails.io/docs/reference/runtime/window#windowtogglemaximise)
// Toggles between Maximised and UnMaximised.
export function WindowToggleMaximise(): void;

// [WindowUnmaximise](https://wails.io/docs/reference/runtime/window#windowunmaximise)
// Restores the window to the dimensions and position prior to maximising.
export function WindowUnmaximise(): void;

// [WindowIsMaximised](https://wails.io/docs/reference/runtime/window#windowismaximised)
// Returns the state of the window, i.e. whether the window is maximised or not.
export function WindowIsMaximised(): Promise<boolean>;

// [WindowMinimise](https://wails.io/docs/reference/runtime/window#windowminimise)
// Minimises the window.
export function WindowMinimise(): void;

// [WindowUnminimise](https://wails.io/docs/reference/runtime/window#windowunminimise)
// Restores the window to the dimensions and position prior to minimising.
export function WindowUnminimise(): void;

// [WindowIsMinimised](https://wails.io/docs/reference/runtime/window#windowisminimised)
// Returns the state of the window, i.e. whether the window is minimised or not.
export function WindowIsMinimised(): Promise<boolean>;

// [WindowIsNormal](https://wails.io/docs/reference/runtime/window#windowisnormal)
// Returns the state of the window, i.e. whether the window is normal or not.
export function WindowIsNormal(): Promise<boolean>;

// [WindowSetBackgroundColour](https://wails.io/docs/reference/runtime/window#windowsetbackgroundcolour)
// Sets the background colour of the window to the given RGBA colour definition. This colour will show through for all transparent pixels.
export function WindowSetBackgroundColour(R: number, G: number, B: number, A: number): void;

// [ScreenGetAll](https://wails.io/docs/reference/runtime/window#screengetall)
// Gets the all screens. Call this anew each time you want to refresh data from the underlying windowing system.
export function ScreenGetAll(): Promise<Screen[]>;

// [BrowserOpenURL](https://wails.io/docs/reference/runtime/browser#browseropenurl)
// Opens the given URL in the system browser.
export function BrowserOpenURL(url: string): void;

// [Environment](https://wails.io/docs/reference/runtime/intro#environment)
// Returns information about the environment
export function Environment(): Promise<EnvironmentInfo>;

// [Quit](https://wails.io/docs/reference/runtime/intro#quit)
// Quits the application.
export function Quit(): void;

// [Hide](https://wails.io/docs/reference/runtime/intro#hide)
// Hides the application.
export function Hide(): void;

// [Show](https://wails.io/docs/reference/runtime/intro#show)
// Shows the application.
export function Show(): void;

// [ClipboardGetText](https://wails.io/docs/reference/runtime/clipboard#clipboardgettext)
// Returns the current text stored on clipboard
export function ClipboardGetText(): Promise<string>;

// [ClipboardSetText](https://wails.io/docs/reference/runtime/clipboard#clipboardsettext)
// Sets a text on the clipboard
export function ClipboardSetText(text: string): Promise<boolean>;

// [OnFileDrop](https://wails.io/docs/reference/runtime/draganddrop#onfiledrop)
// OnFileDrop listens to drag and drop events and calls the callback with the coordinates of the drop and an array of path strings.
export function OnFileDrop(callback: (x: number, y: number ,paths: string[]) => void, useDropTarget: boolean) :void

// [OnFileDropOff](https://wails.io/docs/reference/runtime/draganddrop#dragandddropoff)
// OnFileDropOff removes the drag and drop listeners and handlers.
export function OnFileDropOff() :void

// Check if the file path resolver is available
export function CanResolveFilePaths(): boolean;

// Resolves file paths for an array of files
export function ResolveFilePaths(files: File[]): void

================================================
File: backend/app.go
================================================
package backend

import (
	"context"
	"log"
)

// NewApp creates a new App application struct with dependency injection
func NewApp() *App {
	// Create all manager instances
	platform := NewPlatformManager()
	filesystem := NewFileSystemManager(platform)
	fileOps := NewFileOperationsManager(platform)
	drives := NewDriveManager()
	terminal := NewTerminalManager()

	return &App{
		filesystem: filesystem,
		fileOps:    fileOps,
		platform:   platform,
		drives:     drives,
		terminal:   terminal,
	}
}

// Startup is called when the app starts. The context is saved
// so we can call the runtime methods
func (a *App) Startup(ctx context.Context) {
	a.ctx = ctx

	// Set context on filesystem manager for event emission
	if fsManager, ok := a.filesystem.(*FileSystemManager); ok {
		fsManager.SetContext(ctx)
	}

	log.Println("🚀 Lightning Explorer backend started with modular architecture")
}

// API Methods for Wails Frontend

// GetHomeDirectory returns the user's home directory
func (a *App) GetHomeDirectory() string {
	return a.platform.GetHomeDirectory()
}

// GetCurrentWorkingDirectory returns the current working directory
func (a *App) GetCurrentWorkingDirectory() string {
	return a.platform.GetCurrentWorkingDirectory()
}

// GetSystemRoots returns system root paths (drives on Windows, / on Unix)
func (a *App) GetSystemRoots() []string {
	return a.platform.GetSystemRoots()
}

// NavigateToPath navigates to a specific path
func (a *App) NavigateToPath(path string) NavigationResponse {
	return a.filesystem.NavigateToPath(path)
}

// NavigateUp navigates to the parent directory
func (a *App) NavigateUp(currentPath string) NavigationResponse {
	return a.filesystem.NavigateUp(currentPath)
}

// ListDirectory lists the contents of a directory
func (a *App) ListDirectory(path string) NavigationResponse {
	return a.filesystem.ListDirectory(path)
}

// GetFileDetails returns detailed information about a file
func (a *App) GetFileDetails(filePath string) FileInfo {
	fileInfo, err := a.filesystem.GetFileInfo(filePath)
	if err != nil {
		log.Printf("Error getting file details: %v", err)
		return FileInfo{}
	}
	return fileInfo
}

// OpenFile opens a file with its default application
func (a *App) OpenFile(filePath string) bool {
	return a.fileOps.OpenFile(filePath)
}

// OpenInSystemExplorer opens the given path in the system's default file manager
func (a *App) OpenInSystemExplorer(path string) bool {
	return a.platform.OpenInSystemExplorer(path)
}

// CopyFiles copies files from source paths to destination directory
func (a *App) CopyFiles(sourcePaths []string, destDir string) bool {
	return a.fileOps.CopyFiles(sourcePaths, destDir)
}

// MoveFiles moves files from source paths to destination directory
func (a *App) MoveFiles(sourcePaths []string, destDir string) bool {
	return a.fileOps.MoveFiles(sourcePaths, destDir)
}

// DeleteFiles permanently deletes the specified files and directories
func (a *App) DeleteFiles(filePaths []string) bool {
	return a.fileOps.DeleteFiles(filePaths)
}

// MoveFilesToRecycleBin moves files to the system recycle bin/trash
func (a *App) MoveFilesToRecycleBin(filePaths []string) bool {
	return a.fileOps.MoveFilesToRecycleBin(filePaths)
}

// RenameFile renames a file or directory
func (a *App) RenameFile(oldPath, newName string) bool {
	return a.fileOps.RenameFile(oldPath, newName)
}

// HideFiles sets the hidden attribute on the specified files
func (a *App) HideFiles(filePaths []string) bool {
	return a.fileOps.HideFiles(filePaths)
}

// CreateDirectory creates a new directory
func (a *App) CreateDirectory(path, name string) NavigationResponse {
	return a.filesystem.CreateDirectory(path, name)
}

// DeletePath deletes a file or directory (alias for compatibility)
func (a *App) DeletePath(path string) NavigationResponse {
	success := a.fileOps.DeleteFiles([]string{path})
	if success {
		return NavigationResponse{
			Success: true,
			Message: "Item deleted successfully",
		}
	}
	return NavigationResponse{
		Success: false,
		Message: "Failed to delete item",
	}
}

// GetDriveInfo returns information about available drives
func (a *App) GetDriveInfo() []map[string]interface{} {
	drives := a.drives.GetDriveInfo()

	// Convert to the expected format for backward compatibility
	var result []map[string]interface{}
	for _, drive := range drives {
		result = append(result, map[string]interface{}{
			"path":   drive.Path,
			"letter": drive.Letter,
			"name":   drive.Name,
		})
	}

	return result
}

// OpenPowerShellHere opens PowerShell 7 in the specified directory
func (a *App) OpenPowerShellHere(directoryPath string) bool {
	return a.terminal.OpenPowerShellHere(directoryPath)
}

// FormatFileSize formats file size in human readable format
func (a *App) FormatFileSize(size int64) string {
	return a.platform.FormatFileSize(size)
}

// Additional API methods for enhanced functionality

// GetQuickAccessPaths returns commonly accessed directories for quick navigation
func (a *App) GetQuickAccessPaths() []map[string]interface{} {
	paths := a.drives.GetQuickAccessPaths()

	var result []map[string]interface{}
	for _, path := range paths {
		result = append(result, map[string]interface{}{
			"path":   path.Path,
			"letter": path.Letter,
			"name":   path.Name,
		})
	}

	return result
}

// OpenTerminalHere opens the system's default terminal in the specified directory
func (a *App) OpenTerminalHere(directoryPath string) bool {
	return a.terminal.OpenTerminalHere(directoryPath)
}

// GetAvailableTerminals returns a list of available terminal applications
func (a *App) GetAvailableTerminals() []string {
	return a.terminal.GetAvailableTerminals()
}

// ValidatePath checks if a path is valid and accessible
func (a *App) ValidatePath(path string) bool {
	err := a.filesystem.ValidatePath(path)
	return err == nil
}

// FileExists checks if a file exists
func (a *App) FileExists(path string) bool {
	return a.filesystem.FileExists(path)
}

// IsHidden checks if a file/directory is hidden
func (a *App) IsHidden(path string) bool {
	return a.platform.IsHidden(path)
}

// ExecuteCommand executes a command in the background (useful for scripts)
func (a *App) ExecuteCommand(command string, workingDir string) bool {
	err := a.terminal.ExecuteCommand(command, workingDir)
	return err == nil
}

// Health check method for monitoring
func (a *App) HealthCheck() map[string]interface{} {
	return map[string]interface{}{
		"status":  "healthy",
		"modules": []string{"filesystem", "fileops", "platform", "drives", "terminal"},
	}
}

// PrefetchDirectory pre-loads directory contents for faster navigation
// This method is called when hovering over folders to improve perceived performance
func (a *App) PrefetchDirectory(path string) NavigationResponse {
	// Use the same method as NavigateToPath but mark it as prefetch for logging
	log.Printf("🔄 Prefetching directory: %s", path)

	response := a.filesystem.ListDirectory(path)

	if response.Success {
		log.Printf("✅ Prefetched directory %s: %d files, %d dirs",
			path, response.Data.TotalFiles, response.Data.TotalDirs)
	} else {
		log.Printf("❌ Failed to prefetch directory %s: %s", path, response.Message)
	}

	return response
}


================================================
File: go.mod
================================================
module lightning_explorer

go 1.23

require github.com/wailsapp/wails/v2 v2.10.1

require (
	github.com/bep/debounce v1.2.1 // indirect
	github.com/go-ole/go-ole v1.3.0 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e // indirect
	github.com/labstack/echo/v4 v4.13.3 // indirect
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/leaanthony/go-ansi-parser v1.6.1 // indirect
	github.com/leaanthony/gosod v1.0.4 // indirect
	github.com/leaanthony/slicer v1.6.0 // indirect
	github.com/leaanthony/u v1.1.1 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/samber/lo v1.49.1 // indirect
	github.com/tkrajina/go-reflector v0.5.8 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	github.com/wailsapp/go-webview2 v1.0.19 // indirect
	github.com/wailsapp/mimetype v1.4.1 // indirect
	golang.org/x/crypto v0.33.0 // indirect
	golang.org/x/net v0.35.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.22.0 // indirect
)

// replace github.com/wailsapp/wails/v2 v2.10.1 => C:\Users\andrewzhuang\go\pkg\mod


================================================
File: frontend/src/style.css
================================================
/* Local JetBrains Mono Font */
@font-face {
  font-family: 'JetBrains Mono';
  src: url('./assets/fonts/JetBrainsMono-Regular.ttf') format('truetype');
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Zen Minimalist Theme - Modern & Spacious */
:root {
  /* Base colors - Calm and zen */
  --zen-bg: #fafafa;
  --zen-surface: #ffffff;
  --zen-surface-elevated: #ffffff;
  --zen-surface-hover: #f8f9fa;
  --zen-surface-active: #f1f3f4;
  
  /* Primary accent - Soft and calming */
  --zen-primary: #4f46e5;
  --zen-primary-light: #6366f1;
  --zen-primary-alpha: rgba(79, 70, 229, 0.08);
  --zen-primary-alpha-hover: rgba(79, 70, 229, 0.12);
  
  /* Borders and dividers - Very subtle */
  --zen-border: #e5e7eb;
  --zen-border-light: #f3f4f6;
  --zen-border-focus: #d1d5db;
  
  /* Text hierarchy - Clear and readable */
  --zen-text-primary: #111827;
  --zen-text-secondary: #6b7280;
  --zen-text-tertiary: #9ca3af;
  --zen-text-inverse: #ffffff;
  
  /* Status colors - Soft and non-intrusive */
  --zen-success: #059669;
  --zen-warning: #d97706;
  --zen-error: #dc2626;
  --zen-info: #0284c7;
  
  /* Shadows - Gentle and zen */
  --zen-shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
  --zen-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
  --zen-shadow-md: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
  --zen-shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1), 0 4px 6px rgba(0, 0, 0, 0.05);
  
  /* Spacing scale - Generous and consistent */
  --zen-space-xs: 0.25rem;  /* 4px */
  --zen-space-sm: 0.5rem;   /* 8px */
  --zen-space-md: 0.75rem;  /* 12px */
  --zen-space-lg: 1rem;     /* 16px */
  --zen-space-xl: 1.5rem;   /* 24px */
  --zen-space-2xl: 2rem;    /* 32px */
  --zen-space-3xl: 3rem;    /* 48px */
  
  /* Typography scale */
  --zen-text-xs: 0.75rem;   /* 12px */
  --zen-text-sm: 0.875rem;  /* 14px */
  --zen-text-base: 1rem;    /* 16px */
  --zen-text-lg: 1.125rem;  /* 18px */
  --zen-text-xl: 1.25rem;   /* 20px */
  --zen-text-2xl: 1.5rem;   /* 24px */
  
  /* Radius scale */
  --zen-radius-sm: 0.25rem; /* 4px */
  --zen-radius: 0.375rem;   /* 6px */
  --zen-radius-md: 0.5rem;  /* 8px */
  --zen-radius-lg: 0.75rem; /* 12px */
}

/* Base styles with better defaults */
* {
  box-sizing: border-box;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-touch-callout: none;
  -webkit-tap-highlight-color: transparent;
}

body {
  margin: 0;
  padding: 0;
  font-family: 'JetBrains Mono', ui-monospace, 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
  font-size: var(--zen-text-sm);
  line-height: 1.5;
  background: var(--zen-bg);
  color: var(--zen-text-primary);
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* Performance optimizations */
.file-explorer,
.file-list {
  will-change: scroll-position;
  transform: translateZ(0);
}

/* Main layout structure - More spacious */
.file-explorer {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background: var(--zen-bg);
}

/* Header - Clean and spacious */
.app-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--zen-space-lg) var(--zen-space-xl);
  background: var(--zen-surface);
  border-bottom: 1px solid var(--zen-border-light);
  min-height: 4rem;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

.app-title {
  font-size: var(--zen-text-xl);
  font-weight: 600;
  color: var(--zen-text-primary);
  margin: 0;
  letter-spacing: -0.025em;
}

/* Main content area - Better proportions */
.main-content {
  display: flex;
  flex: 1;
  min-height: 0;
  background: var(--zen-bg);
}

/* Sidebar - More refined */
.sidebar {
  width: 240px;
  background: var(--zen-surface);
  border-right: 1px solid var(--zen-border-light);
  display: flex;
  flex-direction: column;
  padding: var(--zen-space-lg);
  gap: var(--zen-space-xl);
}

.sidebar-section {
  display: flex;
  flex-direction: column;
  gap: var(--zen-space-sm);
}

.sidebar-title {
  font-size: var(--zen-text-xs);
  font-weight: 600;
  color: var(--zen-text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  margin-bottom: var(--zen-space-sm);
}

.sidebar-item {
  display: flex;
  align-items: center;
  gap: var(--zen-space-md);
  padding: var(--zen-space-md) var(--zen-space-lg);
  border-radius: var(--zen-radius);
  color: var(--zen-text-secondary);
  cursor: pointer;
  transition: all 150ms ease;
  font-size: var(--zen-text-sm);
  min-height: 2.5rem;
}

.sidebar-item:hover:not(.active) {
  background: var(--zen-surface-hover);
  color: var(--zen-text-primary);
  transform: translateX(2px);
}

.sidebar-item.active {
  background: var(--zen-primary-alpha);
  color: var(--zen-primary);
  font-weight: 500;
}

.sidebar-icon {
  width: 1.25rem;
  height: 1.25rem;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

/* Content area - Spacious and clean */
.content-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  background: var(--zen-surface);
}

/* Toolbar - Modern and spacious */
.toolbar {
  display: flex;
  align-items: center;
  gap: var(--zen-space-sm);
  padding: var(--zen-space-lg) var(--zen-space-xl);
  background: var(--zen-surface);
  border-bottom: 1px solid var(--zen-border-light);
  min-height: 3.5rem;
}

.toolbar-btn {
  display: flex;
  align-items: center;
  gap: var(--zen-space-sm);
  padding: var(--zen-space-sm) var(--zen-space-lg);
  background: transparent;
  border: 1px solid var(--zen-border);
  border-radius: var(--zen-radius);
  color: var(--zen-text-secondary);
  font-size: var(--zen-text-sm);
  font-family: inherit;
  cursor: pointer;
  transition: all 150ms ease;
  min-height: 2.25rem;
  font-weight: 500;
}

.toolbar-btn:hover:not(:disabled) {
  background: var(--zen-surface-hover);
  border-color: var(--zen-border-focus);
  color: var(--zen-text-primary);
  transform: translateY(-1px);
  box-shadow: var(--zen-shadow-sm);
}

.toolbar-btn:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: none;
}

.toolbar-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.toolbar-btn.active {
  background: var(--zen-primary-alpha);
  border-color: var(--zen-primary);
  color: var(--zen-primary);
}

/* Breadcrumb navigation - Clean and clickable */
.nav-breadcrumb {
  display: flex;
  align-items: center;
  gap: 0;
  padding: var(--zen-space-lg) var(--zen-space-xl);
  background: var(--zen-surface);
  border-bottom: 1px solid var(--zen-border-light);
  font-size: var(--zen-text-sm);
  min-height: 3rem;
  overflow-x: auto;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.nav-breadcrumb::-webkit-scrollbar {
  display: none;
}

.breadcrumb-segment-wrapper {
  display: flex;
  align-items: center;
  flex-shrink: 0;
}

.nav-segment {
  display: inline-flex;
  align-items: center;
  padding: var(--zen-space-sm) var(--zen-space-md);
  border-radius: var(--zen-radius-sm);
  color: var(--zen-text-secondary);
  cursor: pointer;
  transition: all 150ms ease;
  white-space: nowrap;
  font-weight: 500;
  user-select: none;
  max-width: 200px;
  overflow: hidden;
  text-overflow: ellipsis;
}

.nav-segment:hover {
  background: var(--zen-surface-hover);
  color: var(--zen-text-primary);
  transform: translateY(-1px);
}

.nav-segment.current {
  color: var(--zen-primary);
  font-weight: 600;
  background: var(--zen-primary-alpha);
}

.separator {
  color: var(--zen-text-tertiary);
  margin: 0 var(--zen-space-sm);
  font-size: var(--zen-text-xs);
  font-weight: 400;
  flex-shrink: 0;
}

/* File list container - Spacious and clean */
.file-list-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  background: var(--zen-surface);
}

.file-list {
  flex: 1;
  overflow-y: auto;
  padding: var(--zen-space-xl);
  gap: var(--zen-space-sm);
  display: flex;
  flex-direction: column;
}

/* File items - Much more spacious and refined */
.file-item {
  display: flex;
  align-items: center;
  gap: var(--zen-space-lg);
  padding: var(--zen-space-lg);
  border-radius: var(--zen-radius-md);
  cursor: pointer;
  transition: background-color 150ms ease, border-color 150ms ease, color 150ms ease, opacity 150ms ease;
  border: 1px solid transparent;
  min-height: 3.5rem;
  background: transparent;
  box-sizing: border-box;
}

.file-item:hover:not(.selected) {
  background: var(--zen-surface-hover);
  border-color: var(--zen-border);
  /* More prominent but contained visual feedback */
  background: rgba(79, 70, 229, 0.04);
}

.file-item.selected {
  background: var(--zen-primary-alpha);
  border-color: var(--zen-primary);
  color: var(--zen-primary);
  /* Removed transform and box-shadow to prevent expansion over other files */
}

.file-item.selected:hover {
  background: var(--zen-primary-alpha-hover);
  border-color: var(--zen-primary);
  /* Pure color-based feedback - no dimension changes */
}

.file-item:active {
  /* Removed scale transform to prevent expansion over other files */
  opacity: 0.8;
}

.file-item.cut {
  opacity: 0.6;
  filter: grayscale(30%);
  border-style: dashed;
}

/* File icons - More refined */
.file-icon {
  width: 2rem;
  height: 2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--zen-radius);
  font-size: var(--zen-text-sm);
  flex-shrink: 0;
  font-weight: 600;
}

.file-icon.folder {
  background: var(--zen-primary);
  color: var(--zen-text-inverse);
}

.file-icon.file {
  background: var(--zen-surface-hover);
  color: var(--zen-text-secondary);
  border: 1px solid var(--zen-border);
}

.file-icon.code {
  background: var(--zen-success);
  color: var(--zen-text-inverse);
}

.file-icon.image {
  background: var(--zen-warning);
  color: var(--zen-text-inverse);
}

.file-icon.document {
  background: var(--zen-info);
  color: var(--zen-text-inverse);
}

.file-icon.archive {
  background: var(--zen-text-secondary);
  color: var(--zen-text-inverse);
}

.file-icon.executable {
  background: var(--zen-error);
  color: var(--zen-text-inverse);
}

/* File details - Better typography */
.file-details {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: var(--zen-space-xs);
  min-width: 0;
}

.file-name {
  font-size: var(--zen-text-sm);
  font-weight: 500;
  color: inherit;
  margin: 0;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.file-meta {
  font-size: var(--zen-text-xs);
  color: var(--zen-text-tertiary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

/* Status bar - Clean and informative */
.status-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--zen-space-md) var(--zen-space-xl);
  background: var(--zen-surface);
  border-top: 1px solid var(--zen-border-light);
  font-size: var(--zen-text-xs);
  color: var(--zen-text-secondary);
  min-height: 2.5rem;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

/* Error message - Non-intrusive */
.error-message {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--zen-space-lg) var(--zen-space-xl);
  background: rgba(239, 68, 68, 0.1);
  border-left: 4px solid var(--zen-error);
  color: var(--zen-error);
  font-size: var(--zen-text-sm);
  margin: var(--zen-space-lg);
  border-radius: var(--zen-radius);
}

/* Loading states - Gentle and zen */
.loading-overlay {
  display: flex;
  align-items: center;
  justify-content: center;
  flex: 1;
  background: var(--zen-surface);
}

.loading-spinner {
  width: 1.5rem;
  height: 1.5rem;
  border: 2px solid var(--zen-border);
  border-top: 2px solid var(--zen-primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Empty state - Zen and calming */
.empty-directory {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  gap: var(--zen-space-lg);
  color: var(--zen-text-tertiary);
  font-size: var(--zen-text-sm);
}

.empty-directory-icon {
  font-size: 3rem;
  opacity: 0.5;
}

/* Context menus - Modern and clean */
.context-menu,
.empty-space-context-menu {
  position: fixed;
  background: var(--zen-surface);
  border: 1px solid var(--zen-border);
  border-radius: var(--zen-radius-md);
  box-shadow: var(--zen-shadow-lg);
  z-index: 1000;
  min-width: 200px;
  padding: var(--zen-space-sm);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
}

.context-menu-item {
  display: flex;
  align-items: center;
  gap: var(--zen-space-md);
  padding: var(--zen-space-md) var(--zen-space-lg);
  border-radius: var(--zen-radius);
  cursor: pointer;
  transition: all 150ms ease;
  font-size: var(--zen-text-sm);
  color: var(--zen-text-secondary);
  min-height: 2.5rem;
}

.context-menu-item:hover {
  background: var(--zen-surface-hover);
  color: var(--zen-text-primary);
}

.context-menu-item:active {
  background: var(--zen-surface-active);
}

.context-menu-icon {
  width: 1rem;
  height: 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.context-menu-separator {
  height: 1px;
  background: var(--zen-border-light);
  margin: var(--zen-space-sm) 0;
}

/* Custom scrollbar - Minimal and zen */
.custom-scrollbar::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: transparent;
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: var(--zen-border);
  border-radius: 3px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: var(--zen-border-focus);
}

/* Text utilities */
.text-technical {
  font-family: inherit;
  font-size: var(--zen-text-xs);
  color: var(--zen-text-tertiary);
  font-weight: 500;
}

/* Drag and drop states */
.file-item.drag-over {
  background: var(--zen-primary-alpha-hover);
  border-color: var(--zen-primary);
  /* Pure color-based feedback - no dimension changes */
}

.file-item.dragging {
  opacity: 0.6;
  /* Removed rotation and scale to prevent expansion over other files */
  filter: grayscale(50%);
}

.file-explorer.dragging-active {
  cursor: grabbing;
}

/* Folder creation input */
.folder-name-input {
  background: var(--zen-surface);
  border: 2px solid var(--zen-primary);
  border-radius: var(--zen-radius);
  padding: var(--zen-space-md) var(--zen-space-lg);
  font-family: inherit;
  font-size: var(--zen-text-sm);
  color: var(--zen-text-primary);
  min-height: 2.5rem;
  transition: all 150ms ease;
}

.folder-name-input:focus {
  outline: none;
  border-color: var(--zen-primary);
  box-shadow: 0 0 0 3px var(--zen-primary-alpha);
}

/* Responsive design */
@media (max-width: 768px) {
  .main-content {
    flex-direction: column;
  }
  
  .sidebar {
    width: 100%;
    height: auto;
    border-right: none;
    border-bottom: 1px solid var(--zen-border-light);
  }
  
  .toolbar {
    flex-wrap: wrap;
    gap: var(--zen-space-xs);
  }
  
  .app-header {
    padding: var(--zen-space-md) var(--zen-space-lg);
  }
  
  .file-list {
    padding: var(--zen-space-lg);
  }
}

@media (max-width: 480px) {
  .file-item {
    padding: var(--zen-space-md);
    gap: var(--zen-space-md);
    min-height: 3rem;
  }
  
  .file-icon {
    width: 1.5rem;
    height: 1.5rem;
  }
  
  .toolbar-btn {
    padding: var(--zen-space-sm) var(--zen-space-md);
    font-size: var(--zen-text-xs);
  }
}

/* Accessibility improvements */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

@media (prefers-contrast: high) {
  :root {
    --zen-border: #000000;
    --zen-text-secondary: #000000;
    --zen-primary: #0000ff;
  }
}

/* Focus states for accessibility */
.toolbar-btn:focus-visible,
.sidebar-item:focus-visible,
.nav-segment:focus-visible,
.file-item:focus-visible {
  outline: 2px solid var(--zen-primary);
  outline-offset: 2px;
}

/* Print styles */
@media print {
  .toolbar,
  .sidebar,
  .status-bar {
    display: none;
  }
  
  .main-content {
    flex-direction: column;
  }
  
 .file-list {
    background: white;
    color: black;
  }
}


================================================
File: wails.json
================================================
{
  "$schema": "https://wails.io/schemas/config.v2.json",
  "name": "lightning_explorer",
  "outputfilename": "lightning_explorer",
  "frontend:install": "bun install",
  "frontend:build": "bun run build",
  "frontend:dev:watcher": "bun run dev",
  "frontend:dev:serverUrl": "auto",
  "author": {
    "name": "YourAverageDev",
    "email": "andrewzhuangyue@hotmail.com"
  }
}


================================================
File: go.sum
================================================
github.com/bep/debounce v1.2.1 h1:v67fRdBA9UQu2NhLFXrSg0Brw7CexQekrBwDMM8bzeY=
github.com/bep/debounce v1.2.1/go.mod h1:H8yggRPQKLUhUoqrJC1bO2xNya7vanpDl7xR3ISbCJ0=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/go-ole/go-ole v1.3.0 h1:Dt6ye7+vXGIKZ7Xtk4s6/xVdGDQynvom7xCFEdWr6uE=
github.com/go-ole/go-ole v1.3.0/go.mod h1:5LS6F96DhAwUc7C+1HLexzMXY1xGRSryjyPPKW6zv78=
github.com/godbus/dbus/v5 v5.1.0 h1:4KLkAxT3aOY8Li4FRJe/KvhoNFFxo0m6fNuFUO8QJUk=
github.com/godbus/dbus/v5 v5.1.0/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e h1:Q3+PugElBCf4PFpxhErSzU3/PY5sFL5Z6rfv4AbGAck=
github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e/go.mod h1:alcuEEnZsY1WQsagKhZDsoPCRoOijYqhZvPwLG0kzVs=
github.com/labstack/echo/v4 v4.13.3 h1:pwhpCPrTl5qry5HRdM5FwdXnhXSLSY+WE+YQSeCaafY=
github.com/labstack/echo/v4 v4.13.3/go.mod h1:o90YNEeQWjDozo584l7AwhJMHN0bOC4tAfg+Xox9q5g=
github.com/labstack/gommon v0.4.2 h1:F8qTUNXgG1+6WQmqoUWnz8WiEU60mXVVw0P4ht1WRA0=
github.com/labstack/gommon v0.4.2/go.mod h1:QlUFxVM+SNXhDL/Z7YhocGIBYOiwB0mXm1+1bAPHPyU=
github.com/leaanthony/debme v1.2.1 h1:9Tgwf+kjcrbMQ4WnPcEIUcQuIZYqdWftzZkBr+i/oOc=
github.com/leaanthony/debme v1.2.1/go.mod h1:3V+sCm5tYAgQymvSOfYQ5Xx2JCr+OXiD9Jkw3otUjiA=
github.com/leaanthony/go-ansi-parser v1.6.1 h1:xd8bzARK3dErqkPFtoF9F3/HgN8UQk0ed1YDKpEz01A=
github.com/leaanthony/go-ansi-parser v1.6.1/go.mod h1:+vva/2y4alzVmmIEpk9QDhA7vLC5zKDTRwfZGOp3IWU=
github.com/leaanthony/gosod v1.0.4 h1:YLAbVyd591MRffDgxUOU1NwLhT9T1/YiwjKZpkNFeaI=
github.com/leaanthony/gosod v1.0.4/go.mod h1:GKuIL0zzPj3O1SdWQOdgURSuhkF+Urizzxh26t9f1cw=
github.com/leaanthony/slicer v1.6.0 h1:1RFP5uiPJvT93TAHi+ipd3NACobkW53yUiBqZheE/Js=
github.com/leaanthony/slicer v1.6.0/go.mod h1:o/Iz29g7LN0GqH3aMjWAe90381nyZlDNquK+mtH2Fj8=
github.com/leaanthony/u v1.1.1 h1:TUFjwDGlNX+WuwVEzDqQwC2lOv0P4uhTQw7CMFdiK7M=
github.com/leaanthony/u v1.1.1/go.mod h1:9+o6hejoRljvZ3BzdYlVL0JYCwtnAsVuN9pVTQcaRfI=
github.com/matryer/is v1.4.0/go.mod h1:8I/i5uYgLzgsgEloJE1U6xx5HkBQpAZvepWuujKwMRU=
github.com/matryer/is v1.4.1 h1:55ehd8zaGABKLXQUe2awZ99BD/PTc2ls+KV/dXphgEQ=
github.com/matryer/is v1.4.1/go.mod h1:8I/i5uYgLzgsgEloJE1U6xx5HkBQpAZvepWuujKwMRU=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c h1:+mdjkGKdHQG3305AYmdv1U2eRNDiU2ErMBj1gwrq8eQ=
github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c/go.mod h1:7rwL4CYBLnjLxUqIJNnCWiEdr3bn6IUYi15bNlnbCCU=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/samber/lo v1.49.1 h1:4BIFyVfuQSEpluc7Fua+j1NolZHiEHEpaSEKdsH0tew=
github.com/samber/lo v1.49.1/go.mod h1:dO6KHFzUKXgP8LDhU0oI8d2hekjXnGOu0DB8Jecxd6o=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/tkrajina/go-reflector v0.5.8 h1:yPADHrwmUbMq4RGEyaOUpz2H90sRsETNVpjzo3DLVQQ=
github.com/tkrajina/go-reflector v0.5.8/go.mod h1:ECbqLgccecY5kPmPmXg1MrHW585yMcDkVl6IvJe64T4=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasttemplate v1.2.2 h1:lxLXG0uE3Qnshl9QyaK6XJxMXlQZELvChBOCmQD0Loo=
github.com/valyala/fasttemplate v1.2.2/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=
github.com/wailsapp/go-webview2 v1.0.19 h1:7U3QcDj1PrBPaxJNCui2k1SkWml+Q5kvFUFyTImA6NU=
github.com/wailsapp/go-webview2 v1.0.19/go.mod h1:qJmWAmAmaniuKGZPWwne+uor3AHMB5PFhqiK0Bbj8kc=
github.com/wailsapp/mimetype v1.4.1 h1:pQN9ycO7uo4vsUUuPeHEYoUkLVkaRntMnHJxVwYhwHs=
github.com/wailsapp/mimetype v1.4.1/go.mod h1:9aV5k31bBOv5z6u+QP8TltzvNGJPmNJD4XlAL3U+j3o=
github.com/wailsapp/wails/v2 v2.10.1 h1:QWHvWMXII2nI/nXz77gpPG8P3ehl6zKe+u4su5BWIns=
github.com/wailsapp/wails/v2 v2.10.1/go.mod h1:zrebnFV6MQf9kx8HI4iAv63vsR5v67oS7GTEZ7Pz1TY=
golang.org/x/crypto v0.33.0 h1:IOBPskki6Lysi0lo9qQvbxiQ+FvsCC/YWOecCHAixus=
golang.org/x/crypto v0.33.0/go.mod h1:bVdXmD7IV/4GdElGPozy6U7lWdRXA4qyRVGJV57uQ5M=
golang.org/x/net v0.0.0-20210505024714-0287a6fb4125/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.35.0 h1:T5GQRQb2y08kTAByq9L4/bz8cipCdA8FbRTXewonqY8=
golang.org/x/net v0.35.0/go.mod h1:EglIi67kWsHKlRzzVMUD93VMSWGFOMSZgxFjparz1Qk=
golang.org/x/sys v0.0.0-20200810151505-1b9f1253b3ed/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=
golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.22.0 h1:bofq7m3/HAFvbF51jz3Q9wLg3jkvSPuiZu/pD1XwgtM=
golang.org/x/text v0.22.0/go.mod h1:YRoo4H8PVmsu+E3Ou7cqLVH8oXWIHVoX0jqUWALQhfY=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


