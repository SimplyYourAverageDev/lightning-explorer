================================================
File: .gitignore
================================================
build/*
node_modules
frontend/dist
frontend/bun.lock
frontend/package-lock.json

================================================
File: frontend/postcss.config.js
================================================
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


================================================
File: frontend/package.json
================================================
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "preact": "^10.10.1"
  },
  "devDependencies": {
    "@preact/preset-vite": "^2.3.0",
    "autoprefixer": "^10.4.21",
    "postcss": "^8.5.4",
    "tailwindcss": "3",
    "vite": "^3.0.7"
  }
}

================================================
File: frontend/package.json.md5
================================================
c3da20351cdc630bf29b545cce8f1b8d

================================================
File: .cursor/rules/ui-design-rule.mdc
================================================
---
description: 
globs: 
alwaysApply: true
---
In the frontend, all UI components—including context menus—should adopt an 8-bit retro style while retaining a minimalist, zen aesthetic. Use bold, blocky visuals consistent with classic 8-bit design, keep layouts clean and uncluttered, avoid using bright neon "hacker" green (#00ff00); choose alternative retro colors instead.

================================================
File: frontend/src/assets/fonts/OFL.txt
================================================
Copyright 2016 The Nunito Project Authors (contact@sansoxygen.com),

This Font Software is licensed under the SIL Open Font License, Version 1.1.
This license is copied below, and is also available with a FAQ at:
http://scripts.sil.org/OFL


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.


================================================
File: backend/filesystem.go
================================================
package backend

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"time"
)

// NewFileSystemManager creates a new filesystem manager instance
func NewFileSystemManager(cache CacheManagerInterface, platform PlatformManagerInterface) *FileSystemManager {
	return &FileSystemManager{
		cache:    cache,
		platform: platform,
	}
}

// ListDirectory lists the contents of a directory with performance optimizations
func (fs *FileSystemManager) ListDirectory(path string) NavigationResponse {
	startTime := time.Now()
	log.Printf("📂 Listing directory: %s", path)

	if path == "" {
		path = fs.platform.GetHomeDirectory()
	}

	// Clean and validate path - optimized for Windows
	path = filepath.Clean(path)

	// Quick existence check first
	info, err := os.Stat(path)
	if err != nil {
		return NavigationResponse{
			Success: false,
			Message: fmt.Sprintf("Cannot access path: %v", err),
		}
	}

	if !info.IsDir() {
		return NavigationResponse{
			Success: false,
			Message: "Path is not a directory",
		}
	}

	// Check cache first with mod time validation
	cached, exists := fs.cache.Get(path)
	if exists {
		// Validate cache against actual mod time for accuracy
		if cached.ModTime.Equal(info.ModTime()) || cached.ModTime.After(info.ModTime()) {
			cacheTime := time.Since(startTime)
			log.Printf("⚡ Cache hit for %s in %v", path, cacheTime)
			return NavigationResponse{
				Success: true,
				Message: fmt.Sprintf("Directory listed successfully (cached in %v)", cacheTime),
				Data:    cached.Contents,
			}
		} else {
			log.Printf("🔄 Cache invalidated for %s (mod time changed)", path)
		}
	}

	// Read directory entries
	entries, err := os.ReadDir(path)
	if err != nil {
		return NavigationResponse{
			Success: false,
			Message: fmt.Sprintf("Cannot read directory: %v", err),
		}
	}

	// Pre-allocate slices with better size estimation
	totalEntries := len(entries)
	// Use actual directory/file ratio heuristics (usually 20-30% directories)
	estimatedDirs := totalEntries / 4
	estimatedFiles := totalEntries - estimatedDirs

	files := make([]FileInfo, 0, estimatedFiles)
	directories := make([]FileInfo, 0, estimatedDirs)

	// Optimized processing based on directory size
	if totalEntries > 50 { // Lower threshold for concurrent processing
		files, directories = fs.processEntriesConcurrent(path, entries)
	} else {
		// Process entries synchronously for small directories (faster for small dirs)
		files, directories = fs.processEntriesSync(path, entries, files, directories)
	}

	// Optimized sorting using string comparison with locale awareness
	sort.Slice(directories, func(i, j int) bool {
		return strings.ToLower(directories[i].Name) < strings.ToLower(directories[j].Name)
	})
	sort.Slice(files, func(i, j int) bool {
		return strings.ToLower(files[i].Name) < strings.ToLower(files[j].Name)
	})

	// Get parent path efficiently
	parentPath := filepath.Dir(path)
	if parentPath == path {
		parentPath = "" // At root
	}

	contents := DirectoryContents{
		CurrentPath: path,
		ParentPath:  parentPath,
		Files:       files,
		Directories: directories,
		TotalFiles:  len(files),
		TotalDirs:   len(directories),
	}

	// Cache the results immediately for future use
	fs.cache.Set(path, &CacheEntry{
		Contents:  contents,
		Timestamp: time.Now(),
		ModTime:   info.ModTime(),
	})

	processingTime := time.Since(startTime)
	log.Printf("✅ Directory listed in %v: %s (%d dirs, %d files)", processingTime, path, len(directories), len(files))

	return NavigationResponse{
		Success: true,
		Message: fmt.Sprintf("Directory listed successfully in %v", processingTime),
		Data:    contents,
	}
}

// processEntriesSync processes directory entries synchronously with optimizations
func (fs *FileSystemManager) processEntriesSync(path string, entries []os.DirEntry, files, directories []FileInfo) ([]FileInfo, []FileInfo) {
	for _, entry := range entries {
		// Skip processing certain system files early for performance
		name := entry.Name()
		if fs.shouldSkipFile(name) {
			continue
		}

		fileInfo := fs.CreateFileInfoOptimized(path, name, entry)

		if fileInfo.IsDir {
			directories = append(directories, fileInfo)
		} else {
			files = append(files, fileInfo)
		}
	}
	return files, directories
}

// processEntriesConcurrent processes directory entries concurrently with worker pool
func (fs *FileSystemManager) processEntriesConcurrent(path string, entries []os.DirEntry) ([]FileInfo, []FileInfo) {
	// Optimized worker pool size based on entry count and CPU cores
	numWorkers := 6 // Sweet spot for most systems
	if len(entries) < 200 {
		numWorkers = 3
	}

	type workItem struct {
		entry os.DirEntry
		index int
	}

	type result struct {
		fileInfo FileInfo
		isDir    bool
		index    int
	}

	entryChan := make(chan workItem, len(entries))
	resultChan := make(chan result, len(entries))

	// Start worker goroutines
	var wg sync.WaitGroup
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for item := range entryChan {
				// Skip certain files early
				if fs.shouldSkipFile(item.entry.Name()) {
					continue
				}

				fileInfo := fs.CreateFileInfoOptimized(path, item.entry.Name(), item.entry)
				resultChan <- result{
					fileInfo: fileInfo,
					isDir:    fileInfo.IsDir,
					index:    item.index,
				}
			}
		}()
	}

	// Send work items
	go func() {
		defer close(entryChan)
		for i, entry := range entries {
			entryChan <- workItem{entry: entry, index: i}
		}
	}()

	// Close result channel when all workers are done
	go func() {
		wg.Wait()
		close(resultChan)
	}()

	// Collect results
	files := make([]FileInfo, 0, len(entries)/2)
	directories := make([]FileInfo, 0, len(entries)/2)

	for res := range resultChan {
		if res.isDir {
			directories = append(directories, res.fileInfo)
		} else {
			files = append(files, res.fileInfo)
		}
	}

	return files, directories
}

// shouldSkipFile determines if a file should be skipped for performance
func (fs *FileSystemManager) shouldSkipFile(name string) bool {
	// Skip certain system files that are typically not needed
	skipPatterns := []string{
		"$RECYCLE.BIN",
		"System Volume Information",
		"pagefile.sys",
		"hiberfil.sys",
		"swapfile.sys",
		".DS_Store",
		".Trashes",
		".Spotlight-V100",
	}

	for _, pattern := range skipPatterns {
		if strings.EqualFold(name, pattern) {
			return true
		}
	}

	return false
}

// CreateFileInfoOptimized creates FileInfo with performance optimizations
func (fs *FileSystemManager) CreateFileInfoOptimized(basePath string, name string, entry os.DirEntry) FileInfo {
	fullPath := filepath.Join(basePath, name)

	// Use DirEntry info when possible to avoid extra stat calls
	var info os.FileInfo
	var err error

	if entry != nil {
		info, err = entry.Info()
	} else {
		info, err = os.Stat(fullPath)
	}

	if err != nil {
		log.Printf("Warning: Error getting file info for %s: %v", fullPath, err)
		// Return basic info even on error
		return FileInfo{
			Name:     name,
			Path:     fullPath,
			IsDir:    entry != nil && entry.IsDir(),
			IsHidden: fs.platform.IsHidden(fullPath),
		}
	}

	return FileInfo{
		Name:        name,
		Path:        fullPath,
		IsDir:       info.IsDir(),
		Size:        info.Size(),
		ModTime:     info.ModTime(),
		Permissions: info.Mode().String(),
		Extension:   fs.platform.GetExtension(name),
		IsHidden:    fs.platform.IsHidden(fullPath),
	}
}

// CreateFileInfo creates FileInfo from file path and name (backward compatibility)
func (fs *FileSystemManager) CreateFileInfo(basePath string, name string) FileInfo {
	return fs.CreateFileInfoOptimized(basePath, name, nil)
}

// GetFileInfo returns detailed information about a specific file
func (fs *FileSystemManager) GetFileInfo(filePath string) (FileInfo, error) {
	log.Printf("Getting file details for: %s", filePath)

	info, err := os.Stat(filePath)
	if err != nil {
		log.Printf("Error getting file details: %v", err)
		return FileInfo{}, err
	}

	return FileInfo{
		Name:        filepath.Base(filePath),
		Path:        filePath,
		IsDir:       info.IsDir(),
		Size:        info.Size(),
		ModTime:     info.ModTime(),
		Permissions: info.Mode().String(),
		Extension:   fs.platform.GetExtension(filepath.Base(filePath)),
		IsHidden:    fs.platform.IsHidden(filePath),
	}, nil
}

// IsHidden checks if a file/directory is hidden
func (fs *FileSystemManager) IsHidden(path string) bool {
	return fs.platform.IsHidden(path)
}

// GetExtension returns the file extension
func (fs *FileSystemManager) GetExtension(name string) string {
	return fs.platform.GetExtension(name)
}

// NavigateToPath navigates to a specific path with enhanced logging
func (fs *FileSystemManager) NavigateToPath(path string) NavigationResponse {
	log.Printf("🧭 Navigation request: %s", path)
	return fs.ListDirectory(path)
}

// NavigateUp navigates to the parent directory with path validation
func (fs *FileSystemManager) NavigateUp(currentPath string) NavigationResponse {
	if currentPath == "" {
		return NavigationResponse{
			Success: false,
			Message: "No current path provided",
		}
	}

	parentPath := filepath.Dir(currentPath)
	if parentPath == currentPath {
		// Already at root
		return NavigationResponse{
			Success: false,
			Message: "Already at root directory",
		}
	}

	log.Printf("⬆️ Navigate up: %s -> %s", currentPath, parentPath)
	return fs.ListDirectory(parentPath)
}

// FileExists checks if a file exists
func (fs *FileSystemManager) FileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

// CreateDirectory creates a new directory with cache invalidation
func (fs *FileSystemManager) CreateDirectory(path, name string) NavigationResponse {
	fullPath := filepath.Join(path, name)

	err := os.MkdirAll(fullPath, 0755)
	if err != nil {
		return NavigationResponse{
			Success: false,
			Message: fmt.Sprintf("Failed to create directory: %v", err),
		}
	}

	// Clear cache for the parent directory to refresh the listing
	fs.cache.Clear()

	log.Printf("📁 Directory created: %s", fullPath)
	return NavigationResponse{
		Success: true,
		Message: "Directory created successfully",
	}
}

// ValidatePath checks if a path is valid and accessible with optimized validation
func (fs *FileSystemManager) ValidatePath(path string) error {
	if path == "" {
		return fmt.Errorf("path cannot be empty")
	}

	info, err := os.Stat(path)
	if err != nil {
		return fmt.Errorf("cannot access path: %v", err)
	}

	if !info.IsDir() {
		return fmt.Errorf("path is not a directory")
	}

	return nil
}


================================================
File: backend/app.go
================================================
package backend

import (
	"context"
	"log"
)

// NewApp creates a new App application struct with dependency injection
func NewApp() *App {
	// Create all manager instances
	cache := NewCacheManager()
	platform := NewPlatformManager()
	filesystem := NewFileSystemManager(cache, platform)
	fileOps := NewFileOperationsManager(cache, platform)
	drives := NewDriveManager()
	terminal := NewTerminalManager()

	return &App{
		cache:      cache,
		filesystem: filesystem,
		fileOps:    fileOps,
		platform:   platform,
		drives:     drives,
		terminal:   terminal,
	}
}

// Startup is called when the app starts. The context is saved
// so we can call the runtime methods
func (a *App) Startup(ctx context.Context) {
	a.ctx = ctx
	log.Println("🚀 Blueprint File Explorer backend started with modular architecture")
}

// API Methods for Wails Frontend

// GetHomeDirectory returns the user's home directory
func (a *App) GetHomeDirectory() string {
	return a.platform.GetHomeDirectory()
}

// GetCurrentWorkingDirectory returns the current working directory
func (a *App) GetCurrentWorkingDirectory() string {
	return a.platform.GetCurrentWorkingDirectory()
}

// GetSystemRoots returns system root paths (drives on Windows, / on Unix)
func (a *App) GetSystemRoots() []string {
	return a.platform.GetSystemRoots()
}

// NavigateToPath navigates to a specific path
func (a *App) NavigateToPath(path string) NavigationResponse {
	return a.filesystem.NavigateToPath(path)
}

// NavigateUp navigates to the parent directory
func (a *App) NavigateUp(currentPath string) NavigationResponse {
	return a.filesystem.NavigateUp(currentPath)
}

// ListDirectory lists the contents of a directory
func (a *App) ListDirectory(path string) NavigationResponse {
	return a.filesystem.ListDirectory(path)
}

// GetFileDetails returns detailed information about a file
func (a *App) GetFileDetails(filePath string) FileInfo {
	fileInfo, err := a.filesystem.GetFileInfo(filePath)
	if err != nil {
		log.Printf("Error getting file details: %v", err)
		return FileInfo{}
	}
	return fileInfo
}

// OpenFile opens a file with its default application
func (a *App) OpenFile(filePath string) bool {
	return a.fileOps.OpenFile(filePath)
}

// OpenInSystemExplorer opens the given path in the system's default file manager
func (a *App) OpenInSystemExplorer(path string) bool {
	return a.platform.OpenInSystemExplorer(path)
}

// CopyFiles copies files from source paths to destination directory
func (a *App) CopyFiles(sourcePaths []string, destDir string) bool {
	return a.fileOps.CopyFiles(sourcePaths, destDir)
}

// MoveFiles moves files from source paths to destination directory
func (a *App) MoveFiles(sourcePaths []string, destDir string) bool {
	return a.fileOps.MoveFiles(sourcePaths, destDir)
}

// DeleteFiles permanently deletes the specified files and directories
func (a *App) DeleteFiles(filePaths []string) bool {
	return a.fileOps.DeleteFiles(filePaths)
}

// MoveFilesToRecycleBin moves files to the system recycle bin/trash
func (a *App) MoveFilesToRecycleBin(filePaths []string) bool {
	return a.fileOps.MoveFilesToRecycleBin(filePaths)
}

// RenameFile renames a file or directory
func (a *App) RenameFile(oldPath, newName string) bool {
	return a.fileOps.RenameFile(oldPath, newName)
}

// HideFiles sets the hidden attribute on the specified files
func (a *App) HideFiles(filePaths []string) bool {
	return a.fileOps.HideFiles(filePaths)
}

// CreateDirectory creates a new directory
func (a *App) CreateDirectory(path, name string) NavigationResponse {
	return a.filesystem.CreateDirectory(path, name)
}

// DeletePath deletes a file or directory (alias for compatibility)
func (a *App) DeletePath(path string) NavigationResponse {
	success := a.fileOps.DeleteFiles([]string{path})
	if success {
		return NavigationResponse{
			Success: true,
			Message: "Item deleted successfully",
		}
	}
	return NavigationResponse{
		Success: false,
		Message: "Failed to delete item",
	}
}

// GetDriveInfo returns information about available drives
func (a *App) GetDriveInfo() []map[string]interface{} {
	drives := a.drives.GetDriveInfo()

	// Convert to the expected format for backward compatibility
	var result []map[string]interface{}
	for _, drive := range drives {
		result = append(result, map[string]interface{}{
			"path":   drive.Path,
			"letter": drive.Letter,
			"name":   drive.Name,
		})
	}

	return result
}

// OpenPowerShellHere opens PowerShell 7 in the specified directory
func (a *App) OpenPowerShellHere(directoryPath string) bool {
	return a.terminal.OpenPowerShellHere(directoryPath)
}

// FormatFileSize formats file size in human readable format
func (a *App) FormatFileSize(size int64) string {
	return a.platform.FormatFileSize(size)
}

// Additional API methods for enhanced functionality

// GetQuickAccessPaths returns commonly accessed directories for quick navigation
func (a *App) GetQuickAccessPaths() []map[string]interface{} {
	paths := a.drives.GetQuickAccessPaths()

	var result []map[string]interface{}
	for _, path := range paths {
		result = append(result, map[string]interface{}{
			"path":   path.Path,
			"letter": path.Letter,
			"name":   path.Name,
		})
	}

	return result
}

// OpenTerminalHere opens the system's default terminal in the specified directory
func (a *App) OpenTerminalHere(directoryPath string) bool {
	return a.terminal.OpenTerminalHere(directoryPath)
}

// GetAvailableTerminals returns a list of available terminal applications
func (a *App) GetAvailableTerminals() []string {
	return a.terminal.GetAvailableTerminals()
}

// GetCacheStats returns cache statistics for debugging/monitoring
func (a *App) GetCacheStats() map[string]interface{} {
	if cacheManager, ok := a.cache.(*CacheManager); ok {
		return cacheManager.GetCacheStats()
	}
	return map[string]interface{}{"error": "Cache manager not available"}
}

// ClearCache clears the directory cache
func (a *App) ClearCache() {
	a.cache.Clear()
	log.Println("🧹 Directory cache cleared manually")
}

// ValidatePath checks if a path is valid and accessible
func (a *App) ValidatePath(path string) bool {
	err := a.filesystem.ValidatePath(path)
	return err == nil
}

// FileExists checks if a file exists
func (a *App) FileExists(path string) bool {
	return a.filesystem.FileExists(path)
}

// IsHidden checks if a file/directory is hidden
func (a *App) IsHidden(path string) bool {
	return a.platform.IsHidden(path)
}

// ExecuteCommand executes a command in the background (useful for scripts)
func (a *App) ExecuteCommand(command string, workingDir string) bool {
	err := a.terminal.ExecuteCommand(command, workingDir)
	return err == nil
}

// Health check method for monitoring
func (a *App) HealthCheck() map[string]interface{} {
	return map[string]interface{}{
		"status":  "healthy",
		"cache":   a.GetCacheStats(),
		"modules": []string{"cache", "filesystem", "fileops", "platform", "drives", "terminal"},
	}
}


================================================
File: frontend/index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <meta name="description" content="Wails application with Tailwind CSS v3">
    <title>testui</title>
</head>
<body class="m-0 p-0 font-nunito antialiased">
<div id="app"></div>
<script src="./src/main.jsx" type="module"></script>
</body>
</html>



================================================
File: backend/drives.go
================================================
package backend

import (
	"fmt"
	"log"
	"os"
	"runtime"
)

// NewDriveManager creates a new drive manager instance
func NewDriveManager() *DriveManager {
	return &DriveManager{}
}

// GetDriveInfo returns information about available drives
func (d *DriveManager) GetDriveInfo() []DriveInfo {
	var drives []DriveInfo

	switch runtime.GOOS {
	case "windows":
		drives = d.getWindowsDrives()
	case "darwin":
		drives = d.getMacVolumes()
	case "linux":
		drives = d.getLinuxMountPoints()
	default:
		log.Printf("Drive enumeration not supported on %s", runtime.GOOS)
	}

	return drives
}

// getWindowsDrives returns Windows drive information
func (d *DriveManager) getWindowsDrives() []DriveInfo {
	var drives []DriveInfo

	for i := 'A'; i <= 'Z'; i++ {
		drive := fmt.Sprintf("%c:\\", i)
		if _, err := os.Stat(drive); err == nil {
			driveInfo := DriveInfo{
				Path:   drive,
				Letter: string(i),
				Name:   fmt.Sprintf("Drive %c:", i),
			}

			// Try to get more detailed drive information
			if driveType := d.getWindowsDriveType(drive); driveType != "" {
				driveInfo.Name = fmt.Sprintf("%s (%s)", driveInfo.Name, driveType)
			}

			drives = append(drives, driveInfo)
		}
	}

	return drives
}

// getWindowsDriveType gets the type of Windows drive (if possible)
func (d *DriveManager) getWindowsDriveType(drive string) string {
	// This is a simplified implementation
	// In a more advanced version, you could use Windows API calls
	// to get detailed drive information like volume labels, types, etc.

	// For now, we'll just return empty string
	// Future enhancement: Use syscalls to get actual drive type
	return ""
}

// getMacVolumes returns macOS volume information
func (d *DriveManager) getMacVolumes() []DriveInfo {
	var drives []DriveInfo

	// Add root volume
	drives = append(drives, DriveInfo{
		Path:   "/",
		Letter: "",
		Name:   "Macintosh HD",
	})

	// Add /Volumes if it exists
	if _, err := os.Stat("/Volumes"); err == nil {
		if entries, err := os.ReadDir("/Volumes"); err == nil {
			for _, entry := range entries {
				if entry.IsDir() {
					volumePath := fmt.Sprintf("/Volumes/%s", entry.Name())
					drives = append(drives, DriveInfo{
						Path:   volumePath,
						Letter: "",
						Name:   entry.Name(),
					})
				}
			}
		}
	}

	return drives
}

// getLinuxMountPoints returns Linux mount point information
func (d *DriveManager) getLinuxMountPoints() []DriveInfo {
	var drives []DriveInfo

	// Add root filesystem
	drives = append(drives, DriveInfo{
		Path:   "/",
		Letter: "",
		Name:   "Root Filesystem",
	})

	// Add common mount points
	commonMounts := []struct {
		path string
		name string
	}{
		{"/home", "Home"},
		{"/media", "Media"},
		{"/mnt", "Mount"},
		{"/opt", "Optional"},
		{"/usr", "User Programs"},
		{"/var", "Variable Data"},
	}

	for _, mount := range commonMounts {
		if _, err := os.Stat(mount.path); err == nil {
			drives = append(drives, DriveInfo{
				Path:   mount.path,
				Letter: "",
				Name:   mount.name,
			})
		}
	}

	return drives
}

// GetSystemRoots returns system root paths for quick navigation
func (d *DriveManager) GetSystemRoots() []string {
	var roots []string

	switch runtime.GOOS {
	case "windows":
		// Get all available drive letters
		for i := 'A'; i <= 'Z'; i++ {
			drive := fmt.Sprintf("%c:\\", i)
			if _, err := os.Stat(drive); err == nil {
				roots = append(roots, drive)
			}
		}
	default:
		// Unix-like systems start from root
		roots = append(roots, "/")
	}

	return roots
}

// GetQuickAccessPaths returns commonly accessed directories for quick navigation
func (d *DriveManager) GetQuickAccessPaths() []DriveInfo {
	var quickPaths []DriveInfo

	switch runtime.GOOS {
	case "windows":
		quickPaths = d.getWindowsQuickAccess()
	case "darwin":
		quickPaths = d.getMacQuickAccess()
	case "linux":
		quickPaths = d.getLinuxQuickAccess()
	}

	return quickPaths
}

// getWindowsQuickAccess returns Windows quick access paths
func (d *DriveManager) getWindowsQuickAccess() []DriveInfo {
	var quickPaths []DriveInfo

	// Get common Windows directories
	homeDir, _ := os.UserHomeDir()

	commonPaths := []struct {
		path string
		name string
	}{
		{homeDir, "Home"},
		{fmt.Sprintf("%s\\Desktop", homeDir), "Desktop"},
		{fmt.Sprintf("%s\\Documents", homeDir), "Documents"},
		{fmt.Sprintf("%s\\Downloads", homeDir), "Downloads"},
		{fmt.Sprintf("%s\\Pictures", homeDir), "Pictures"},
		{fmt.Sprintf("%s\\Music", homeDir), "Music"},
		{fmt.Sprintf("%s\\Videos", homeDir), "Videos"},
		{"C:\\Program Files", "Program Files"},
		{"C:\\Program Files (x86)", "Program Files (x86)"},
		{"C:\\Windows", "Windows"},
	}

	for _, path := range commonPaths {
		if _, err := os.Stat(path.path); err == nil {
			quickPaths = append(quickPaths, DriveInfo{
				Path:   path.path,
				Letter: "",
				Name:   path.name,
			})
		}
	}

	return quickPaths
}

// getMacQuickAccess returns macOS quick access paths
func (d *DriveManager) getMacQuickAccess() []DriveInfo {
	var quickPaths []DriveInfo

	homeDir, _ := os.UserHomeDir()

	commonPaths := []struct {
		path string
		name string
	}{
		{homeDir, "Home"},
		{fmt.Sprintf("%s/Desktop", homeDir), "Desktop"},
		{fmt.Sprintf("%s/Documents", homeDir), "Documents"},
		{fmt.Sprintf("%s/Downloads", homeDir), "Downloads"},
		{fmt.Sprintf("%s/Pictures", homeDir), "Pictures"},
		{fmt.Sprintf("%s/Music", homeDir), "Music"},
		{fmt.Sprintf("%s/Movies", homeDir), "Movies"},
		{"/Applications", "Applications"},
		{"/System", "System"},
		{"/Users", "Users"},
	}

	for _, path := range commonPaths {
		if _, err := os.Stat(path.path); err == nil {
			quickPaths = append(quickPaths, DriveInfo{
				Path:   path.path,
				Letter: "",
				Name:   path.name,
			})
		}
	}

	return quickPaths
}

// getLinuxQuickAccess returns Linux quick access paths
func (d *DriveManager) getLinuxQuickAccess() []DriveInfo {
	var quickPaths []DriveInfo

	homeDir, _ := os.UserHomeDir()

	commonPaths := []struct {
		path string
		name string
	}{
		{homeDir, "Home"},
		{fmt.Sprintf("%s/Desktop", homeDir), "Desktop"},
		{fmt.Sprintf("%s/Documents", homeDir), "Documents"},
		{fmt.Sprintf("%s/Downloads", homeDir), "Downloads"},
		{fmt.Sprintf("%s/Pictures", homeDir), "Pictures"},
		{fmt.Sprintf("%s/Music", homeDir), "Music"},
		{fmt.Sprintf("%s/Videos", homeDir), "Videos"},
		{"/usr", "User Programs"},
		{"/opt", "Optional Software"},
		{"/etc", "Configuration"},
		{"/var", "Variable Data"},
	}

	for _, path := range commonPaths {
		if _, err := os.Stat(path.path); err == nil {
			quickPaths = append(quickPaths, DriveInfo{
				Path:   path.path,
				Letter: "",
				Name:   path.name,
			})
		}
	}

	return quickPaths
}


================================================
File: backend/terminal.go
================================================
package backend

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"runtime"
	"strings"
	"syscall"
)

// NewTerminalManager creates a new terminal manager instance
func NewTerminalManager() *TerminalManager {
	return &TerminalManager{}
}

// OpenPowerShellHere opens PowerShell 7 in the specified directory
func (t *TerminalManager) OpenPowerShellHere(directoryPath string) bool {
	log.Printf("Opening PowerShell 7 in directory: %s", directoryPath)

	// Validate the directory path
	if directoryPath == "" {
		log.Printf("Error: Empty directory path provided")
		return false
	}

	// Check if directory exists
	if _, err := os.Stat(directoryPath); os.IsNotExist(err) {
		log.Printf("Error: Directory does not exist: %s", directoryPath)
		return false
	}

	return t.openWindowsTerminal(directoryPath)
}

// OpenTerminalHere opens the system's default terminal in the specified directory
func (t *TerminalManager) OpenTerminalHere(directoryPath string) bool {
	log.Printf("Opening terminal in directory: %s", directoryPath)

	// Validate the directory path
	if directoryPath == "" {
		log.Printf("Error: Empty directory path provided")
		return false
	}

	// Check if directory exists
	if _, err := os.Stat(directoryPath); os.IsNotExist(err) {
		log.Printf("Error: Directory does not exist: %s", directoryPath)
		return false
	}

	switch runtime.GOOS {
	case "windows":
		return t.openWindowsTerminal(directoryPath)
	case "darwin":
		return t.openMacTerminal(directoryPath)
	case "linux":
		return t.openLinuxTerminal(directoryPath)
	default:
		log.Printf("Unsupported operating system: %s", runtime.GOOS)
		return false
	}
}

// openWindowsTerminal opens PowerShell in Windows
func (t *TerminalManager) openWindowsTerminal(directoryPath string) bool {
	// PowerShell 7 executable path
	pwshPath := "C:\\Program Files\\PowerShell\\7\\pwsh.exe"

	// Check if PowerShell 7 exists, fallback to Windows PowerShell if not
	if _, err := os.Stat(pwshPath); os.IsNotExist(err) {
		log.Printf("PowerShell 7 not found, falling back to Windows PowerShell")
		pwshPath = "powershell.exe"
	}

	log.Printf("Using PowerShell executable: %s", pwshPath)

	// Use the most reliable method: -NoExit without -Command, just set working directory
	cmd := exec.Command(pwshPath, "-NoExit")

	// Set the working directory for the process - this is the key!
	cmd.Dir = directoryPath

	// Create new console window that stays open
	cmd.SysProcAttr = &syscall.SysProcAttr{
		HideWindow:    false,      // We want to show PowerShell window
		CreationFlags: 0x00000010, // CREATE_NEW_CONSOLE - create new console window
	}

	log.Printf("PowerShell command: %s %v in directory: %s", pwshPath, cmd.Args[1:], directoryPath)

	// Start the command
	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening PowerShell: %v", err)
		return false
	}

	log.Printf("Successfully opened PowerShell in directory: %s", directoryPath)
	return true
}

// openMacTerminal opens Terminal in macOS
func (t *TerminalManager) openMacTerminal(directoryPath string) bool {
	// macOS: Open Terminal with the specified directory
	cmd := exec.Command("osascript", "-e", fmt.Sprintf(`tell app "Terminal" to do script "cd '%s'"`, directoryPath))

	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening macOS Terminal: %v", err)
		return false
	}

	log.Printf("Successfully opened Terminal in directory: %s", directoryPath)
	return true
}

// openLinuxTerminal opens terminal in Linux
func (t *TerminalManager) openLinuxTerminal(directoryPath string) bool {
	// Linux: Try to open terminal in the directory
	// Try different terminal emulators in order of preference
	terminals := [][]string{
		{"gnome-terminal", "--working-directory", directoryPath},
		{"konsole", "--workdir", directoryPath},
		{"xfce4-terminal", "--working-directory", directoryPath},
		{"xterm", "-e", fmt.Sprintf("cd '%s' && bash", directoryPath)},
		{"urxvt", "-e", fmt.Sprintf("bash -c 'cd \"%s\" && bash'", directoryPath)},
		{"terminator", "--working-directory", directoryPath},
	}

	for _, terminalCmd := range terminals {
		if _, err := exec.LookPath(terminalCmd[0]); err == nil {
			cmd := exec.Command(terminalCmd[0], terminalCmd[1:]...)
			err := cmd.Start()
			if err == nil {
				log.Printf("Successfully opened %s in directory: %s", terminalCmd[0], directoryPath)
				return true
			}
			log.Printf("Failed to open %s: %v", terminalCmd[0], err)
		}
	}

	log.Printf("No suitable terminal emulator found")
	return false
}

// OpenCommandPromptHere opens Command Prompt in Windows (alternative to PowerShell)
func (t *TerminalManager) OpenCommandPromptHere(directoryPath string) bool {
	if runtime.GOOS != "windows" {
		log.Printf("Command Prompt is only available on Windows")
		return false
	}

	log.Printf("Opening Command Prompt in directory: %s", directoryPath)

	// Validate the directory path
	if directoryPath == "" {
		log.Printf("Error: Empty directory path provided")
		return false
	}

	// Check if directory exists
	if _, err := os.Stat(directoryPath); os.IsNotExist(err) {
		log.Printf("Error: Directory does not exist: %s", directoryPath)
		return false
	}

	// Open Command Prompt with specific directory
	cmd := exec.Command("cmd.exe", "/K", fmt.Sprintf("cd /d \"%s\"", directoryPath))

	// Create new console window
	cmd.SysProcAttr = &syscall.SysProcAttr{
		HideWindow:    false,
		CreationFlags: 0x00000010, // CREATE_NEW_CONSOLE
	}

	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening Command Prompt: %v", err)
		return false
	}

	log.Printf("Successfully opened Command Prompt in directory: %s", directoryPath)
	return true
}

// OpenWindowsTerminalApp opens Windows Terminal app (if available)
func (t *TerminalManager) OpenWindowsTerminalApp(directoryPath string) bool {
	if runtime.GOOS != "windows" {
		log.Printf("Windows Terminal is only available on Windows")
		return false
	}

	log.Printf("Opening Windows Terminal app in directory: %s", directoryPath)

	// Check if Windows Terminal is available
	cmd := exec.Command("wt.exe", "-d", directoryPath)

	err := cmd.Start()
	if err != nil {
		log.Printf("Windows Terminal not available, error: %v", err)
		// Fallback to PowerShell
		return t.openWindowsTerminal(directoryPath)
	}

	log.Printf("Successfully opened Windows Terminal app in directory: %s", directoryPath)
	return true
}

// GetAvailableTerminals returns a list of available terminal applications
func (t *TerminalManager) GetAvailableTerminals() []string {
	var terminals []string

	switch runtime.GOOS {
	case "windows":
		// Check for Windows terminals
		windowsTerminals := []struct {
			path string
			name string
		}{
			{"C:\\Program Files\\PowerShell\\7\\pwsh.exe", "PowerShell 7"},
			{"powershell.exe", "Windows PowerShell"},
			{"cmd.exe", "Command Prompt"},
			{"wt.exe", "Windows Terminal"},
		}

		for _, term := range windowsTerminals {
			if term.name == "Windows Terminal" {
				// Special check for Windows Terminal using wt.exe
				if _, err := exec.LookPath("wt.exe"); err == nil {
					terminals = append(terminals, term.name)
				}
			} else if _, err := os.Stat(term.path); err == nil || term.name == "Windows PowerShell" || term.name == "Command Prompt" {
				terminals = append(terminals, term.name)
			}
		}

	case "darwin":
		// macOS terminals
		terminals = append(terminals, "Terminal")

		// Check for additional terminals
		macTerminals := []string{"iTerm", "Hyper", "Alacritty"}
		for _, term := range macTerminals {
			if _, err := exec.LookPath(strings.ToLower(term)); err == nil {
				terminals = append(terminals, term)
			}
		}

	case "linux":
		// Linux terminals
		linuxTerminals := []string{
			"gnome-terminal", "konsole", "xfce4-terminal", "xterm",
			"urxvt", "terminator", "alacritty", "kitty", "tilix",
		}

		for _, term := range linuxTerminals {
			if _, err := exec.LookPath(term); err == nil {
				terminals = append(terminals, term)
			}
		}
	}

	return terminals
}

// ExecuteCommand executes a command in the background (useful for scripts)
func (t *TerminalManager) ExecuteCommand(command string, workingDir string) error {
	log.Printf("Executing command: %s in directory: %s", command, workingDir)

	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "windows":
		cmd = exec.Command("cmd", "/C", command)
	default:
		cmd = exec.Command("sh", "-c", command)
	}

	if workingDir != "" {
		cmd.Dir = workingDir
	}

	// Run the command and capture output
	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("Command execution failed: %v, output: %s", err, string(output))
		return err
	}

	log.Printf("Command executed successfully, output: %s", string(output))
	return nil
}


================================================
File: backend/fileops.go
================================================
package backend

import (
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

// NewFileOperationsManager creates a new file operations manager instance
func NewFileOperationsManager(cache CacheManagerInterface, platform PlatformManagerInterface) *FileOperationsManager {
	return &FileOperationsManager{
		cache:    cache,
		platform: platform,
	}
}

// CopyFiles copies files from source paths to destination directory
func (fo *FileOperationsManager) CopyFiles(sourcePaths []string, destDir string) bool {
	log.Printf("Copying %d files to: %s", len(sourcePaths), destDir)

	for _, srcPath := range sourcePaths {
		srcInfo, err := os.Stat(srcPath)
		if err != nil {
			log.Printf("Error getting source file info: %v", err)
			return false
		}

		destPath := filepath.Join(destDir, filepath.Base(srcPath))

		if srcInfo.IsDir() {
			err = fo.copyDir(srcPath, destPath)
		} else {
			err = fo.copyFile(srcPath, destPath)
		}

		if err != nil {
			log.Printf("Error copying %s: %v", srcPath, err)
			return false
		}

		// Verify the copy was successful
		if _, err := os.Stat(destPath); err != nil {
			log.Printf("Copy verification failed for %s: %v", destPath, err)
			return false
		}
	}

	log.Printf("Successfully copied %d files to %s", len(sourcePaths), destDir)
	fo.cache.Clear() // Clear cache to ensure fresh data
	return true
}

// MoveFiles moves files from source paths to destination directory
func (fo *FileOperationsManager) MoveFiles(sourcePaths []string, destDir string) bool {
	log.Printf("Moving %d files to: %s", len(sourcePaths), destDir)

	for _, srcPath := range sourcePaths {
		destPath := filepath.Join(destDir, filepath.Base(srcPath))

		err := os.Rename(srcPath, destPath)
		if err != nil {
			// If rename fails, try copy + delete (for cross-drive moves)
			if err := fo.copyAndDelete(srcPath, destPath); err != nil {
				log.Printf("Error moving %s: %v", srcPath, err)
				return false
			}
		}

		// Verify the move was successful
		if _, err := os.Stat(destPath); err != nil {
			log.Printf("Move verification failed for %s: %v", destPath, err)
			return false
		}
	}

	log.Printf("Successfully moved %d files to %s", len(sourcePaths), destDir)
	fo.cache.Clear() // Clear cache to ensure fresh data
	return true
}

// DeleteFiles permanently deletes the specified files and directories
func (fo *FileOperationsManager) DeleteFiles(filePaths []string) bool {
	log.Printf("Permanently deleting %d files", len(filePaths))

	for _, filePath := range filePaths {
		err := os.RemoveAll(filePath)
		if err != nil {
			log.Printf("Error permanently deleting %s: %v", filePath, err)
			return false
		}
	}

	fo.cache.Clear() // Clear cache to ensure fresh data
	return true
}

// MoveFilesToRecycleBin moves files to the system recycle bin/trash
func (fo *FileOperationsManager) MoveFilesToRecycleBin(filePaths []string) bool {
	log.Printf("Moving %d files to recycle bin", len(filePaths))

	for _, filePath := range filePaths {
		success := fo.moveToRecycleBin(filePath)
		if !success {
			log.Printf("Error moving %s to recycle bin", filePath)
			return false
		}
	}

	fo.cache.Clear() // Clear cache to ensure fresh data
	return true
}

// RenameFile renames a file or directory
func (fo *FileOperationsManager) RenameFile(oldPath, newName string) bool {
	log.Printf("Renaming %s to %s", oldPath, newName)

	// Validate inputs
	if oldPath == "" || newName == "" {
		log.Printf("Error: Empty path or new name provided")
		return false
	}

	// Get the directory containing the file
	dir := filepath.Dir(oldPath)
	newPath := filepath.Join(dir, newName)

	// Check if old path exists
	if _, err := os.Stat(oldPath); os.IsNotExist(err) {
		log.Printf("Error: Source file does not exist: %s", oldPath)
		return false
	}

	// Check if new path already exists
	if _, err := os.Stat(newPath); err == nil {
		log.Printf("Error: Destination already exists: %s", newPath)
		return false
	}

	// Perform the rename
	err := os.Rename(oldPath, newPath)
	if err != nil {
		log.Printf("Error renaming file: %v", err)
		return false
	}

	log.Printf("Successfully renamed %s to %s", oldPath, newPath)
	fo.cache.Clear() // Clear cache to ensure fresh data
	return true
}

// HideFiles sets the hidden attribute on the specified files
func (fo *FileOperationsManager) HideFiles(filePaths []string) bool {
	log.Printf("Hiding %d files", len(filePaths))

	for _, filePath := range filePaths {
		success := fo.platform.HideFile(filePath)
		if !success {
			log.Printf("Error hiding file: %s", filePath)
			return false
		}
	}

	log.Printf("Successfully hid %d files", len(filePaths))
	fo.cache.Clear() // Clear cache to ensure fresh data
	return true
}

// OpenFile opens a file with its default application
func (fo *FileOperationsManager) OpenFile(filePath string) bool {
	return fo.platform.OpenFile(filePath)
}

// Helper methods

// copyFile copies a single file with optimized buffer size for better performance
func (fo *FileOperationsManager) copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	// Use optimized buffer size for better performance (64KB)
	buffer := make([]byte, 64*1024)
	_, err = io.CopyBuffer(destFile, sourceFile, buffer)
	if err != nil {
		return err
	}

	// Copy file permissions and timestamps
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	os.Chmod(dst, srcInfo.Mode())
	os.Chtimes(dst, srcInfo.ModTime(), srcInfo.ModTime())

	return nil
}

// copyDir recursively copies a directory with progress tracking
func (fo *FileOperationsManager) copyDir(src, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	err = os.MkdirAll(dst, srcInfo.Mode())
	if err != nil {
		return err
	}

	entries, err := os.ReadDir(src)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		srcPath := filepath.Join(src, entry.Name())
		dstPath := filepath.Join(dst, entry.Name())

		if entry.IsDir() {
			err = fo.copyDir(srcPath, dstPath)
		} else {
			err = fo.copyFile(srcPath, dstPath)
		}

		if err != nil {
			return err
		}
	}

	return nil
}

// copyAndDelete copies a file/directory then deletes the original (for cross-drive moves)
func (fo *FileOperationsManager) copyAndDelete(src, dst string) error {
	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	if srcInfo.IsDir() {
		return fo.copyDirAndDelete(src, dst)
	}

	return fo.copyFileAndDelete(src, dst)
}

// copyFileAndDelete copies a file and then deletes the original
func (fo *FileOperationsManager) copyFileAndDelete(src, dst string) error {
	err := fo.copyFile(src, dst)
	if err != nil {
		return err
	}

	return os.Remove(src)
}

// copyDirAndDelete recursively copies a directory and then deletes the original
func (fo *FileOperationsManager) copyDirAndDelete(src, dst string) error {
	err := fo.copyDir(src, dst)
	if err != nil {
		return err
	}

	return os.RemoveAll(src)
}

// moveToRecycleBin moves a single file to the recycle bin using OS-specific methods
func (fo *FileOperationsManager) moveToRecycleBin(filePath string) bool {
	switch runtime.GOOS {
	case "windows":
		return fo.moveToWindowsRecycleBin(filePath)
	case "darwin":
		return fo.moveToMacTrash(filePath)
	case "linux":
		return fo.moveToLinuxTrash(filePath)
	default:
		log.Printf("Recycle bin not supported on %s, falling back to permanent delete", runtime.GOOS)
		return os.RemoveAll(filePath) == nil
	}
}

// moveToWindowsRecycleBin moves file to Windows Recycle Bin using optimized method
func (fo *FileOperationsManager) moveToWindowsRecycleBin(filePath string) bool {
	log.Printf("Moving to Windows Recycle Bin: %s", filePath)

	// Get current user SID efficiently
	userSID, err := fo.getCurrentUserSID()
	if err != nil {
		log.Printf("Failed to get user SID: %v", err)
		return false
	}

	// Get the drive letter from the file path
	if len(filePath) < 2 || filePath[1] != ':' {
		log.Printf("Invalid file path format: %s", filePath)
		return false
	}

	driveLetter := strings.ToUpper(string(filePath[0]))
	recycleBinPath := fmt.Sprintf("%s:\\$Recycle.Bin\\%s", driveLetter, userSID)

	// Create recycle bin directory if it doesn't exist
	err = os.MkdirAll(recycleBinPath, 0755)
	if err != nil {
		log.Printf("Failed to create recycle bin directory: %v", err)
		return false
	}

	// Generate unique filename in recycle bin
	originalName := filepath.Base(filePath)
	recycleBinFile := filepath.Join(recycleBinPath, originalName)

	// Handle filename conflicts
	if fo.fileExists(recycleBinFile) {
		recycleBinFile = fo.generateUniqueRecycleBinPath(recycleBinPath, originalName)
	}

	// Move file to recycle bin
	err = os.Rename(filePath, recycleBinFile)
	if err != nil {
		// If rename fails, try copy + delete (for cross-drive moves)
		err = fo.copyAndDelete(filePath, recycleBinFile)
		if err != nil {
			log.Printf("Failed to move file to recycle bin: %v", err)
			return false
		}
	}

	log.Printf("Successfully moved to recycle bin: %s -> %s", filePath, recycleBinFile)
	return true
}

// getCurrentUserSID gets the current user's SID using optimized method
func (fo *FileOperationsManager) getCurrentUserSID() (string, error) {
	cmd := exec.Command("whoami", "/user", "/fo", "csv", "/nh")
	output, err := cmd.Output()
	if err != nil {
		return "", fmt.Errorf("whoami failed: %v", err)
	}

	// Parse CSV output: "DOMAIN\username","S-1-5-..."
	csvLine := strings.TrimSpace(string(output))
	if len(csvLine) < 10 {
		return "", fmt.Errorf("invalid whoami output: %s", csvLine)
	}

	// Extract SID from CSV (second column)
	parts := strings.Split(csvLine, ",")
	if len(parts) < 2 {
		return "", fmt.Errorf("could not parse SID from: %s", csvLine)
	}

	sid := strings.Trim(parts[1], `"`)
	if !strings.HasPrefix(sid, "S-1-5-") {
		return "", fmt.Errorf("invalid SID format: %s", sid)
	}

	return sid, nil
}

// fileExists checks if a file exists
func (fo *FileOperationsManager) fileExists(path string) bool {
	_, err := os.Stat(path)
	return !os.IsNotExist(err)
}

// generateUniqueRecycleBinPath creates a unique filename for the recycle bin
func (fo *FileOperationsManager) generateUniqueRecycleBinPath(recycleBinDir, originalName string) string {
	ext := filepath.Ext(originalName)
	nameWithoutExt := strings.TrimSuffix(originalName, ext)

	for counter := 1; counter < 1000; counter++ {
		newName := fmt.Sprintf("%s (%d)%s", nameWithoutExt, counter, ext)
		newPath := filepath.Join(recycleBinDir, newName)

		if !fo.fileExists(newPath) {
			return newPath
		}
	}

	// Fallback with timestamp if we hit 1000 conflicts
	timestamp := fmt.Sprintf("%d", time.Now().Unix())
	newName := fmt.Sprintf("%s_%s%s", nameWithoutExt, timestamp, ext)
	return filepath.Join(recycleBinDir, newName)
}

// moveToMacTrash moves file to macOS Trash
func (fo *FileOperationsManager) moveToMacTrash(filePath string) bool {
	cmd := exec.Command("osascript", "-e", fmt.Sprintf(`tell app "Finder" to delete POSIX file "%s"`, filePath))
	err := cmd.Run()
	return err == nil
}

// moveToLinuxTrash moves file to Linux trash (freedesktop.org standard)
func (fo *FileOperationsManager) moveToLinuxTrash(filePath string) bool {
	// Try using gio trash (modern method)
	cmd := exec.Command("gio", "trash", filePath)
	err := cmd.Run()

	if err != nil {
		// Fallback to gvfs-trash
		cmd = exec.Command("gvfs-trash", filePath)
		err = cmd.Run()

		if err != nil {
			// Final fallback: move to ~/.local/share/Trash
			homeDir, _ := os.UserHomeDir()
			trashDir := filepath.Join(homeDir, ".local", "share", "Trash", "files")

			// Create trash directory if it doesn't exist
			os.MkdirAll(trashDir, 0755)

			// Move file to trash
			fileName := filepath.Base(filePath)
			trashPath := filepath.Join(trashDir, fileName)

			return os.Rename(filePath, trashPath) == nil
		}
	}

	return true
}


================================================
File: backend/types.go
================================================
package backend

import (
	"context"
	"sync"
	"time"
)

// FileInfo represents file/directory information
type FileInfo struct {
	Name        string    `json:"name"`
	Path        string    `json:"path"`
	IsDir       bool      `json:"isDir"`
	Size        int64     `json:"size"`
	ModTime     time.Time `json:"modTime"`
	Permissions string    `json:"permissions"`
	Extension   string    `json:"extension"`
	IsHidden    bool      `json:"isHidden"`
}

// DirectoryContents represents the contents of a directory
type DirectoryContents struct {
	CurrentPath string     `json:"currentPath"`
	ParentPath  string     `json:"parentPath"`
	Files       []FileInfo `json:"files"`
	Directories []FileInfo `json:"directories"`
	TotalFiles  int        `json:"totalFiles"`
	TotalDirs   int        `json:"totalDirs"`
}

// NavigationResponse represents navigation result
type NavigationResponse struct {
	Success bool              `json:"success"`
	Message string            `json:"message"`
	Data    DirectoryContents `json:"data"`
}

// CacheEntry represents a cached directory entry for performance optimization
type CacheEntry struct {
	Contents  DirectoryContents `json:"contents"`
	Timestamp time.Time         `json:"timestamp"`
	ModTime   time.Time         `json:"modTime"`
}

// DriveInfo represents information about a system drive
type DriveInfo struct {
	Path   string `json:"path"`
	Letter string `json:"letter"`
	Name   string `json:"name"`
}

// Interfaces for dependency injection and better testability

// CacheManagerInterface defines the cache management contract
type CacheManagerInterface interface {
	Get(path string) (*CacheEntry, bool)
	Set(path string, entry *CacheEntry)
	Clear()
	CleanOldEntries()
}

// FileSystemManagerInterface defines the file system operations contract
type FileSystemManagerInterface interface {
	ListDirectory(path string) NavigationResponse
	GetFileInfo(path string) (FileInfo, error)
	CreateFileInfo(basePath string, name string) FileInfo
	IsHidden(path string) bool
	GetExtension(name string) string
	NavigateToPath(path string) NavigationResponse
	NavigateUp(currentPath string) NavigationResponse
	CreateDirectory(path, name string) NavigationResponse
	ValidatePath(path string) error
	FileExists(path string) bool
}

// FileOperationsManagerInterface defines file operations contract
type FileOperationsManagerInterface interface {
	CopyFiles(sourcePaths []string, destDir string) bool
	MoveFiles(sourcePaths []string, destDir string) bool
	DeleteFiles(filePaths []string) bool
	MoveFilesToRecycleBin(filePaths []string) bool
	RenameFile(oldPath, newName string) bool
	HideFiles(filePaths []string) bool
	OpenFile(filePath string) bool
}

// PlatformManagerInterface defines OS-specific operations contract
type PlatformManagerInterface interface {
	GetHomeDirectory() string
	GetCurrentWorkingDirectory() string
	GetSystemRoots() []string
	OpenInSystemExplorer(path string) bool
	IsHiddenWindows(filePath string) bool
	IsHiddenMac(filePath string) bool
	IsHiddenLinux(filePath string) bool
	IsHidden(filePath string) bool
	GetExtension(name string) string
	HideFile(filePath string) bool
	OpenFile(filePath string) bool
	FormatFileSize(size int64) string
}

// DriveManagerInterface defines drive management contract
type DriveManagerInterface interface {
	GetDriveInfo() []DriveInfo
	GetQuickAccessPaths() []DriveInfo
}

// TerminalManagerInterface defines terminal operations contract
type TerminalManagerInterface interface {
	OpenPowerShellHere(directoryPath string) bool
	OpenTerminalHere(directoryPath string) bool
	GetAvailableTerminals() []string
	ExecuteCommand(command string, workingDir string) error
}

// App struct - Main application structure with dependency injection
type App struct {
	ctx        context.Context
	cache      CacheManagerInterface
	filesystem FileSystemManagerInterface
	fileOps    FileOperationsManagerInterface
	platform   PlatformManagerInterface
	drives     DriveManagerInterface
	terminal   TerminalManagerInterface
}

// CacheManager implementation
type CacheManager struct {
	dirCache   map[string]*CacheEntry
	lastAccess map[string]time.Time
	cacheMutex sync.RWMutex
}

// FileSystemManager implementation
type FileSystemManager struct {
	cache    CacheManagerInterface
	platform PlatformManagerInterface
}

// FileOperationsManager implementation
type FileOperationsManager struct {
	cache    CacheManagerInterface
	platform PlatformManagerInterface
}

// PlatformManager implementation
type PlatformManager struct{}

// DriveManager implementation
type DriveManager struct{}

// TerminalManager implementation
type TerminalManager struct{}


================================================
File: frontend/src/assets/preact.svg
================================================
<svg xmlns="http://www.w3.org/2000/svg" width="27.68" height="32" aria-hidden="true" class="iconify iconify--logos" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 256 296"><path fill="#673AB8" d="m128 0l128 73.9v147.8l-128 73.9L0 221.7V73.9z"/><path fill="#FFF" d="M34.865 220.478c17.016 21.78 71.095 5.185 122.15-34.704c51.055-39.888 80.24-88.345 63.224-110.126c-17.017-21.78-71.095-5.184-122.15 34.704c-51.055 39.89-80.24 88.346-63.224 110.126Zm7.27-5.68c-5.644-7.222-3.178-21.402 7.573-39.253c11.322-18.797 30.541-39.548 54.06-57.923c23.52-18.375 48.303-32.004 69.281-38.442c19.922-6.113 34.277-5.075 39.92 2.148c5.644 7.223 3.178 21.403-7.573 39.254c-11.322 18.797-30.541 39.547-54.06 57.923c-23.52 18.375-48.304 32.004-69.281 38.441c-19.922 6.114-34.277 5.076-39.92-2.147Z"/><path fill="#FFF" d="M220.239 220.478c17.017-21.78-12.169-70.237-63.224-110.126C105.96 70.464 51.88 53.868 34.865 75.648c-17.017 21.78 12.169 70.238 63.224 110.126c51.055 39.889 105.133 56.485 122.15 34.704Zm-7.27-5.68c-5.643 7.224-19.998 8.262-39.92 2.148c-20.978-6.437-45.761-20.066-69.28-38.441c-23.52-18.376-42.74-39.126-54.06-57.923c-10.752-17.851-13.218-32.03-7.575-39.254c5.644-7.223 19.999-8.261 39.92-2.148c20.978 6.438 45.762 20.067 69.281 38.442c23.52 18.375 42.739 39.126 54.06 57.923c10.752 17.85 13.218 32.03 7.574 39.254Z"/><path fill="#FFF" d="M127.552 167.667c10.827 0 19.603-8.777 19.603-19.604c0-10.826-8.776-19.603-19.603-19.603c-10.827 0-19.604 8.777-19.604 19.603c0 10.827 8.777 19.604 19.604 19.604Z"/></svg>

================================================
File: frontend/src/components/RetroDialog.jsx
================================================
import { useState, useRef, useEffect, useCallback } from "preact/hooks";
import { memo } from "preact/compat";

// Memoized 8-bit Dialog Component
const RetroDialog = memo(({ isOpen, type, title, message, defaultValue, onConfirm, onCancel, onClose }) => {
    const [inputValue, setInputValue] = useState(defaultValue || '');
    const inputRef = useRef(null);
    
    useEffect(() => {
        setInputValue(defaultValue || '');
    }, [defaultValue]);
    
    useEffect(() => {
        if (isOpen && type === 'prompt' && inputRef.current) {
            inputRef.current.focus();
            inputRef.current.select();
        }
    }, [isOpen, type]);
    
    useEffect(() => {
        const handleKeyDown = (e) => {
            if (!isOpen) return;
            
            if (e.key === 'Escape') {
                onCancel();
            } else if (e.key === 'Enter') {
                if (type === 'prompt') {
                    onConfirm(inputValue);
                } else {
                    onConfirm();
                }
            }
        };
        
        if (isOpen) {
            document.addEventListener('keydown', handleKeyDown);
            return () => document.removeEventListener('keydown', handleKeyDown);
        }
    }, [isOpen, type, inputValue, onConfirm, onCancel]);
    
    const handleInputChange = useCallback((e) => {
        setInputValue(e.target.value);
    }, []);
    
    const handleConfirm = useCallback(() => {
        if (type === 'prompt') {
            onConfirm(inputValue);
        } else {
            onConfirm();
        }
    }, [type, inputValue, onConfirm]);
    
    if (!isOpen) return null;
    
    return (
        <div className="retro-dialog-overlay">
            <div className={`retro-dialog ${type === 'prompt' ? 'prompt-type' : ''} ${type === 'delete' ? 'delete-type' : ''}`}>
                {/* Dialog header */}
                <div className="retro-dialog-header">
                    <div className="retro-dialog-title">{title || 'SYSTEM MESSAGE'}</div>
                    <button 
                        className="retro-dialog-close"
                        onClick={onCancel}
                        title="CLOSE [ESC]"
                    >
                        ✕
                    </button>
                </div>
                
                {/* Dialog content */}
                <div className="retro-dialog-content">
                    <div className="retro-dialog-icon">
                        {type === 'confirm' && '⚠️'}
                        {type === 'prompt' && '✏️'}
                        {type === 'alert' && 'ℹ️'}
                        {type === 'error' && '❌'}
                        {type === 'success' && '✅'}
                        {type === 'delete' && '🗑️'}
                    </div>
                    <div className="retro-dialog-message">
                        {message.split('\n').map((line, index) => (
                            <div key={index}>{line}</div>
                        ))}
                    </div>
                    
                    {type === 'prompt' && (
                        <div className="retro-dialog-input-container">
                            <input
                                ref={inputRef}
                                type="text"
                                value={inputValue}
                                onChange={handleInputChange}
                                className="retro-dialog-input"
                                placeholder="ENTER VALUE..."
                            />
                        </div>
                    )}
                </div>
                
                {/* Dialog buttons */}
                <div className="retro-dialog-buttons">
                    {type === 'prompt' ? (
                        <>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-primary"
                                onClick={handleConfirm}
                            >
                                [ENTER] CONFIRM
                            </button>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-secondary"
                                onClick={onCancel}
                            >
                                [ESC] CANCEL
                            </button>
                        </>
                    ) : type === 'confirm' || type === 'delete' ? (
                        <>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-primary"
                                onClick={handleConfirm}
                            >
                                [ENTER] YES
                            </button>
                            <button 
                                className="retro-dialog-btn retro-dialog-btn-secondary"
                                onClick={onCancel}
                            >
                                [ESC] NO
                            </button>
                        </>
                    ) : (
                        <button 
                            className="retro-dialog-btn retro-dialog-btn-primary"
                            onClick={handleConfirm}
                        >
                            [ENTER] OK
                        </button>
                    )}
                </div>
            </div>
        </div>
    );
});

export { RetroDialog };
export default RetroDialog; 

================================================
File: frontend/src/components/ContextMenu.jsx
================================================
import { useRef, useEffect } from "preact/hooks";
import { memo } from "preact/compat";

// Memoized Context Menu Component
const ContextMenu = memo(({ visible, x, y, files, onClose, onPermanentDelete, onCopy, onCut, onRename, onHide }) => {
    const menuRef = useRef(null);
    
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
                onClose();
            }
        };
        
        if (visible) {
            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
        }
    }, [visible, onClose]);
    
    if (!visible) return null;
    
    return (
        <div 
            ref={menuRef}
            className="context-menu"
            style={{ 
                position: 'fixed', 
                left: x, 
                top: y, 
                zIndex: 1000 
            }}
        >
            <div className="context-menu-item" onClick={onCopy}>
                <span className="context-menu-icon">[C]</span>
                <span className="context-menu-text">Copy ({files.length})</span>
            </div>
            <div className="context-menu-item" onClick={onCut}>
                <span className="context-menu-icon">[X]</span>
                <span className="context-menu-text">Cut ({files.length})</span>
            </div>
            <div className="context-menu-separator"></div>
            {files.length === 1 && (
                <div className="context-menu-item" onClick={onRename}>
                    <span className="context-menu-icon">[F2]</span>
                    <span className="context-menu-text">Rename</span>
                </div>
            )}
            <div className="context-menu-separator"></div>
            <div className="context-menu-item" onClick={onHide} style={{ color: 'var(--blueprint-text-secondary)' }}>
                <span className="context-menu-icon">[H]</span>
                <span className="context-menu-text">Hide ({files.length})</span>
            </div>
            <div className="context-menu-item" onClick={onPermanentDelete} style={{ color: 'var(--blueprint-error)' }}>
                <span className="context-menu-icon">[!]</span>
                <span className="context-menu-text">Delete ({files.length})</span>
            </div>
        </div>
    );
});

export { ContextMenu };
export default ContextMenu; 

================================================
File: frontend/src/components/FileItem.jsx
================================================
import { useMemo, useCallback } from "preact/hooks";
import { memo } from "preact/compat";
import { getFileIcon, getFileType } from "../utils/fileUtils.js";
import { formatDate, formatFileSize } from "../utils/formatUtils.js";

// Memoized File item component
const FileItem = memo(({ 
    file, 
    onSelect, 
    onOpen, 
    isLoading, 
    isSelected, 
    fileIndex, 
    isCut, 
    onContextMenu, 
    onDragStart, 
    onDragOver, 
    onDragEnter, 
    onDragLeave, 
    onDrop, 
    isDragOver 
}) => {
    const icon = useMemo(() => getFileIcon(file.name, file.isDir), [file.name, file.isDir]);
    const type = useMemo(() => getFileType(file.name, file.isDir), [file.name, file.isDir]);
    
    const handleClick = useCallback((event) => {
        console.log('📋 File clicked:', file.name, 'Path:', file.path, 'IsDir:', file.isDir, 'IsSelected:', isSelected);
        
        if (!isLoading) {
            // If the file is already selected and this is a single click (no modifier keys), open it
            if (isSelected && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
                console.log('🚀 File already selected, opening:', file.name);
                onOpen(file);
            } else {
                // Otherwise, handle selection
                console.log('🖱️ Processing selection for:', file.name);
                onSelect(fileIndex, event.shiftKey, event.ctrlKey || event.metaKey);
            }
        }
    }, [file, isLoading, isSelected, fileIndex, onOpen, onSelect]);
    
    const handleDoubleClick = useCallback((event) => {
        console.log('🔍 File double-clicked:', file.name, 'Path:', file.path, 'IsDir:', file.isDir);
        
        if (!isLoading) {
            // Double click always opens, regardless of selection state
            console.log('🚀 Double-click detected, opening:', file.name);
            onOpen(file);
        }
    }, [file, isLoading, onOpen]);
    
    const handleRightClick = useCallback((event) => {
        event.preventDefault();
        console.log('🖱️ Right-click on:', file.name, 'IsSelected:', isSelected);
        
        if (!isLoading) {
            // If file is not selected, select it first
            if (!isSelected) {
                onSelect(fileIndex, false, false);
            }
            
            // Show context menu
            onContextMenu(event, file);
        }
    }, [file, isLoading, isSelected, fileIndex, onSelect, onContextMenu]);
    
    const handleDragStart = useCallback((event) => {
        if (isLoading) {
            event.preventDefault();
            return;
        }
        
        // If the dragged item is not selected, select it first
        if (!isSelected) {
            onSelect(fileIndex, false, false);
        }
        
        if (onDragStart) {
            onDragStart(event, file);
        }
    }, [isLoading, isSelected, fileIndex, file, onSelect, onDragStart]);
    
    const handleDragOver = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        event.preventDefault();
        event.dataTransfer.dropEffect = event.ctrlKey ? 'copy' : 'move';
        
        if (onDragOver) {
            onDragOver(event, file);
        }
    }, [file.isDir, isLoading, onDragOver, file]);
    
    const handleDragEnter = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        event.preventDefault();
        if (onDragEnter) {
            onDragEnter(event, file);
        }
    }, [file.isDir, isLoading, onDragEnter, file]);
    
    const handleDragLeave = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        if (onDragLeave) {
            onDragLeave(event, file);
        }
    }, [file.isDir, isLoading, onDragLeave, file]);
    
    const handleDrop = useCallback((event) => {
        if (!file.isDir || isLoading) return;
        
        event.preventDefault();
        
        try {
            const dragData = JSON.parse(event.dataTransfer.getData('application/json'));
            console.log('📂 Drop on folder:', file.name, 'Items:', dragData.files?.length, 'Operation:', dragData.operation);
            
            if (onDrop) {
                onDrop(event, file, dragData);
            }
        } catch (err) {
            console.error('❌ Error parsing drag data:', err);
        }
    }, [file, isLoading, onDrop]);
    
    return (
        <div 
            className={`file-item ${isSelected ? 'selected' : ''} ${isLoading ? 'disabled' : ''} ${isCut ? 'cut' : ''} ${isDragOver ? 'drag-over' : ''}`}
            onClick={handleClick}
            onDoubleClick={handleDoubleClick}
            onContextMenu={handleRightClick}
            draggable={!isLoading}
            onDragStart={handleDragStart}
            onDragOver={handleDragOver}
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
            style={{ 
                cursor: isLoading ? 'wait' : 'pointer',
                opacity: isLoading ? 0.7 : (isCut ? 0.5 : 1) 
            }}
        >
            <div className={`file-icon ${type}`}>
                {icon}
            </div>
            <div className="file-details">
                <div className="file-name">{file.name}</div>
                <div className="file-meta">
                    {file.isDir ? (
                        <span>DIR</span>
                    ) : (
                        <>
                            <span>{formatFileSize(file.size)}</span>
                            <span>{formatDate(file.modTime)}</span>
                        </>
                    )}
                </div>
            </div>
        </div>
    );
});

export { FileItem };
export default FileItem; 

================================================
File: frontend/src/components/FileList.jsx
================================================
import { useState } from 'preact/hooks';
import FileIcon from './FileIcon';

const FileList = ({ contents, onNavigate, isLoading }) => {
    const [selectedFile, setSelectedFile] = useState(null);
    
    const formatFileSize = (size) => {
        if (size === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(size) / Math.log(k));
        return `${parseFloat((size / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
    };
    
    const formatDate = (dateString) => {
        const date = new Date(dateString);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    };
    
    const handleFileClick = (file) => {
        setSelectedFile(file);
        if (file.isDir) {
            onNavigate(file.path);
        }
    };
    
    const handleDoubleClick = (file) => {
        if (file.isDir) {
            onNavigate(file.path);
        }
    };
    
    if (isLoading) {
        return (
            <div className="blueprint-panel flex-1">
                <div className="blueprint-panel-header">
                    <span>Loading Directory...</span>
                </div>
                <div className="p-8 text-center">
                    <div className="blueprint-loading text-blue-300">
                        <div className="inline-block w-6 h-6 border-2 border-blue-300 border-t-transparent rounded-full animate-spin"></div>
                    </div>
                    <p className="mt-4 text-gray-400">Scanning files...</p>
                </div>
            </div>
        );
    }
    
    const allItems = [...contents.directories, ...contents.files];
    
    return (
        <div className="blueprint-panel flex-1 flex flex-col">
            <div className="blueprint-panel-header flex justify-between items-center">
                <span>Directory Contents</span>
                <div className="text-xs opacity-75">
                    {contents.totalDirs} folders, {contents.totalFiles} files
                </div>
            </div>
            
            <div className="flex-1 overflow-auto custom-scrollbar">
                {allItems.length === 0 ? (
                    <div className="p-8 text-center text-gray-400">
                        <div className="text-4xl mb-4">📂</div>
                        <p>This directory is empty</p>
                    </div>
                ) : (
                    <div className="p-2">
                        {/* Header row */}
                        <div className="grid grid-cols-12 gap-2 px-3 py-2 text-xs font-semibold text-gray-400 border-b border-gray-600 uppercase tracking-wider">
                            <div className="col-span-5">Name</div>
                            <div className="col-span-2">Size</div>
                            <div className="col-span-3">Modified</div>
                            <div className="col-span-2">Type</div>
                        </div>
                        
                        {/* File/folder rows */}
                        {allItems.map((file, index) => (
                            <div
                                key={`${file.path}-${index}`}
                                onClick={() => handleFileClick(file)}
                                onDoubleClick={() => handleDoubleClick(file)}
                                className={`
                                    grid grid-cols-12 gap-2 px-3 py-2 mx-1 my-1 rounded-md cursor-pointer
                                    transition-all duration-200 ease-in-out
                                    hover:bg-blue-900/30 hover:border-blue-400/30 border border-transparent
                                    ${selectedFile?.path === file.path ? 'bg-blue-800/40 border-blue-400/50' : ''}
                                    ${file.isHidden ? 'opacity-60' : ''}
                                `}
                            >
                                {/* Name column */}
                                <div className="col-span-5 flex items-center space-x-3 min-w-0">
                                    <FileIcon file={file} />
                                    <span className={`truncate text-sm ${file.isDir ? 'text-blue-300 font-medium' : 'text-gray-200'}`}>
                                        {file.name}
                                    </span>
                                </div>
                                
                                {/* Size column */}
                                <div className="col-span-2 flex items-center text-xs text-gray-400">
                                    {file.isDir ? '—' : formatFileSize(file.size)}
                                </div>
                                
                                {/* Modified column */}
                                <div className="col-span-3 flex items-center text-xs text-gray-400">
                                    {file.modTime ? formatDate(file.modTime) : '—'}
                                </div>
                                
                                {/* Type column */}
                                <div className="col-span-2 flex items-center text-xs text-gray-400">
                                    {file.isDir ? 'Folder' : (file.extension || 'File')}
                                </div>
                            </div>
                        ))}
                    </div>
                )}
            </div>
            
            {/* Status bar */}
            <div className="border-t border-gray-600 px-4 py-2 bg-gray-800/50">
                <div className="flex justify-between items-center text-xs text-gray-400">
                    <span>{contents.currentPath}</span>
                    <span>
                        {selectedFile ? (
                            <>Selected: {selectedFile.name}</>
                        ) : (
                            <>{contents.totalDirs + contents.totalFiles} items</>
                        )}
                    </span>
                </div>
            </div>
        </div>
    );
};

export default FileList; 

================================================
File: frontend/src/app.jsx
================================================
import './style.css';
import './components/FastNavigation.css';
import { useState, useEffect, useCallback, useMemo } from "preact/hooks";
import { 
    GetHomeDirectory, 
    GetDriveInfo,
    OpenInSystemExplorer
} from "../wailsjs/go/backend/App";

// Import our custom components
import {
    Breadcrumb,
    Sidebar,
    FileItem,
    ContextMenu,
    EmptySpaceContextMenu,
    RetroDialog,
    VirtualizedFileList
} from "./components";

// Import our custom hooks
import {
    useFileOperations,
    useSelection,
    useClipboard,
    useNavigation,
    useDialogs,
    useContextMenus,
    usePerformanceMonitoring,
    useKeyboardShortcuts
} from "./hooks";

// Import our utilities
import { filterFiles } from "./utils/fileUtils";

// Import navigation service
import { navCache } from "./services/NavigationService";

// Main App component
export function App() {
    // Basic UI state
    const [error, setError] = useState('');
    const [drives, setDrives] = useState([]);
    const [showHiddenFiles, setShowHiddenFiles] = useState(false);
    const [dragOverFolder, setDragOverFolder] = useState(null);
    const [isDragging, setIsDragging] = useState(false);

    // Custom hooks
    const { navigationStats, setNavigationStats } = usePerformanceMonitoring();
    
    const {
        currentPath,
        directoryContents,
        showLoadingIndicator,
        navigateToPath,
        handleNavigateUp,
        handleRefresh,
        clearCache
    } = useNavigation(setError, setNavigationStats);

    const { dialog, showDialog, closeDialog } = useDialogs();

    const {
        selectedFiles,
        handleFileSelect,
        clearSelection,
        selectAll,
        handleArrowNavigation
    } = useSelection();

    const {
        clipboardFiles,
        clipboardOperation,
        handleCopy,
        handleCut,
        clearClipboard,
        isPasteAvailable
    } = useClipboard();

    // Initialize file operations hook
    const fileOperations = useFileOperations(
        currentPath, 
        setError, 
        clearSelection, 
        () => navigateToPath(currentPath), 
        showDialog
    );

    // Computed values
    const filteredDirectories = useMemo(() => 
        directoryContents ? filterFiles(directoryContents.directories, showHiddenFiles) : [], 
        [directoryContents, showHiddenFiles]
    );
    
    const filteredFiles = useMemo(() => 
        directoryContents ? filterFiles(directoryContents.files, showHiddenFiles) : [], 
        [directoryContents, showHiddenFiles]
    );
    
    const allFiles = useMemo(() => 
        [...filteredDirectories, ...filteredFiles], 
        [filteredDirectories, filteredFiles]
    );

    // Context menus hook
    const {
        contextMenu,
        emptySpaceContextMenu,
        handleContextMenu,
        closeContextMenu,
        handleEmptySpaceContextMenu,
        closeEmptySpaceContextMenu,
        handleContextCopy,
        handleContextCut,
        handleContextRename,
        handleContextHide,
        handlePermanentDelete,
        handleOpenPowerShell
    } = useContextMenus(
        selectedFiles, 
        allFiles, 
        handleCopy, 
        handleCut, 
        showDialog, 
        fileOperations, 
        currentPath, 
        navCache
    );

    // File operation handlers
    const handleFileOpen = useCallback((file) => {
        const result = fileOperations.handleFileOpen(file);
        if (result && result.type === 'navigate') {
            // Use direct navigation for file opens (immediate response)
            navigateToPath(result.path, 'file-open');
        }
    }, [fileOperations, navigateToPath]);

    const handleOpenInExplorer = useCallback(() => {
        if (currentPath) {
            OpenInSystemExplorer(currentPath);
        }
    }, [currentPath]);

    // Clipboard operations
    const handleCopySelected = useCallback(() => {
        const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
        const filePaths = selectedFileObjects.map(file => file.path);
        handleCopy(filePaths);
    }, [selectedFiles, allFiles, handleCopy]);

    const handleCutSelected = useCallback(() => {
        const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
        const filePaths = selectedFileObjects.map(file => file.path);
        handleCut(filePaths);
    }, [selectedFiles, allFiles, handleCut]);

    const handlePaste = useCallback(async () => {
        if (!isPasteAvailable() || !currentPath) return;
        
        try {
            console.log(`📥 Pasting ${clipboardFiles.length} items to:`, currentPath);
            
            let success = false;
            if (clipboardOperation === 'copy') {
                success = await fileOperations.handleCopyFiles(clipboardFiles);
            } else if (clipboardOperation === 'cut') {
                success = await fileOperations.handleMoveFiles(clipboardFiles);
                if (success) {
                    clearClipboard();
                }
            }
            
            if (!success) {
                setError('Paste operation failed');
            } else {
                // Clear cache for current directory to show changes
                navCache.cache.delete(currentPath);
                // Refresh the directory to show the pasted files immediately
                handleRefresh();
            }
        } catch (err) {
            console.error('❌ Error during paste operation:', err);
            setError('Failed to paste files: ' + err.message);
        }
    }, [isPasteAvailable, currentPath, clipboardFiles, clipboardOperation, fileOperations, clearClipboard]);

    // Keyboard shortcuts
    useKeyboardShortcuts({
        handleRefresh,
        handleNavigateUp,
        selectedFiles,
        allFiles,
        handleFileOpen,
        selectAll,
        handleCopySelected,
        handleCutSelected,
        handlePaste,
        isPasteAvailable,
        handleArrowNavigation,
        clearSelection,
        closeContextMenu,
        closeEmptySpaceContextMenu,
        clearCache
    });

    // Initialize app
    useEffect(() => {
        console.log('🚀 Blueprint File Explorer initializing...');
        initializeApp();
    }, []);

    const initializeApp = async () => {
        try {
            setError('');
            
            const homeDir = await GetHomeDirectory();
            if (homeDir) {
                await navigateToPath(homeDir, 'init');
            } else {
                setError('Unable to determine starting directory');
            }
        } catch (err) {
            console.error('❌ Error initializing app:', err);
            setError('Failed to initialize file explorer: ' + err.message);
        }
    };

    // Load drives
    useEffect(() => {
        GetDriveInfo().then(driveList => {
            setDrives(driveList);
        });
    }, []);

    // Clear selection when path changes
    useEffect(() => {
        clearSelection();
        closeContextMenu();
    }, [currentPath, clearSelection, closeContextMenu]);

    return (
        <div className="file-explorer blueprint-bg">
            {/* Header */}
            <header className="app-header">
                <div className="app-title">Files</div>
                <div style={{ marginLeft: 'auto', display: 'flex', alignItems: 'center', gap: '12px' }}>
                    {showLoadingIndicator && <div className="loading-spinner"></div>}
                    <span className="text-technical">
                        {directoryContents ? 
                            `${filteredDirectories.length} dirs • ${filteredFiles.length} files${!showHiddenFiles ? ' (hidden filtered)' : ''}${selectedFiles.size > 0 ? ` • ${selectedFiles.size} selected` : ''}` : 
                            'Ready'
                        }
                    </span>
                    {/* Performance indicator */}
                    {navigationStats.totalNavigations > 0 && (
                        <span className="text-technical" style={{ fontSize: '10px', opacity: 0.6 }}>
                            Cache: {Math.round(navigationStats.cacheHits / navigationStats.totalNavigations * 100)}% • {Math.round(navigationStats.averageTime)}ms avg
                        </span>
                    )}
                    {/* Show current path for instant feedback */}
                    {currentPath && (
                        <span className="text-technical" style={{ fontSize: '11px', opacity: 0.7, maxWidth: '200px', overflow: 'hidden', textOverflow: 'ellipsis' }}>
                            {currentPath}
                        </span>
                    )}
                </div>
            </header>
            
            {/* Error display */}
            {error && (
                <div className="error-message">
                    <strong>⚠️ Error:</strong> {error}
                    <button onClick={() => setError('')} style={{ marginLeft: '12px', background: 'none', border: 'none', color: 'inherit', textDecoration: 'underline', cursor: 'pointer' }}>
                        Dismiss
                    </button>
                </div>
            )}
            
            {/* Main content */}
            <div className="main-content">
                <Sidebar 
                    currentPath={currentPath}
                    onNavigate={(path) => navigateToPath(path, 'sidebar')}
                    drives={drives}
                />
                
                <div className="content-area">
                    {/* Toolbar */}
                    <div className="toolbar">
                        <button className="toolbar-btn" onClick={handleNavigateUp} disabled={!currentPath}>
                            ⬆️ Up
                        </button>
                        <button className="toolbar-btn" onClick={handleRefresh} disabled={!currentPath}>
                            🔄 Refresh
                        </button>
                        <button className="toolbar-btn" onClick={handleOpenInExplorer} disabled={!currentPath}>
                            🖥️ Open in Explorer
                        </button>
                        <button 
                            className={`toolbar-btn ${showHiddenFiles ? 'active' : ''}`}
                            onClick={() => setShowHiddenFiles(!showHiddenFiles)}
                        >
                            {showHiddenFiles ? '👁️' : '🙈'} Hidden
                        </button>
                    </div>
                    
                    {/* Breadcrumb navigation */}
                    {currentPath && (
                        <Breadcrumb 
                            currentPath={currentPath}
                            onNavigate={(path) => navigateToPath(path, 'breadcrumb')}
                        />
                    )}
                    
                    {/* File list - Use virtual scrolling for better performance */}
                    <div 
                        className="file-list-container"
                        onClick={(e) => {
                            if (e.target === e.currentTarget) {
                                clearSelection();
                                closeContextMenu();
                                closeEmptySpaceContextMenu();
                            }
                        }}
                        onContextMenu={(e) => {
                            if (e.target === e.currentTarget) {
                                e.preventDefault();
                                closeContextMenu();
                                closeEmptySpaceContextMenu();
                                handleEmptySpaceContextMenu(e);
                            }
                        }}
                    >
                        {showLoadingIndicator ? (
                            <div className="loading-overlay">
                                <div style={{ textAlign: 'center' }}>
                                    <div className="loading-spinner" style={{ width: '32px', height: '32px', marginBottom: '16px' }}></div>
                                    <div className="text-technical">Loading directory...</div>
                                </div>
                            </div>
                        ) : directoryContents ? (
                            allFiles.length > 20 ? (
                                // Use virtual scrolling for large directories
                                <VirtualizedFileList
                                    files={allFiles}
                                    selectedFiles={selectedFiles}
                                    onFileSelect={handleFileSelect}
                                    onFileOpen={handleFileOpen}
                                    onContextMenu={handleContextMenu}
                                    isLoading={false} // Never show loading in file items
                                    clipboardFiles={clipboardFiles}
                                    clipboardOperation={clipboardOperation}
                                />
                            ) : (
                                // Use normal rendering for small directories
                                <div className="file-list custom-scrollbar">
                                    {allFiles.map((file, index) => (
                                        <FileItem
                                            key={file.path}
                                            file={file}
                                            fileIndex={index}
                                            onSelect={handleFileSelect}
                                            onOpen={handleFileOpen}
                                            onContextMenu={handleContextMenu}
                                            isLoading={false} // Never show loading in file items
                                            isSelected={selectedFiles.has(index)}
                                            isCut={clipboardOperation === 'cut' && clipboardFiles.includes(file.path)}
                                            isDragOver={dragOverFolder === file.path}
                                        />
                                    ))}
                                    
                                    {allFiles.length === 0 && (
                                        <div style={{ textAlign: 'center', padding: '64px 32px', color: 'var(--blueprint-text-muted)' }}>
                                            <div style={{ fontSize: '48px', marginBottom: '16px' }}>📁</div>
                                            <div className="text-technical">Directory is empty</div>
                                        </div>
                                    )}
                                </div>
                            )
                        ) : (
                            <div style={{ textAlign: 'center', padding: '64px 32px', color: 'var(--blueprint-text-muted)' }}>
                                <div style={{ fontSize: '48px', marginBottom: '16px' }}>📁</div>
                                <div className="text-technical">Ready</div>
                            </div>
                        )}
                    </div>
                </div>
            </div>
            
            {/* Context Menus and Dialog */}
            <ContextMenu
                visible={contextMenu.visible}
                x={contextMenu.x}
                y={contextMenu.y}
                files={contextMenu.files}
                onClose={closeContextMenu}
                onCopy={handleContextCopy}
                onCut={handleContextCut}
                onRename={handleContextRename}
                onHide={handleContextHide}
                onPermanentDelete={handlePermanentDelete}
            />
            
            <EmptySpaceContextMenu
                visible={emptySpaceContextMenu.visible}
                x={emptySpaceContextMenu.x}
                y={emptySpaceContextMenu.y}
                onClose={closeEmptySpaceContextMenu}
                onOpenPowerShell={handleOpenPowerShell}
            />
            
            <RetroDialog
                isOpen={dialog.isOpen}
                type={dialog.type}
                title={dialog.title}
                message={dialog.message}
                defaultValue={dialog.defaultValue}
                onConfirm={dialog.onConfirm}
                onCancel={dialog.onCancel}
                onClose={closeDialog}
            />
            
            {/* Status bar */}
            <div className="status-bar">
                <span>
                    Path: {currentPath || 'Not selected'} 
                    {selectedFiles.sizwaie > 0 && ` • ${selectedFiles.size} item${selectedFiles.size === 1 ? '' : 's'} selected`}
                    {clipboardFiles.length > 0 && ` • ${clipboardFiles.length} item${clipboardFiles.length === 1 ? '' : 's'} ${clipboardOperation === 'cut' ? 'cut' : 'copied'}`}
                    {isDragging && ' • Dragging files (Hold Ctrl to copy)'}
                </span>
                <span style={{ marginLeft: 'auto' }}>
                    File Explorer • Ctrl+Shift+C: Clear Cache
                </span>
            </div>
        </div>
    );
} 

================================================
File: frontend/src/components/FileIcon.jsx
================================================
import { useState, useEffect } from 'preact/hooks';

const FileIcon = ({ file, className = "" }) => {
    const [iconType, setIconType] = useState('file');
    
    useEffect(() => {
        if (file.isDir) {
            setIconType('folder');
        } else {
            const ext = file.extension?.toLowerCase();
            
            // Image files
            if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp', 'ico'].includes(ext)) {
                setIconType('image');
            }
            // Code files
            else if (['js', 'jsx', 'ts', 'tsx', 'py', 'go', 'java', 'cpp', 'c', 'h', 'css', 'html', 'json', 'xml', 'yaml', 'yml'].includes(ext)) {
                setIconType('code');
            }
            // Text files
            else if (['txt', 'md', 'rst', 'log', 'csv'].includes(ext)) {
                setIconType('text');
            }
            // Archive files
            else if (['zip', 'rar', '7z', 'tar', 'gz', 'bz2'].includes(ext)) {
                setIconType('archive');
            }
            // Executable files
            else if (['exe', 'msi', 'app', 'deb', 'rpm'].includes(ext)) {
                setIconType('executable');
            }
            else {
                setIconType('file');
            }
        }
    }, [file]);
    
    const getIconSymbol = () => {
        switch (iconType) {
            case 'folder':
                return '📁';
            case 'image':
                return '🖼️';
            case 'code':
                return '⚡';
            case 'text':
                return '📄';
            case 'archive':
                return '📦';
            case 'executable':
                return '⚙️';
            default:
                return '📄';
        }
    };
    
    const getFileTypeLabel = () => {
        if (file.isDir) return 'DIR';
        if (file.extension) return file.extension.toUpperCase();
        return 'FILE';
    };
    
    return (
        <div className={`file-icon ${iconType} ${className}`} title={file.name}>
            <span className="text-xs">{getFileTypeLabel()}</span>
        </div>
    );
};

export default FileIcon; 

================================================
File: backend/cache.go
================================================
package backend

import (
	"log"
	"time"
)

// NewCacheManager creates a new cache manager instance with optimized settings
func NewCacheManager() *CacheManager {
	cm := &CacheManager{
		dirCache:   make(map[string]*CacheEntry),
		lastAccess: make(map[string]time.Time),
	}

	// Start background cleanup routine
	go cm.backgroundCleanup()

	return cm
}

// Get retrieves a cache entry if it exists and is still valid
func (c *CacheManager) Get(path string) (*CacheEntry, bool) {
	c.cacheMutex.RLock()
	defer c.cacheMutex.RUnlock()

	entry, exists := c.dirCache[path]
	if !exists {
		return nil, false
	}

	// Extended cache validity for better performance
	// Use 30 seconds for recently accessed paths, 5 seconds for others
	maxAge := 5 * time.Second
	if lastAccess, hasAccess := c.lastAccess[path]; hasAccess {
		if time.Since(lastAccess) < 2*time.Minute {
			maxAge = 30 * time.Second // Recently accessed paths get longer cache
		}
	}

	cacheAge := time.Since(entry.Timestamp)
	if cacheAge > maxAge {
		return nil, false
	}

	// Update access time for LRU
	c.lastAccess[path] = time.Now()

	log.Printf("⚡ Backend cache HIT for: %s (age: %v, max: %v)", path, cacheAge, maxAge)
	return entry, true
}

// Set stores a cache entry with intelligent size management
func (c *CacheManager) Set(path string, entry *CacheEntry) {
	c.cacheMutex.Lock()
	defer c.cacheMutex.Unlock()

	c.dirCache[path] = entry
	c.lastAccess[path] = time.Now()

	// Increased cache size for better hit rates
	maxEntries := 200
	if len(c.dirCache) > maxEntries {
		c.cleanOldEntriesLocked(maxEntries / 2) // Clean half when full
	}

	log.Printf("💾 Backend cached: %s (%d/%d entries)", path, len(c.dirCache), maxEntries)
}

// Clear removes all cache entries
func (c *CacheManager) Clear() {
	c.cacheMutex.Lock()
	defer c.cacheMutex.Unlock()

	c.dirCache = make(map[string]*CacheEntry)
	c.lastAccess = make(map[string]time.Time)
	log.Printf("🧹 Backend cache cleared")
}

// CleanOldEntries removes stale cache entries to prevent memory bloat
func (c *CacheManager) CleanOldEntries() {
	c.cacheMutex.Lock()
	defer c.cacheMutex.Unlock()

	c.cleanOldEntriesLocked(0)
}

// cleanOldEntriesLocked is the internal implementation that requires a write lock
func (c *CacheManager) cleanOldEntriesLocked(targetSize int) {
	if targetSize <= 0 {
		// Normal cleanup - remove entries older than 1 minute
		maxAge := 1 * time.Minute
		now := time.Now()
		removedCount := 0

		for path, entry := range c.dirCache {
			if now.Sub(entry.Timestamp) > maxAge {
				delete(c.dirCache, path)
				delete(c.lastAccess, path)
				removedCount++
			}
		}

		if removedCount > 0 {
			log.Printf("🧹 Cleaned %d old cache entries, %d remaining", removedCount, len(c.dirCache))
		}
	} else {
		// Aggressive cleanup to reach target size - remove least recently accessed
		if len(c.dirCache) <= targetSize {
			return
		}

		type accessEntry struct {
			path       string
			accessTime time.Time
		}

		// Sort by access time
		var accessList []accessEntry
		for path, accessTime := range c.lastAccess {
			accessList = append(accessList, accessEntry{path, accessTime})
		}

		// Sort by access time (oldest first)
		for i := 0; i < len(accessList)-1; i++ {
			for j := i + 1; j < len(accessList); j++ {
				if accessList[i].accessTime.After(accessList[j].accessTime) {
					accessList[i], accessList[j] = accessList[j], accessList[i]
				}
			}
		}

		// Remove oldest entries
		toRemove := len(c.dirCache) - targetSize
		removedCount := 0
		for i := 0; i < toRemove && i < len(accessList); i++ {
			path := accessList[i].path
			delete(c.dirCache, path)
			delete(c.lastAccess, path)
			removedCount++
		}

		log.Printf("🧹 Aggressive cleanup: removed %d entries, %d remaining", removedCount, len(c.dirCache))
	}
}

// backgroundCleanup runs periodic cache maintenance
func (c *CacheManager) backgroundCleanup() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()

	for range ticker.C {
		c.CleanOldEntries()
	}
}

// GetCacheStats returns cache statistics for debugging/monitoring
func (c *CacheManager) GetCacheStats() map[string]interface{} {
	c.cacheMutex.RLock()
	defer c.cacheMutex.RUnlock()

	stats := make(map[string]interface{})
	stats["total_entries"] = len(c.dirCache)
	stats["memory_usage_estimate"] = len(c.dirCache) * 1024 // Rough estimate

	// Calculate age distribution
	now := time.Now()
	ageDistribution := map[string]int{
		"under_5s":  0,
		"5s_to_30s": 0,
		"over_30s":  0,
	}

	accessDistribution := map[string]int{
		"recent":   0, // Accessed in last 2 minutes
		"moderate": 0, // Accessed 2-10 minutes ago
		"old":      0, // Accessed over 10 minutes ago
	}

	for path, entry := range c.dirCache {
		age := now.Sub(entry.Timestamp)
		switch {
		case age < 5*time.Second:
			ageDistribution["under_5s"]++
		case age < 30*time.Second:
			ageDistribution["5s_to_30s"]++
		default:
			ageDistribution["over_30s"]++
		}

		// Check access time
		if accessTime, exists := c.lastAccess[path]; exists {
			accessAge := now.Sub(accessTime)
			switch {
			case accessAge < 2*time.Minute:
				accessDistribution["recent"]++
			case accessAge < 10*time.Minute:
				accessDistribution["moderate"]++
			default:
				accessDistribution["old"]++
			}
		}
	}

	stats["age_distribution"] = ageDistribution
	stats["access_distribution"] = accessDistribution
	stats["hit_rate_estimate"] = "See frontend logs for real-time hit rates"

	return stats
}


================================================
File: frontend/src/components/Sidebar.jsx
================================================
import { useState, useEffect, useMemo, useCallback } from "preact/hooks";
import { memo } from "preact/compat";
import { GetHomeDirectory } from "../../wailsjs/go/backend/App";

// Memoized Sidebar component
const Sidebar = memo(({ currentPath, onNavigate, drives = [] }) => {
    const [homeDir, setHomeDir] = useState('');
    
    useEffect(() => {
        GetHomeDirectory().then(setHomeDir);
    }, []);
    
    // Use proper path separators for the current OS
    const pathSep = homeDir.includes('\\') ? '\\' : '/';
    
    const quickAccess = useMemo(() => [
        { name: 'Home', path: homeDir, icon: '🏠' },
        { name: 'Desktop', path: homeDir + pathSep + 'Desktop', icon: '🖥️' },
        { name: 'Documents', path: homeDir + pathSep + 'Documents', icon: '📁' },
        { name: 'Downloads', path: homeDir + pathSep + 'Downloads', icon: '⬇️' },
    ].filter(item => item.path), [homeDir, pathSep]);
    
    const handleQuickAccessClick = useCallback((path) => {
        onNavigate(path);
    }, [onNavigate]);
    
    const handleDriveClick = useCallback((path) => {
        onNavigate(path);
    }, [onNavigate]);
    
    return (
        <div className="sidebar">
            <div className="sidebar-section">
                <div className="sidebar-title">Quick Access</div>
                {quickAccess.map((item) => (
                    <div 
                        key={item.path}
                        className={`sidebar-item ${currentPath === item.path ? 'active' : ''}`}
                        onClick={() => handleQuickAccessClick(item.path)}
                    >
                        <span className="sidebar-icon">{item.icon}</span>
                        {item.name}
                    </div>
                ))}
            </div>
            
            {drives.length > 0 && (
                <div className="sidebar-section">
                    <div className="sidebar-title">Drives</div>
                    {drives.map((drive) => (
                        <div 
                            key={drive.path}
                            className={`sidebar-item ${currentPath === drive.path ? 'active' : ''}`}
                            onClick={() => handleDriveClick(drive.path)}
                        >
                            <span className="sidebar-icon">💽</span>
                            {drive.name}
                        </div>
                    ))}
                </div>
            )}
        </div>
    );
});

export { Sidebar };
export default Sidebar; 

================================================
File: README.md
================================================
# 🚀 Blueprint File Explorer

A modern, technical file system navigator built with **Wails v2**, **Go**, and **Preact**. Features a retro minimalist blueprint design inspired by technical diagrams and engineering schematics.

![Blueprint File Explorer](https://img.shields.io/badge/Wails-v2.10.1-blue) ![Go](https://img.shields.io/badge/Go-1.21+-00ADD8) ![Preact](https://img.shields.io/badge/Preact-10.10+-673AB8)

## ✨ Features

### 🎨 **Blueprint Design System**
- **Retro minimalist UI** inspired by technical blueprints
- **Grid-based background** with subtle technical overlay
- **Monospace typography** (JetBrains Mono) for technical aesthetics
- **Color-coded file types** with intuitive icons
- **Responsive design** with proper scaling

### 📁 **File System Navigation**
- **Full directory browsing** with real-time updates
- **Breadcrumb navigation** with clickable segments
- **Quick access sidebar** with common locations
- **Drive detection** (Windows) with easy switching
- **File type recognition** with proper icons and colors
- **File size formatting** in human-readable units

### ⚡ **Performance & UX**
- **Fast navigation** with minimal loading times
- **Keyboard shortcuts** (F5 refresh, Backspace/Alt+← navigate up)
- **Double-click to open** files in system default applications
- **Open in Explorer** functionality
- **Error handling** with user-friendly messages
- **Loading states** with blueprint-styled spinners

### 🔧 **Technical Features**
- **Cross-platform** support (Windows, macOS, Linux)
- **Go backend** with robust file system operations
- **Preact frontend** for efficient rendering
- **TypeScript bindings** auto-generated by Wails
- **Development hot-reload** with Vite

## 🚀 Getting Started

### Prerequisites
- **Go 1.21+**
- **Node.js 18+** or **Bun** (preferred)
- **Wails CLI v2**

### Installation

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd blueprint-file-explorer
   ```

2. **Install Wails CLI** (if not already installed)
   ```bash
   go install github.com/wailsapp/wails/v2/cmd/wails@latest
   ```

3. **Install frontend dependencies**
   ```bash
   cd frontend
   bun install  # or npm install
   cd ..
   ```

4. **Run in development mode**
   ```bash
   wails dev
   ```

5. **Build for production**
   ```bash
   wails build
   ```

## 🎯 Usage

### Navigation
- **Click folders** to navigate into directories
- **Click breadcrumb segments** to jump to parent directories
- **Use sidebar** for quick access to common locations
- **Double-click files** to open with system default application

### Keyboard Shortcuts
- **F5** - Refresh current directory
- **Backspace** - Navigate to parent directory
- **Alt + ←** - Navigate to parent directory

### File Operations
- **View file details** including size, modification date, and permissions
- **Open in system explorer** using the toolbar button
- **Color-coded file types** for easy identification

## 🏗️ Architecture

### Backend (Go)
- **File system operations** with proper error handling
- **Cross-platform path handling** for Windows/Unix systems
- **Drive detection** and system information
- **File metadata extraction** (size, permissions, timestamps)

### Frontend (Preact)
- **Component-based architecture** with hooks
- **Responsive design** with CSS Grid and Flexbox
- **State management** with React hooks
- **Event handling** for navigation and user interactions

### Design System
- **CSS Custom Properties** for theming
- **Blueprint color palette** with technical aesthetics
- **Typography hierarchy** using Inter and JetBrains Mono
- **Grid patterns** and technical overlays

## 🎨 Design Philosophy

The Blueprint File Explorer embraces a **retro minimalist** aesthetic inspired by:
- **Technical blueprints** and engineering diagrams
- **Monospace typography** for precision and clarity
- **Grid-based layouts** with mathematical precision
- **Subtle animations** and hover effects
- **Color coding** for functional differentiation

## 🔧 Development

### Project Structure
```
blueprint-file-explorer/
├── app.go                 # Main Go application
├── main.go               # Application entry point
├── frontend/             # Preact frontend
│   ├── src/
│   │   ├── app.jsx      # Main application component
│   │   ├── style.css    # Blueprint design system
│   │   └── main.jsx     # Application bootstrap
│   └── package.json     # Frontend dependencies
├── build/               # Built application
└── wails.json          # Wails configuration
```

### Adding Features
1. **Backend methods** - Add new methods to `app.go`
2. **Frontend components** - Create new components in `src/`
3. **Styling** - Extend the design system in `style.css`
4. **Regenerate bindings** - Run `wails dev` to update TypeScript bindings

## 📝 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- **Wails** - For the excellent Go + Web framework
- **Preact** - For the lightweight React alternative
- **JetBrains Mono** - For the beautiful monospace typography
- **Blueprint design** - Inspired by technical diagram aesthetics

---

Built with ❤️ using **Wails v2** & **Go**


================================================
File: frontend/src/components/NavigationBar.jsx
================================================
import { useState, useEffect } from 'preact/hooks';

const NavigationBar = ({ currentPath, onNavigate, onNavigateUp, onNavigateHome }) => {
    const [pathParts, setPathParts] = useState([]);
    const [inputPath, setInputPath] = useState('');
    const [isEditing, setIsEditing] = useState(false);
    
    useEffect(() => {
        if (currentPath) {
            setInputPath(currentPath);
            // Split path into parts for breadcrumb navigation
            const parts = currentPath.split(/[\\/]/).filter(part => part.length > 0);
            setPathParts(parts);
        }
    }, [currentPath]);
    
    const handlePathInputSubmit = (e) => {
        e.preventDefault();
        if (inputPath.trim()) {
            onNavigate(inputPath.trim());
        }
        setIsEditing(false);
    };
    
    const handleBreadcrumbClick = (index) => {
        if (index === -1) {
            // Root click
            const isWindows = currentPath.includes(':\\');
            if (isWindows) {
                // Go to drive root (e.g., C:\)
                const driveLetter = currentPath.charAt(0);
                onNavigate(`${driveLetter}:\\`);
            } else {
                onNavigate('/');
            }
        } else {
            // Build path up to clicked part
            const isWindows = currentPath.includes(':\\');
            let pathUpTo;
            
            if (isWindows && index === 0) {
                // First part is drive letter
                pathUpTo = pathParts[0];
            } else if (isWindows) {
                pathUpTo = pathParts.slice(0, index + 1).join('\\');
            } else {
                pathUpTo = '/' + pathParts.slice(0, index + 1).join('/');
            }
            
            onNavigate(pathUpTo);
        }
    };
    
    const canNavigateUp = () => {
        if (!currentPath) return false;
        const isRoot = currentPath === '/' || /^[A-Z]:\\?$/.test(currentPath);
        return !isRoot;
    };
    
    return (
        <div className="blueprint-panel">
            <div className="blueprint-panel-header">
                <span>File Explorer Navigation</span>
            </div>
            
            <div className="p-4 space-y-4">
                {/* Quick navigation buttons */}
                <div className="flex space-x-2">
                    <button
                        onClick={onNavigateUp}
                        disabled={!canNavigateUp()}
                        className="blueprint-button disabled:opacity-50 disabled:cursor-not-allowed"
                        title="Go up one level"
                    >
                        ↑ Up
                    </button>
                    
                    <button
                        onClick={onNavigateHome}
                        className="blueprint-button"
                        title="Go to home directory"
                    >
                        🏠 Home
                    </button>
                    
                    <button
                        onClick={() => setIsEditing(!isEditing)}
                        className="blueprint-button"
                        title="Edit path directly"
                    >
                        ✏️ Edit
                    </button>
                </div>
                
                {/* Path display/input */}
                <div className="space-y-2">
                    {isEditing ? (
                        <form onSubmit={handlePathInputSubmit} className="flex space-x-2">
                            <input
                                type="text"
                                value={inputPath}
                                onChange={(e) => setInputPath(e.target.value)}
                                onBlur={() => setIsEditing(false)}
                                className="flex-1 blueprint-input text-sm"
                                placeholder="Enter path..."
                                autoFocus
                            />
                            <button type="submit" className="blueprint-button">
                                Go
                            </button>
                        </form>
                    ) : (
                        /* Breadcrumb navigation */
                        <div className="flex items-center space-x-1 text-sm">
                            <span className="text-gray-400">Path:</span>
                            
                            {/* Root indicator */}
                            <button
                                onClick={() => handleBreadcrumbClick(-1)}
                                className="px-2 py-1 rounded text-blue-300 hover:bg-blue-900/30 transition-colors"
                                title="Go to root"
                            >
                                {currentPath?.includes(':\\') ? '💻' : '/'}
                            </button>
                            
                            {/* Path parts */}
                            {pathParts.map((part, index) => (
                                <div key={index} className="flex items-center space-x-1">
                                    <span className="text-gray-500">/</span>
                                    <button
                                        onClick={() => handleBreadcrumbClick(index)}
                                        className="px-2 py-1 rounded text-blue-300 hover:bg-blue-900/30 transition-colors max-w-32 truncate"
                                        title={part}
                                    >
                                        {part}
                                    </button>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
                
                {/* Current path display (always visible) */}
                <div className="text-xs text-gray-500 bg-gray-800/30 p-2 rounded border border-gray-600 font-mono">
                    <span className="text-gray-400">Current: </span>
                    <span className="break-all">{currentPath || 'No path selected'}</span>
                </div>
            </div>
        </div>
    );
};

export default NavigationBar; 

================================================
File: frontend/src/components/EmptySpaceContextMenu.jsx
================================================
import { useRef, useEffect } from "preact/hooks";
import { memo } from "preact/compat";

// Memoized Empty Space Context Menu Component  
const EmptySpaceContextMenu = memo(({ visible, x, y, onClose, onOpenPowerShell }) => {
    const menuRef = useRef(null);
    
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (menuRef.current && !menuRef.current.contains(event.target)) {
                onClose();
            }
        };
        
        if (visible) {
            document.addEventListener('mousedown', handleClickOutside);
            return () => document.removeEventListener('mousedown', handleClickOutside);
        }
    }, [visible, onClose]);
    
    if (!visible) return null;
    
    return (
        <div 
            ref={menuRef}
            className="context-menu empty-space-context-menu"
            style={{ 
                position: 'fixed', 
                left: x, 
                top: y, 
                zIndex: 1000 
            }}
        >
            <div className="context-menu-item" onClick={onOpenPowerShell}>
                <span className="context-menu-icon">[{'>'}_]</span>
                <span className="context-menu-text">Open PowerShell 7 Here</span>
            </div>
        </div>
    );
});

export { EmptySpaceContextMenu };
export default EmptySpaceContextMenu; 

================================================
File: frontend/src/components/VirtualizedFileList.css
================================================
/* Virtualized File List Performance Optimizations */

.virtualized-file-list {
    /* Use GPU acceleration for smooth scrolling */
    transform: translateZ(0);
    will-change: scroll-position;
    
    /* Optimize rendering */
    contain: layout style paint;
    
    /* Prevent layout thrashing */
    overflow-anchor: none;
}

.virtualized-file-list .file-item {
    /* Optimize positioning for virtual scrolling */
    contain: layout style paint;
    
    /* Prevent unnecessary reflows */
    box-sizing: border-box;
    
    /* Use transform instead of top/left for better performance */
    will-change: transform;
}

/* Optimize scrollbar for Windows */
.virtualized-file-list::-webkit-scrollbar {
    width: 8px;
    background-color: var(--blueprint-surface);
}

.virtualized-file-list::-webkit-scrollbar-track {
    background-color: var(--blueprint-surface);
    border-radius: 2px;
}

.virtualized-file-list::-webkit-scrollbar-thumb {
    background-color: var(--blueprint-border);
    border-radius: 2px;
}

.virtualized-file-list::-webkit-scrollbar-thumb:hover {
    background-color: var(--blueprint-primary);
}

/* Prevent horizontal scrollbar from appearing */
.virtualized-file-list::-webkit-scrollbar-horizontal {
    display: none;
}

/* Optimize file items for virtual scrolling */
.virtual-file-item {
    position: absolute;
    width: 100%;
    
    /* Prevent text selection during fast scrolling */
    user-select: none;
    
    /* Optimize for frequent updates */
    contain: layout style paint;
    
    /* Prevent subpixel rendering issues */
    transform: translateZ(0);
}

/* Loading state optimizations */
.virtualized-file-list .loading-overlay {
    /* Use backdrop-filter for better performance */
    backdrop-filter: blur(2px);
    
    /* Optimize positioning */
    position: absolute;
    inset: 0;
    
    /* Prevent interaction during loading */
    pointer-events: none;
    
    /* Use transform for centering instead of flexbox */
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Memory-efficient animations */
@media (prefers-reduced-motion: no-preference) {
    .virtual-file-item {
        transition: opacity 0.1s ease-out;
    }
}

/* High DPI optimizations */
@media (-webkit-min-device-pixel-ratio: 2) {
    .virtualized-file-list {
        /* Optimize for high DPI displays */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }
} 

================================================
File: frontend/src/components/index.js
================================================
// Component exports for cleaner imports
export { Breadcrumb } from './Breadcrumb';
export { Sidebar } from './Sidebar';
export { FileItem } from './FileItem';
export { ContextMenu } from './ContextMenu';
export { EmptySpaceContextMenu } from './EmptySpaceContextMenu';
export { RetroDialog } from './RetroDialog';
export { VirtualizedFileList } from './VirtualizedFileList'; 

================================================
File: frontend/src/hooks/useClipboard.js
================================================
import { useState, useCallback } from "preact/hooks";

export const useClipboard = () => {
    const [clipboardFiles, setClipboardFiles] = useState([]);
    const [clipboardOperation, setClipboardOperation] = useState(''); // 'copy' or 'cut'

    const handleCopy = useCallback((filePaths) => {
        setClipboardFiles(filePaths);
        setClipboardOperation('copy');
        
        console.log('📋 Copied to clipboard:', filePaths);
        console.log(`📄 ${filePaths.length} item${filePaths.length === 1 ? '' : 's'} copied`);
    }, []);

    const handleCut = useCallback((filePaths) => {
        setClipboardFiles(filePaths);
        setClipboardOperation('cut');
        
        console.log('✂️ Cut to clipboard:', filePaths);
        console.log(`✂️ ${filePaths.length} item${filePaths.length === 1 ? '' : 's'} cut`);
    }, []);

    const clearClipboard = useCallback(() => {
        setClipboardFiles([]);
        setClipboardOperation('');
    }, []);

    const isPasteAvailable = useCallback(() => {
        return clipboardFiles.length > 0 && clipboardOperation !== '';
    }, [clipboardFiles.length, clipboardOperation]);

    return {
        clipboardFiles,
        clipboardOperation,
        handleCopy,
        handleCut,
        clearClipboard,
        isPasteAvailable
    };
}; 

================================================
File: frontend/src/components/VirtualizedFileList.jsx
================================================
import { useState, useEffect, useCallback, useMemo, useRef } from "preact/hooks";
import { memo } from "preact/compat";
import { FileItem } from "./FileItem";

// Virtual scrolling configuration
const ITEM_HEIGHT = 48; // Height of each file item in pixels
const BUFFER_SIZE = 5; // Number of items to render outside visible area
const CONTAINER_HEIGHT = 400; // Default container height

const VirtualizedFileList = memo(({ 
    files, 
    selectedFiles,
    onFileSelect,
    onFileOpen,
    onContextMenu,
    isLoading,
    clipboardFiles,
    clipboardOperation,
    containerHeight
}) => {
    const [scrollTop, setScrollTop] = useState(0);
    const containerRef = useRef(null);
    
    // Calculate visible range
    const visibleRange = useMemo(() => {
        const effectiveHeight = containerHeight || CONTAINER_HEIGHT;
        const visibleStart = Math.floor(scrollTop / ITEM_HEIGHT);
        const visibleEnd = Math.min(
            files.length - 1,
            Math.ceil((scrollTop + effectiveHeight) / ITEM_HEIGHT)
        );
        
        // Add buffer for smooth scrolling
        const startIndex = Math.max(0, visibleStart - BUFFER_SIZE);
        const endIndex = Math.min(files.length - 1, visibleEnd + BUFFER_SIZE);
        
        return { startIndex, endIndex, visibleStart, visibleEnd };
    }, [scrollTop, containerHeight, files.length]);
    
    // Get visible items
    const visibleItems = useMemo(() => {
        const { startIndex, endIndex } = visibleRange;
        return files.slice(startIndex, endIndex + 1).map((file, index) => ({
            file,
            index: startIndex + index,
            offsetTop: (startIndex + index) * ITEM_HEIGHT
        }));
    }, [files, visibleRange]);
    
    // Handle scroll
    const handleScroll = useCallback((event) => {
        const newScrollTop = event.target.scrollTop;
        setScrollTop(newScrollTop);
    }, []);
    
    // Scroll to item (for keyboard navigation)
    const scrollToItem = useCallback((index) => {
        if (containerRef.current) {
            const effectiveHeight = containerHeight || CONTAINER_HEIGHT;
            const targetScrollTop = index * ITEM_HEIGHT;
            const containerScrollTop = containerRef.current.scrollTop;
            const containerBottom = containerScrollTop + effectiveHeight;
            
            // Only scroll if item is not visible
            if (targetScrollTop < containerScrollTop) {
                containerRef.current.scrollTop = targetScrollTop;
            } else if (targetScrollTop + ITEM_HEIGHT > containerBottom) {
                containerRef.current.scrollTop = targetScrollTop - effectiveHeight + ITEM_HEIGHT;
            }
        }
    }, [containerHeight]);
    
    // Total height for scrollbar
    const totalHeight = files.length * ITEM_HEIGHT;
    
    // Optimize file item click handlers
    const handleFileClick = useCallback((fileIndex, event) => {
        onFileSelect(fileIndex, event.shiftKey, event.ctrlKey || event.metaKey);
        
        // Scroll to item if needed
        if (event.shiftKey || event.ctrlKey || event.metaKey) {
            scrollToItem(fileIndex);
        }
    }, [onFileSelect, scrollToItem]);
    
    const handleFileDoubleClick = useCallback((file) => {
        onFileOpen(file);
    }, [onFileOpen]);
    
    const handleFileContextMenu = useCallback((event, file) => {
        onContextMenu(event, file);
    }, [onContextMenu]);
    
    return (
        <div 
            ref={containerRef}
            className="virtualized-file-list custom-scrollbar"
            style={{ 
                height: containerHeight || '100%', 
                overflowY: 'auto',
                overflowX: 'hidden',
                position: 'relative'
            }}
            onScroll={handleScroll}
        >
            {/* Virtual container with total height */}
            <div style={{ height: totalHeight, position: 'relative' }}>
                {/* Render only visible items */}
                {visibleItems.map(({ file, index, offsetTop }) => (
                    <div
                        key={`${file.path}-${index}`}
                        style={{
                            position: 'absolute',
                            top: offsetTop,
                            left: 0,
                            right: 0,
                            height: ITEM_HEIGHT
                        }}
                    >
                        <FileItem
                            file={file}
                            fileIndex={index}
                            onSelect={handleFileClick}
                            onOpen={handleFileDoubleClick}
                            onContextMenu={handleFileContextMenu}
                            isLoading={isLoading}
                            isSelected={selectedFiles.has(index)}
                            isCut={clipboardOperation === 'cut' && clipboardFiles.includes(file.path)}
                        />
                    </div>
                ))}
            </div>
            
            {/* Empty state */}
            {files.length === 0 && (
                <div style={{ 
                    display: 'flex', 
                    flexDirection: 'column', 
                    alignItems: 'center', 
                    justifyContent: 'center', 
                    height: '100%',
                    color: 'var(--blueprint-text-muted)' 
                }}>
                    <div style={{ fontSize: '48px', marginBottom: '16px' }}>📁</div>
                    <div className="text-technical">Directory is empty</div>
                </div>
            )}
        </div>
    );
});

export { VirtualizedFileList }; 

================================================
File: backend/platform.go
================================================
package backend

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"syscall"
)

// NewPlatformManager creates a new platform manager instance
func NewPlatformManager() *PlatformManager {
	return &PlatformManager{}
}

// GetHomeDirectory returns the user's home directory
func (p *PlatformManager) GetHomeDirectory() string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		log.Printf("Error getting home directory: %v", err)
		return ""
	}
	return homeDir
}

// GetCurrentWorkingDirectory returns the current working directory
func (p *PlatformManager) GetCurrentWorkingDirectory() string {
	cwd, err := os.Getwd()
	if err != nil {
		log.Printf("Error getting current working directory: %v", err)
		return ""
	}
	return cwd
}

// GetSystemRoots returns system root paths (drives on Windows, / on Unix)
func (p *PlatformManager) GetSystemRoots() []string {
	var roots []string

	switch runtime.GOOS {
	case "windows":
		// Get all drives on Windows
		for i := 'A'; i <= 'Z'; i++ {
			drive := fmt.Sprintf("%c:\\", i)
			if _, err := os.Stat(drive); err == nil {
				roots = append(roots, drive)
			}
		}
	default:
		// Unix-like systems start from root
		roots = append(roots, "/")
	}

	return roots
}

// OpenInSystemExplorer opens the given path in the system's default file manager
func (p *PlatformManager) OpenInSystemExplorer(path string) bool {
	var cmd string
	var args []string

	switch runtime.GOOS {
	case "windows":
		cmd = "explorer"
		args = []string{path}
	case "darwin":
		cmd = "open"
		args = []string{path}
	case "linux":
		cmd = "xdg-open"
		args = []string{path}
	default:
		log.Printf("OpenInSystemExplorer not supported on %s", runtime.GOOS)
		return false
	}

	err := exec.Command(cmd, args...).Start()
	if err != nil {
		log.Printf("Error opening in system explorer: %v", err)
		return false
	}
	return true
}

// OpenFile opens a file with its default application
func (p *PlatformManager) OpenFile(filePath string) bool {
	log.Printf("Opening file with default application: %s", filePath)

	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "windows":
		// Use rundll32 with shell32.dll to open file without showing command prompt
		cmd = exec.Command("rundll32.exe", "shell32.dll,ShellExec_RunDLL", filePath)
		cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}
	case "darwin":
		cmd = exec.Command("open", filePath)
	case "linux":
		cmd = exec.Command("xdg-open", filePath)
	default:
		log.Printf("Unsupported operating system: %s", runtime.GOOS)
		return false
	}

	err := cmd.Start()
	if err != nil {
		log.Printf("Error opening file: %v", err)
		return false
	}

	log.Printf("Successfully opened file: %s", filePath)
	return true
}

// IsHiddenWindows checks if a file has the Windows hidden attribute
func (p *PlatformManager) IsHiddenWindows(filePath string) bool {
	if runtime.GOOS != "windows" {
		return false
	}

	// Use attrib command to check hidden attribute
	cmd := exec.Command("attrib", filePath)
	cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}

	output, err := cmd.Output()
	if err != nil {
		return false
	}

	// Parse attrib output - hidden files show 'H' in the attribute string
	outputStr := string(output)
	lines := strings.Split(outputStr, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.Contains(line, filePath) {
			parts := strings.Fields(line)
			if len(parts) > 0 {
				attributes := parts[0]
				return strings.Contains(attributes, "H")
			}
		}
	}

	return false
}

// IsHiddenMac checks if a file is hidden on macOS
func (p *PlatformManager) IsHiddenMac(filePath string) bool {
	if runtime.GOOS != "darwin" {
		return false
	}

	fileName := filepath.Base(filePath)
	// Files starting with dot are hidden on macOS
	return strings.HasPrefix(fileName, ".")
}

// IsHiddenLinux checks if a file is hidden on Linux
func (p *PlatformManager) IsHiddenLinux(filePath string) bool {
	if runtime.GOOS != "linux" {
		return false
	}

	fileName := filepath.Base(filePath)
	// Files starting with dot are hidden on Linux
	return strings.HasPrefix(fileName, ".")
}

// IsHidden checks if a file/directory is hidden using OS-specific methods
func (p *PlatformManager) IsHidden(filePath string) bool {
	// Check for dot prefix (universal Unix convention)
	fileName := filepath.Base(filePath)
	if strings.HasPrefix(fileName, ".") {
		return true
	}

	// Check OS-specific hidden attributes
	switch runtime.GOOS {
	case "windows":
		return p.IsHiddenWindows(filePath)
	case "darwin":
		return p.IsHiddenMac(filePath)
	case "linux":
		return p.IsHiddenLinux(filePath)
	default:
		return false
	}
}

// HideFileWindows sets the hidden attribute on Windows using attrib command
func (p *PlatformManager) HideFileWindows(filePath string) bool {
	if runtime.GOOS != "windows" {
		return false
	}

	log.Printf("Setting hidden attribute on Windows: %s", filePath)

	cmd := exec.Command("attrib", "+H", filePath)
	cmd.SysProcAttr = &syscall.SysProcAttr{HideWindow: true}

	err := cmd.Run()
	if err != nil {
		log.Printf("Failed to hide file using attrib: %v", err)
		return false
	}

	log.Printf("Successfully set hidden attribute: %s", filePath)
	return true
}

// HideFileMac hides file on macOS by adding a dot prefix (if not already hidden)
func (p *PlatformManager) HideFileMac(filePath string) bool {
	if runtime.GOOS != "darwin" {
		return false
	}

	log.Printf("Hiding file on macOS: %s", filePath)

	fileName := filepath.Base(filePath)
	if strings.HasPrefix(fileName, ".") {
		log.Printf("File is already hidden: %s", filePath)
		return true
	}

	dir := filepath.Dir(filePath)
	newPath := filepath.Join(dir, "."+fileName)

	err := os.Rename(filePath, newPath)
	if err != nil {
		log.Printf("Failed to hide file on macOS: %v", err)
		return false
	}

	log.Printf("Successfully hid file on macOS: %s -> %s", filePath, newPath)
	return true
}

// HideFileLinux hides file on Linux by adding a dot prefix (if not already hidden)
func (p *PlatformManager) HideFileLinux(filePath string) bool {
	if runtime.GOOS != "linux" {
		return false
	}

	log.Printf("Hiding file on Linux: %s", filePath)

	fileName := filepath.Base(filePath)
	if strings.HasPrefix(fileName, ".") {
		log.Printf("File is already hidden: %s", filePath)
		return true
	}

	dir := filepath.Dir(filePath)
	newPath := filepath.Join(dir, "."+fileName)

	err := os.Rename(filePath, newPath)
	if err != nil {
		log.Printf("Failed to hide file on Linux: %v", err)
		return false
	}

	log.Printf("Successfully hid file on Linux: %s -> %s", filePath, newPath)
	return true
}

// HideFile sets the hidden attribute on a file using OS-specific methods
func (p *PlatformManager) HideFile(filePath string) bool {
	switch runtime.GOOS {
	case "windows":
		return p.HideFileWindows(filePath)
	case "darwin":
		return p.HideFileMac(filePath)
	case "linux":
		return p.HideFileLinux(filePath)
	default:
		log.Printf("Hide file not supported on %s", runtime.GOOS)
		return false
	}
}

// GetExtension returns the file extension in lowercase
func (p *PlatformManager) GetExtension(name string) string {
	ext := filepath.Ext(name)
	if ext != "" {
		return strings.ToLower(ext[1:]) // Remove the dot and convert to lowercase
	}
	return ""
}

// FormatFileSize formats file size in human readable format
func (p *PlatformManager) FormatFileSize(size int64) string {
	const unit = 1024
	if size < unit {
		return fmt.Sprintf("%d B", size)
	}

	div, exp := int64(unit), 0
	for n := size / unit; n >= unit; n /= unit {
		div *= unit
		exp++
	}

	units := []string{"KB", "MB", "GB", "TB", "PB"}
	return fmt.Sprintf("%.1f %s", float64(size)/float64(div), units[exp])
}


================================================
File: frontend/src/hooks/index.js
================================================
// Custom hooks for the File Explorer
export { useNavigation } from './useNavigation';
export { useDialogs } from './useDialogs';
export { useContextMenus } from './useContextMenus';
export { usePerformanceMonitoring } from './usePerformanceMonitoring';
export { useKeyboardShortcuts } from './useKeyboardShortcuts';

// Re-export existing hooks
export { useFileOperations } from './useFileOperations';
export { useSelection } from './useSelection';
export { useClipboard } from './useClipboard'; 

================================================
File: frontend/src/style.css
================================================
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap');

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Blueprint Technical Theme */
:root {
  --blueprint-bg: #0a0e1a;
  --blueprint-surface: #1a2332;
  --blueprint-surface-hover: #2a3442;
  --blueprint-primary: #3b82f6;
  --blueprint-secondary: #1e40af;
  --blueprint-accent: #60a5fa;
  --blueprint-grid: #1e3a8a;
  --blueprint-border: #374151;
  --blueprint-text: #f8fafc;
  --blueprint-text-muted: #94a3b8;
  --blueprint-text-dim: #64748b;
  
  /* Status colors */
  --blueprint-success: #10b981;
  --blueprint-warning: #f59e0b;
  --blueprint-error: #ef4444;
  --blueprint-info: #06b6d4;
  
  /* Shadows */
  --blueprint-shadow: rgba(59, 130, 246, 0.15);
  --blueprint-shadow-strong: rgba(59, 130, 246, 0.25);
}

/* Base styles */
* {
  box-sizing: border-box;
}

/* Performance optimizations */
.file-explorer {
  will-change: scroll-position;
  transform: translateZ(0);
}

.file-list {
  will-change: scroll-position;
  transform: translateZ(0);
}

body {
  margin: 0;
  padding: 0;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: var(--blueprint-bg);
  color: var(--blueprint-text);
  overflow: hidden;
}

.mono {
  font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
}

/* Minimalist background */
.blueprint-bg {
  background: var(--blueprint-bg);
  position: relative;
}

/* Panel system */
.blueprint-panel {
  background: var(--blueprint-surface);
  border: 1px solid var(--blueprint-border);
  border-radius: 4px;
  position: relative;
  overflow: hidden;
}

.blueprint-panel-header {
  background: var(--blueprint-surface);
  color: var(--blueprint-text);
  padding: 12px 16px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  border-bottom: 1px solid var(--blueprint-border);
}

/* File explorer specific styles */
.file-explorer {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.file-list {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 8px;
  min-height: 0; /* Fix flex height calculation */
  max-width: 100%; /* Prevent horizontal overflow */
}

.file-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  margin: 2px 0;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.08s ease;
  font-size: 13px;
  border: 1px solid transparent;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

.file-item:hover:not(.selected) {
  background: var(--blueprint-surface-hover);
  border-color: var(--blueprint-border);
  transform: translateY(-1px);
}

.file-item.selected {
  background: var(--blueprint-primary);
  color: white;
  border-color: var(--blueprint-primary);
  transform: translateY(-1px);
}

.file-item.selected:hover {
  background: var(--blueprint-primary);
  color: white;
  border-color: var(--blueprint-primary);
  transform: translateY(-2px);
  /* Enhanced selected hover state for better feedback */
  box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
}

.file-item:active {
  transform: scale(0.98);
}

.file-item.selected:active {
  transform: translateY(0px) scale(0.98);
}

.file-item.cut {
  opacity: 0.5;
  filter: grayscale(50%);
  border-style: dashed;
}

.file-icon {
  width: 20px;
  height: 20px;
  margin-right: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: 600;
  border-radius: 3px;
  flex-shrink: 0;
}

.file-icon.folder {
  background: var(--blueprint-primary);
  color: white;
}

.file-icon.file {
  background: var(--blueprint-text-muted);
  color: var(--blueprint-bg);
}

.file-icon.code {
  background: var(--blueprint-success);
  color: white;
}

.file-icon.image {
  background: #e91e63;
  color: white;
}

.file-icon.document {
  background: var(--blueprint-info);
  color: white;
}

.file-icon.archive {
  background: var(--blueprint-warning);
  color: white;
}

.file-icon.executable {
  background: var(--blueprint-error);
  color: white;
}

.file-details {
  flex: 1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  overflow: hidden;
}

.file-name {
  font-weight: 500;
  truncate: true;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.file-meta {
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  color: var(--blueprint-text-muted);
  display: flex;
  gap: 16px;
  flex-shrink: 0;
  margin-left: 16px;
}

/* Navigation */
.nav-breadcrumb {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  background: var(--blueprint-surface);
  border-bottom: 1px solid var(--blueprint-border);
  font-family: 'JetBrains Mono', monospace;
  font-size: 12px;
  overflow-x: auto;
}

.nav-breadcrumb .separator {
  margin: 0 8px;
  color: var(--blueprint-text-muted);
}

.nav-segment {
  color: var(--blueprint-text-muted);
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 3px;
  transition: all 0.05s ease;
}

.nav-segment:hover {
  background: var(--blueprint-surface-hover);
  color: var(--blueprint-text);
  transform: scale(1.05);
}

.nav-segment:active {
  transform: scale(0.98);
}

.nav-segment.current {
  color: var(--blueprint-primary);
  font-weight: 600;
}

/* Toolbar */
.toolbar {
  display: flex;
  align-items: center;
  padding: 8px 16px;
  background: var(--blueprint-surface);
  border-bottom: 1px solid var(--blueprint-border);
  gap: 8px;
}

.toolbar-btn {
  padding: 6px 12px;
  background: transparent;
  border: 1px solid var(--blueprint-border);
  color: var(--blueprint-text);
  border-radius: 4px;
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.06s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.toolbar-btn:hover {
  background: var(--blueprint-primary);
  border-color: var(--blueprint-primary);
  color: white;
  transform: translateY(-1px);
}

.toolbar-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.toolbar-btn:disabled:hover {
  background: transparent;
  border-color: var(--blueprint-border);
  color: var(--blueprint-text);
  transform: none;
}

.toolbar-btn:active {
  transform: translateY(0px) scale(0.98);
}

.toolbar-btn.active {
  background: var(--blueprint-primary);
  color: white;
  border-color: var(--blueprint-primary);
}

/* Sidebar */
.sidebar {
  width: 250px;
  background: var(--blueprint-surface);
  border-right: 1px solid var(--blueprint-border);
  display: flex;
  flex-direction: column;
}

.sidebar-section {
  margin: 16px 12px;
}

.sidebar-title {
  font-family: 'JetBrains Mono', monospace;
  font-size: 10px;
  font-weight: 600;
  color: var(--blueprint-text-muted);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 8px;
  padding: 0 8px;
}

.sidebar-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  color: var(--blueprint-text-muted);
  cursor: pointer;
  border-radius: 4px;
  font-size: 13px;
  margin: 2px 0;
  transition: all 0.06s ease;
}

.sidebar-item:hover:not(.active) {
  background: var(--blueprint-surface-hover);
  color: var(--blueprint-text);
  transform: translateX(2px);
}

.sidebar-item:active:not(.active) {
  transform: translateX(1px) scale(0.98);
}

.sidebar-item.active {
  background: var(--blueprint-primary);
  color: white;
}

.sidebar-item.active:hover {
  background: var(--blueprint-primary);
  color: white;
  transform: translateX(1px);
  /* Enhanced active hover state for better feedback */
  box-shadow: 0 2px 6px rgba(59, 130, 246, 0.3);
}

.sidebar-item.active:active {
  background: var(--blueprint-primary);
  color: white;
  transform: translateX(0px) scale(0.98);
}

.sidebar-icon {
  margin-right: 8px;
  font-size: 14px;
}

/* Status bar */
.status-bar {
  height: 28px;
  background: var(--blueprint-surface);
  border-top: 1px solid var(--blueprint-border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  color: var(--blueprint-text-muted);
}

/* Loading states */
.loading-spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid var(--blueprint-border);
  border-top: 2px solid var(--blueprint-primary);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  will-change: transform;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(26, 35, 50, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(4px);
}

/* Custom scrollbar */
.custom-scrollbar::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

.custom-scrollbar::-webkit-scrollbar-track {
  background: var(--blueprint-surface);
}

.custom-scrollbar::-webkit-scrollbar-thumb {
  background: var(--blueprint-border);
  border-radius: 4px;
}

.custom-scrollbar::-webkit-scrollbar-thumb:hover {
  background: var(--blueprint-primary);
}

/* Utilities */
.text-technical {
  font-family: 'JetBrains Mono', monospace;
  font-size: 11px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Error states */
.error-message {
  background: rgba(239, 68, 68, 0.1);
  border: 1px solid var(--blueprint-error);
  color: var(--blueprint-error);
  padding: 12px 16px;
  border-radius: 4px;
  margin: 8px;
  font-size: 13px;
}

.success-message {
  background: rgba(16, 185, 129, 0.1);
  border: 1px solid var(--blueprint-success);
  color: var(--blueprint-success);
  padding: 12px 16px;
  border-radius: 4px;
  margin: 8px;
  font-size: 13px;
}

/* Header system */
.app-header {
  height: 48px;
  background: var(--blueprint-surface);
  display: flex;
  align-items: center;
  padding: 0 16px;
  border-bottom: 1px solid var(--blueprint-border);
}

.app-title {
  font-family: 'JetBrains Mono', monospace;
  font-size: 14px;
  font-weight: 700;
  color: var(--blueprint-text);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.app-subtitle {
  font-size: 11px;
  color: rgba(255, 255, 255, 0.7);
  margin-left: 8px;
}

/* Main layout */
.main-content {
  display: flex;
  height: calc(100vh - 48px - 28px); /* minus header and status bar */
  min-height: 0; /* Fix flex height calculation */
}

.content-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0; /* Fix flex height calculation */
  overflow: hidden; /* Prevent content overflow */
}

/* 8-bit Context Menu */
.context-menu {
  position: fixed;
  background: #1e1e2e;
  border: 3px solid #5599ff;
  border-radius: 0;
  box-shadow: 
    6px 6px 0px #3366cc,
    12px 12px 0px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  min-width: 220px;
  overflow: hidden;
  padding: 4px;
  animation: contextMenuAppear 0.1s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  transform-origin: top left;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
}

@keyframes contextMenuAppear {
  from {
    opacity: 0;
    transform: scale(0.9) rotate(-1deg);
  }
  to {
    opacity: 1;
    transform: scale(1) rotate(0deg);
  }
}

.context-menu-item {
  display: flex;
  align-items: center;
  padding: 8px 12px;
  cursor: pointer;
  background: transparent;
  border: none;
  width: 100%;
  text-align: left;
  color: #ffffff;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  transition: all 0.1s ease;
  border: 2px solid transparent;
}

.context-menu-item:hover {
  background: #5599ff;
  color: #ffffff;
  border: 2px solid #77aaff;
  box-shadow: inset 0 0 8px rgba(119, 170, 255, 0.3);
  transform: translateY(-1px);
}

.context-menu-item:active {
  transform: translateY(0px);
  box-shadow: inset 0 0 4px rgba(51, 102, 204, 0.5);
}

.context-menu-icon {
  margin-right: 8px;
  font-weight: bold;
  font-size: 10px;
  color: #77aaff;
  min-width: 16px;
  text-align: center;
}

.context-menu-text {
  flex: 1;
}

.context-menu-separator {
  height: 3px;
  background: #3366cc;
  margin: 4px 8px;
  border: none;
  box-shadow: 0 1px 0 #77aaff;
}

/* Empty space context menu - 8-bit retro styling with no shadows */
.empty-space-context-menu {
  background: #1a1a2e;
  border: 4px solid #5599ff;
  border-radius: 0; /* Blocky, no rounded corners */
  min-width: 220px;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  /* No box-shadow for 8-bit aesthetic - completely flat */
  animation: emptySpaceContextMenuAppear 0.15s cubic-bezier(0.25, 0.1, 0.25, 1);
  z-index: 1001;
}

@keyframes emptySpaceContextMenuAppear {
  from {
    opacity: 0;
    transform: scale(0.9) translateY(-4px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.empty-space-context-menu .context-menu-item {
  padding: 14px 18px;
  cursor: pointer;
  transition: all 0.08s ease;
  background: #1a1a2e;
  border: none;
  border-bottom: 3px solid #3366cc;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  display: flex;
  align-items: center;
}

.empty-space-context-menu .context-menu-item:last-child {
  border-bottom: none;
}

.empty-space-context-menu .context-menu-item:hover {
  background: #5599ff;
  color: #ffffff;
  transform: translateX(3px); /* 8-bit movement effect */
}

.empty-space-context-menu .context-menu-item:active {
  background: #3366cc;
  color: #ffffff;
  transform: translateX(1px) scale(0.98);
}

.empty-space-context-menu .context-menu-icon {
  width: 28px;
  display: inline-block;
  margin-right: 10px;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-weight: bold;
  color: #77aaff;
  font-size: 13px;
}

.empty-space-context-menu .context-menu-text {
  color: #e0e0e0;
  font-weight: 600;
  font-size: 12px;
}

.empty-space-context-menu .context-menu-item:hover .context-menu-icon,
.empty-space-context-menu .context-menu-item:hover .context-menu-text {
  color: #ffffff;
}

/* 8-bit Retro Dialog Styles */
.retro-dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  backdrop-filter: blur(4px);
  animation: dialogOverlayAppear 0.2s ease-out;
}

@keyframes dialogOverlayAppear {
  from {
    opacity: 0;
    backdrop-filter: blur(0px);
  }
  to {
    opacity: 1;
    backdrop-filter: blur(4px);
  }
}

.retro-dialog {
  background: #1a1a2e;
  border: 4px solid #5599ff;
  border-radius: 0;
  box-shadow: 
    8px 8px 0px #3366cc,
    16px 16px 0px rgba(0, 0, 0, 0.4),
    inset 0 0 20px rgba(85, 153, 255, 0.1);
  min-width: 400px;
  max-width: 600px;
  max-height: 80vh;
  overflow: hidden;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  animation: dialogAppear 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  transform-origin: center;
}

@keyframes dialogAppear {
  from {
    opacity: 0;
    transform: scale(0.8) rotate(-2deg) translateY(-50px);
  }
  50% {
    transform: scale(1.05) rotate(1deg) translateY(-10px);
  }
  to {
    opacity: 1;
    transform: scale(1) rotate(0deg) translateY(0px);
  }
}

.retro-dialog-header {
  background: #5599ff;
  border-bottom: 3px solid #77aaff;
  padding: 12px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.retro-dialog-header::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: #77aaff;
  animation: headerGlow 2s ease-in-out infinite alternate;
}

@keyframes headerGlow {
  from {
    opacity: 0.3;
  }
  to {
    opacity: 0.8;
  }
}

.retro-dialog-title {
  color: #ffffff;
  font-size: 13px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}

.retro-dialog-close {
  background: transparent;
  border: 2px solid #77aaff;
  color: #ffffff;
  width: 28px;
  height: 28px;
  cursor: pointer;
  font-family: inherit;
  font-size: 14px;
  font-weight: bold;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.retro-dialog-close:hover {
  background: #ff5555;
  border-color: #ff7777;
  color: #ffffff;
  transform: scale(1.1);
  box-shadow: 0 0 8px rgba(255, 85, 85, 0.5);
}

.retro-dialog-close:active {
  transform: scale(0.95);
}

.retro-dialog-content {
  padding: 24px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  background: #1a1a2e;
  position: relative;
}

.retro-dialog-content::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(85, 153, 255, 0.03);
  pointer-events: none;
}

.retro-dialog-icon {
  font-size: 48px;
  text-align: center;
  margin-bottom: 8px;
  filter: drop-shadow(0 0 8px currentColor);
  animation: iconPulse 2s ease-in-out infinite;
}

/* Remove UI backgrounds for pencil emoji in rename dialog */
.retro-dialog.prompt-type .retro-dialog-icon {
  filter: none !important;
  animation: none !important;
}

/* Minimalist trash can icon for delete operations - remove shadows and effects */
.retro-dialog.delete-type .retro-dialog-icon {
  filter: none !important;
  animation: none !important;
  text-shadow: none !important;
}

@keyframes iconPulse {
  0%, 100% {
    transform: scale(1);
    filter: drop-shadow(0 0 8px currentColor);
  }
  50% {
    transform: scale(1.05);
    filter: drop-shadow(0 0 12px currentColor);
  }
}

.retro-dialog-message {
  color: #e0e0e0;
  font-size: 12px;
  line-height: 1.6;
  text-align: center;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  word-break: break-word;
}

.retro-dialog-input-container {
  margin-top: 16px;
}

.retro-dialog-input {
  width: 100%;
  background: #0d1226;
  border: 3px solid #3366cc;
  color: #ffffff;
  padding: 12px 16px;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  outline: none;
  transition: all 0.2s ease;
  box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
}

.retro-dialog-input:focus {
  border-color: #5599ff;
  box-shadow: 
    inset 0 0 10px rgba(0, 0, 0, 0.5),
    0 0 0 2px rgba(85, 153, 255, 0.3),
    0 0 12px rgba(85, 153, 255, 0.4);
  background: #0f1528;
}

.retro-dialog-input::placeholder {
  color: #666;
  opacity: 1;
}

.retro-dialog-buttons {
  display: flex;
  gap: 12px;
  justify-content: center;
  padding: 16px 24px 24px;
  background: #1a1a2e;
  border-top: 3px solid #3366cc;
}

.retro-dialog-btn {
  background: #2a4d7a;
  border: 3px solid #5599ff;
  color: #ffffff;
  padding: 12px 20px;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
  min-width: 120px;
  box-shadow: 
    0 4px 0 #3366cc,
    0 4px 8px rgba(0, 0, 0, 0.3);
}

.retro-dialog-btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.2);
  transition: left 0.5s ease;
}

.retro-dialog-btn:hover {
  transform: translateY(-2px);
  box-shadow: 
    0 6px 0 #3366cc,
    0 6px 12px rgba(0, 0, 0, 0.4),
    0 0 16px rgba(85, 153, 255, 0.3);
  border-color: #77aaff;
}

.retro-dialog-btn:hover::before {
  left: 100%;
}

.retro-dialog-btn:active {
  transform: translateY(2px);
  box-shadow: 
    0 2px 0 #3366cc,
    0 2px 4px rgba(0, 0, 0, 0.3);
}

.retro-dialog-btn-primary {
  background: #5599ff;
  border-color: #77aaff;
  box-shadow: 
    0 4px 0 #2244aa,
    0 4px 8px rgba(0, 0, 0, 0.3);
}

.retro-dialog-btn-primary:hover {
  background: #66aaff;
  box-shadow: 
    0 6px 0 #2244aa,
    0 6px 12px rgba(0, 0, 0, 0.4),
    0 0 16px rgba(102, 170, 255, 0.4);
}

.retro-dialog-btn-primary:active {
  box-shadow: 
    0 2px 0 #2244aa,
    0 2px 4px rgba(0, 0, 0, 0.3);
}

.retro-dialog-btn-secondary {
  background: #666;
  border-color: #888;
  box-shadow: 
    0 4px 0 #333,
    0 4px 8px rgba(0, 0, 0, 0.3);
}

.retro-dialog-btn-secondary:hover {
  background: #777;
  border-color: #999;
  box-shadow: 
    0 6px 0 #333,
    0 6px 12px rgba(0, 0, 0, 0.4),
    0 0 16px rgba(136, 136, 136, 0.3);
}

.retro-dialog-btn-secondary:active {
  box-shadow: 
    0 2px 0 #333,
    0 2px 4px rgba(0, 0, 0, 0.3);
}

/* Responsive dialog */
@media (max-width: 480px) {
  .retro-dialog {
    min-width: 300px;
    margin: 16px;
  }
  
  .retro-dialog-buttons {
    flex-direction: column;
  }
  
  .retro-dialog-btn {
    min-width: auto;
  }
}

/* Drag and Drop Styles */
.file-item[draggable="true"]:hover {
  cursor: grab;
}

.file-item[draggable="true"]:active {
  cursor: grabbing;
}

.file-item.drag-over {
  background: var(--blueprint-primary) !important;
  border-color: var(--blueprint-primary) !important;
  color: white !important;
  transform: translateY(-2px) scale(1.02);
  will-change: transform;
  /* Ensure drag-over styling works with selected items */
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4) !important;
}

/* Drag feedback for files being dragged */
.file-item.dragging {
  opacity: 0.6;
}

/* Drop zone indicator */
.drop-zone-active {
  border: 1px dashed var(--blueprint-primary);
  background: rgba(59, 130, 246, 0.05);
  border-radius: 4px;
}

/* Responsive Design for Mobile and Tablet */
@media (max-width: 768px) {
  .main-content {
    flex-direction: column;
  }
  
  .sidebar {
    width: 100%;
    height: auto;
    border-right: none;
    border-bottom: 1px solid var(--blueprint-border);
    order: 2;
  }
  
  .sidebar-section {
    margin: 8px;
  }
  
  .sidebar-item {
    padding: 12px;
    font-size: 14px;
  }
  
  .content-area {
    order: 1;
  }
  
  .toolbar {
    flex-wrap: wrap;
    gap: 4px;
  }
  
  .toolbar-btn {
    font-size: 10px;
    padding: 8px 10px;
  }
  
  .nav-breadcrumb {
    font-size: 11px;
    padding: 8px 12px;
  }
  
  .file-item {
    padding: 12px;
    margin: 1px 0;
  }
  
  .file-icon {
    width: 24px;
    height: 24px;
    font-size: 12px;
  }
  
  .file-name {
    font-size: 14px;
  }
  
  .file-meta {
    font-size: 10px;
    gap: 8px;
  }
  
  .app-header {
    padding: 0 12px;
    height: 44px;
  }
  
  .app-title {
    font-size: 12px;
  }
  
  .text-technical {
    font-size: 10px;
  }
  
  .status-bar {
    font-size: 10px;
    padding: 0 12px;
    height: 32px;
  }
  
  .context-menu {
    min-width: 180px;
    font-size: 12px;
  }
  
  .context-menu-item {
    padding: 12px;
  }
}

@media (max-width: 480px) {
  .sidebar {
    display: none; /* Hide sidebar on very small screens */
  }
  
  .main-content {
    height: calc(100vh - 44px - 32px);
  }
  
  .toolbar {
    padding: 4px 8px;
  }
  
  .toolbar-btn {
    font-size: 9px;
    padding: 6px 8px;
  }
  
  .nav-breadcrumb {
    font-size: 10px;
    padding: 6px 8px;
  }
  
  .file-item {
    padding: 10px 8px;
  }
  
  .file-details {
    flex-direction: column;
    align-items: flex-start;
    gap: 4px;
  }
  
  .file-meta {
    margin-left: 0;
    gap: 12px;
  }
  
  .app-header {
    padding: 0 8px;
    height: 40px;
  }
  
  .status-bar {
    padding: 0 8px;
    height: 28px;
  }
}

/* Touch-friendly improvements */
@media (hover: none) and (pointer: coarse) {
  .file-item {
    padding: 16px 12px;
    min-height: 60px;
  }
  
  .toolbar-btn {
    padding: 12px 16px;
    min-height: 44px;
  }
  
  .sidebar-item {
    padding: 16px 12px;
    min-height: 50px;
  }
  
  .nav-segment {
    padding: 8px 12px;
    min-height: 40px;
  }
  
  .context-menu-item {
    padding: 16px 12px;
    min-height: 50px;
  }
  
  .retro-dialog-btn {
    padding: 16px 24px;
    min-height: 50px;
  }
}

/* Performance optimizations */
.file-list {
  contain: layout style paint;
  will-change: scroll-position;
}

.file-item {
  contain: layout style paint;
}

.file-item:hover,
.file-item.selected {
  will-change: transform, background-color;
}

/* Smooth scrolling for better UX */
.custom-scrollbar {
  scroll-behavior: smooth;
}

/* Improved loading states */
.loading-overlay {
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}

.loading-spinner {
  will-change: transform;
}

/* Reduce motion for accessibility */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
  
  .loading-spinner {
    animation: none;
  }
  
  .retro-dialog {
    animation: none;
  }
  
  .context-menu {
    animation: none;
  }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
  :root {
    --blueprint-bg: #000000;
    --blueprint-surface: #1a1a1a;
    --blueprint-text: #ffffff;
    --blueprint-border: #ffffff;
    --blueprint-primary: #00aaff;
  }
}

/* Dark mode optimizations (already dark but for explicit preference) */
@media (prefers-color-scheme: dark) {
  .retro-dialog {
    box-shadow: 
      8px 8px 0px #2244aa,
      16px 16px 0px rgba(0, 0, 0, 0.6),
      inset 0 0 20px rgba(85, 153, 255, 0.15);
  }
}

/* Print styles (hide interactive elements) */
@media print {
  .toolbar,
  .context-menu,
  .retro-dialog-overlay,
  .sidebar {
    display: none !important;
  }
  
  .main-content {
    flex-direction: column;
  }
  
  .file-list {
    background: white;
    color: black;
  }
  
  .file-item {
    border: 1px solid #ccc;
    page-break-inside: avoid;
  }
}


================================================
File: frontend/src/hooks/useKeyboardShortcuts.js
================================================
import { useEffect, useMemo } from "preact/hooks";
import { throttle } from "../utils/debounce";

export function useKeyboardShortcuts({
    handleRefresh,
    handleNavigateUp,
    selectedFiles,
    allFiles,
    handleFileOpen,
    selectAll,
    handleCopySelected,
    handleCutSelected,
    handlePaste,
    isPasteAvailable,
    handleArrowNavigation,
    clearSelection,
    closeContextMenu,
    closeEmptySpaceContextMenu,
    clearCache
}) {
    // Optimized keyboard shortcuts
    const keyboardHandler = useMemo(
        () => throttle((event) => {
            if (event.key === 'F5') {
                event.preventDefault();
                handleRefresh();
            } else if ((event.key === 'Backspace' && !event.target.matches('input, textarea')) || 
                     (event.altKey && event.key === 'ArrowLeft')) {
                event.preventDefault();
                handleNavigateUp();
            } else if (event.key === 'Enter' && selectedFiles.size > 0) {
                event.preventDefault();
                const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
                selectedFileObjects.forEach(file => handleFileOpen(file));
            } else if (event.ctrlKey && event.key === 'a' && !event.target.matches('input, textarea')) {
                event.preventDefault();
                selectAll(allFiles.length);
            } else if (event.ctrlKey && event.key === 'c' && selectedFiles.size > 0) {
                event.preventDefault();
                handleCopySelected();
            } else if (event.ctrlKey && event.key === 'x' && selectedFiles.size > 0) {
                event.preventDefault();
                handleCutSelected();
            } else if (event.ctrlKey && event.key === 'v' && isPasteAvailable()) {
                event.preventDefault();
                handlePaste();
            } else if (event.key === 'ArrowUp' && !event.target.matches('input, textarea')) {
                event.preventDefault();
                handleArrowNavigation('up', allFiles);
            } else if (event.key === 'ArrowDown' && !event.target.matches('input, textarea')) {
                event.preventDefault();
                handleArrowNavigation('down', allFiles);
            } else if (event.key === 'Escape') {
                clearSelection();
                closeContextMenu();
                closeEmptySpaceContextMenu();
            } else if (event.ctrlKey && event.shiftKey && event.key === 'C') {
                // Clear both frontend and backend cache
                event.preventDefault();
                clearCache();
            }
        }, 50), // Faster response for keyboard
        [
            handleRefresh, 
            handleNavigateUp, 
            selectedFiles, 
            allFiles, 
            handleFileOpen, 
            selectAll, 
            handleCopySelected, 
            handleCutSelected, 
            handlePaste, 
            isPasteAvailable, 
            handleArrowNavigation, 
            clearSelection, 
            closeContextMenu, 
            closeEmptySpaceContextMenu,
            clearCache
        ]
    );

    // Keyboard shortcuts
    useEffect(() => {
        window.addEventListener('keydown', keyboardHandler);
        return () => window.removeEventListener('keydown', keyboardHandler);
    }, [keyboardHandler]);
} 

================================================
File: frontend/src/hooks/useFileOperations.js
================================================
import { useCallback } from "preact/hooks";
import { 
    CopyFiles,
    MoveFiles,
    DeleteFiles,
    MoveFilesToRecycleBin,
    RenameFile,
    OpenFile,
    OpenInSystemExplorer,
    OpenPowerShellHere,
    HideFiles
} from "../../wailsjs/go/backend/App";

export const useFileOperations = (currentPath, setError, clearSelection, handleRefresh, showDialog) => {
    const handleFileOpen = useCallback((file) => {
        console.log('🔍 Opening file/folder:', file);
        console.log('📊 File properties - Name:', file.name, 'IsDir:', file.isDir, 'Path:', file.path);
        
        try {
            if (file.isDir) {
                console.log('📁 Navigating to folder:', file.path);
                // This will be handled by the parent component
                return { type: 'navigate', path: file.path };
            } else {
                console.log('📄 Opening file with default application:', file.path);
                const success = OpenFile(file.path);
                if (!success) {
                    console.warn('⚠️ Failed to open file with default application, falling back to explorer');
                    OpenInSystemExplorer(file.path);
                }
            }
        } catch (err) {
            console.error('❌ Error opening file:', err);
            setError('Failed to open file: ' + err.message);
        }
    }, [setError]);

    const handleCopyFiles = useCallback(async (filePaths) => {
        if (filePaths.length === 0 || !currentPath) return false;

        try {
            console.log(`📥 Copying ${filePaths.length} items to:`, currentPath);
            
            const success = await CopyFiles(filePaths, currentPath);
            
            if (success) {
                console.log('✅ Copy operation successful');
                clearSelection();
                setTimeout(() => {
                    console.log('🔄 Refreshing directory after copy operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('❌ Copy operation failed');
                setError(`Failed to copy files to "${currentPath}". This may be due to:
• Insufficient permissions (try running as administrator)
• Destination folder is read-only
• Not enough disk space
• Files are in use by another application`);
                return false;
            }
        } catch (err) {
            console.error('❌ Error during copy operation:', err);
            setError('Failed to copy files: ' + err.message);
            return false;
        }
    }, [currentPath, setError, clearSelection, handleRefresh]);

    const handleMoveFiles = useCallback(async (filePaths) => {
        if (filePaths.length === 0 || !currentPath) return false;

        try {
            console.log(`📥 Moving ${filePaths.length} items to:`, currentPath);
            
            const success = await MoveFiles(filePaths, currentPath);
            
            if (success) {
                console.log('✅ Move operation successful');
                clearSelection();
                setTimeout(() => {
                    console.log('🔄 Refreshing directory after move operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('❌ Move operation failed');
                setError(`Failed to move files to "${currentPath}". This may be due to:
• Insufficient permissions (try running as administrator)
• Destination folder is read-only
• Files are in use by another application
• Cannot move across different drive types`);
                return false;
            }
        } catch (err) {
            console.error('❌ Error during move operation:', err);
            setError('Failed to move files: ' + err.message);
            return false;
        }
    }, [currentPath, setError, clearSelection, handleRefresh]);

    const handleRecycleBinDelete = useCallback(async (filePaths) => {
        try {
            console.log('🗑️ Moving files to recycle bin:', filePaths);
            
            const success = await MoveFilesToRecycleBin(filePaths);
            
            if (success) {
                console.log('✅ Move to recycle bin successful');
                clearSelection();
                setTimeout(() => {
                    console.log('🔄 Refreshing directory after recycle bin operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('❌ Move to recycle bin failed');
                setError('Failed to move files to recycle bin');
                return false;
            }
        } catch (err) {
            console.error('❌ Error during recycle bin operation:', err);
            setError('Failed to move files to recycle bin: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    const handlePermanentDelete = useCallback(async (filePaths) => {
        try {
            console.log('🗑️ Permanently deleting files:', filePaths);
            
            const success = await DeleteFiles(filePaths);
            
            if (success) {
                console.log('✅ Permanent delete operation successful');
                clearSelection();
                setTimeout(() => {
                    console.log('🔄 Refreshing directory after permanent delete operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('❌ Permanent delete operation failed');
                setError('Failed to permanently delete files');
                return false;
            }
        } catch (err) {
            console.error('❌ Error during permanent delete operation:', err);
            setError('Failed to permanently delete files: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    const handleRename = useCallback(async (filePath, newName) => {
        try {
            console.log('✏️ Renaming file:', filePath, 'to:', newName);
            
            const success = await RenameFile(filePath, newName);
            
            if (success) {
                console.log('✅ Rename operation successful');
                clearSelection();
                setTimeout(() => {
                    console.log('🔄 Refreshing directory after rename operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('❌ Rename operation failed');
                setError(`Failed to rename "${filePath}". This may be due to:
• A file with that name already exists
• Insufficient permissions
• Invalid characters in the new name
• File is in use by another application`);
                return false;
            }
        } catch (err) {
            console.error('❌ Error during rename operation:', err);
            setError('Failed to rename file: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    const handleOpenPowerShell = useCallback(async () => {
        if (!currentPath) {
            console.warn('⚠️ No current path available for PowerShell');
            return;
        }
        
        try {
            console.log('🔧 Opening PowerShell 7 in:', currentPath);
            
            const success = await OpenPowerShellHere(currentPath);
            
            if (!success) {
                console.warn('⚠️ Failed to open PowerShell 7');
                setError('Failed to open PowerShell 7. Please ensure PowerShell 7 is installed at the default location.');
            } else {
                console.log('✅ PowerShell 7 opened successfully in:', currentPath);
            }
        } catch (err) {
            console.error('❌ Error opening PowerShell 7:', err);
            setError('Failed to open PowerShell 7: ' + err.message);
        }
    }, [currentPath, setError]);

    const handleHideFiles = useCallback(async (filePaths) => {
        try {
            console.log('👁️ Hiding files:', filePaths);
            
            const success = await HideFiles(filePaths);
            
            if (success) {
                console.log('✅ Hide files operation successful');
                clearSelection();
                setTimeout(() => {
                    console.log('🔄 Refreshing directory after hide operation');
                    handleRefresh();
                }, 50);
                return true;
            } else {
                console.error('❌ Hide files operation failed');
                setError(`Failed to hide files. This may be due to:
• Insufficient permissions (try running as administrator)
• Files are in use by another application
• Files are on a network drive or external storage`);
                return false;
            }
        } catch (err) {
            console.error('❌ Error during hide files operation:', err);
            setError('Failed to hide files: ' + err.message);
            return false;
        }
    }, [setError, clearSelection, handleRefresh]);

    return {
        handleFileOpen,
        handleCopyFiles,
        handleMoveFiles,
        handleRecycleBinDelete,
        handlePermanentDelete,
        handleRename,
        handleOpenPowerShell,
        handleHideFiles
    };
}; 

================================================
File: frontend/src/hooks/useContextMenus.js
================================================
import { useState, useCallback } from "preact/hooks";

export function useContextMenus(selectedFiles, allFiles, handleCopy, handleCut, showDialog, fileOperations, currentPath, navCache) {
    // Context menu states
    const [contextMenu, setContextMenu] = useState({ visible: false, x: 0, y: 0, files: [] });
    const [emptySpaceContextMenu, setEmptySpaceContextMenu] = useState({ visible: false, x: 0, y: 0 });

    // Context menu handlers
    const handleContextMenu = useCallback((event, file) => {
        const selectedFileObjects = Array.from(selectedFiles).map(index => allFiles[index]);
        
        const contextFiles = selectedFiles.size > 0 && selectedFileObjects.some(f => f.path === file.path) 
            ? selectedFileObjects 
            : [file];
        
        setContextMenu({
            visible: true,
            x: event.clientX,
            y: event.clientY,
            files: contextFiles
        });
    }, [selectedFiles, allFiles]);

    const closeContextMenu = useCallback(() => {
        setContextMenu({ visible: false, x: 0, y: 0, files: [] });
    }, []);

    const handleEmptySpaceContextMenu = useCallback((event) => {
        event.preventDefault();
        setEmptySpaceContextMenu({
            visible: true,
            x: event.clientX,
            y: event.clientY
        });
    }, []);

    const closeEmptySpaceContextMenu = useCallback(() => {
        setEmptySpaceContextMenu({ visible: false, x: 0, y: 0 });
    }, []);

    // Context menu actions
    const handleContextCopy = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        handleCopy(filePaths);
        closeContextMenu();
    }, [contextMenu.files, handleCopy, closeContextMenu]);

    const handleContextCut = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        handleCut(filePaths);
        closeContextMenu();
    }, [contextMenu.files, handleCut, closeContextMenu]);

    const handleContextRename = useCallback(() => {
        if (contextMenu.files.length !== 1) {
            closeContextMenu();
            return;
        }
        
        const file = contextMenu.files[0];
        closeContextMenu();
        
        showDialog(
            'prompt',
            'RENAME FILE',
            `RENAME "${file.name}" TO:`,
            file.name,
            (newName) => {
                if (newName && newName !== file.name && newName.trim() !== '') {
                    fileOperations.handleRename(file.path, newName.trim()).then(() => {
                        // Clear cache to show renamed file
                        navCache.cache.delete(currentPath);
                    });
                }
            }
        );
    }, [contextMenu.files, closeContextMenu, showDialog, fileOperations, currentPath, navCache]);

    const handleContextHide = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        closeContextMenu();
        
        showDialog(
            'confirm',
            'HIDE FILES',
            `HIDE ${filePaths.length} ITEM${filePaths.length === 1 ? '' : 'S'}?\n\nHidden files will not be visible unless "Show Hidden Files" is enabled.`,
            '',
            () => {
                fileOperations.handleHideFiles(filePaths).then(() => {
                    // Clear cache to hide files
                    navCache.cache.delete(currentPath);
                });
            }
        );
    }, [contextMenu.files, closeContextMenu, showDialog, fileOperations, currentPath, navCache]);

    const handlePermanentDelete = useCallback(() => {
        const filePaths = contextMenu.files.map(file => file.path);
        closeContextMenu();
        showDialog('delete', '⚠️ PERMANENT DELETE WARNING', `Permanently delete ${filePaths.length} items? This cannot be undone!`, '', 
            () => {
                fileOperations.handlePermanentDelete(filePaths).then(() => {
                    // Clear cache to reflect changes
                    navCache.cache.delete(currentPath);
                });
            });
    }, [contextMenu.files, closeContextMenu, showDialog, fileOperations, currentPath, navCache]);

    const handleOpenPowerShell = useCallback(() => {
        closeEmptySpaceContextMenu();
        fileOperations.handleOpenPowerShell();
    }, [closeEmptySpaceContextMenu, fileOperations]);

    return {
        contextMenu,
        emptySpaceContextMenu,
        handleContextMenu,
        closeContextMenu,
        handleEmptySpaceContextMenu,
        closeEmptySpaceContextMenu,
        handleContextCopy,
        handleContextCut,
        handleContextRename,
        handleContextHide,
        handlePermanentDelete,
        handleOpenPowerShell
    };
} 

================================================
File: frontend/tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        'wails-dark': 'rgba(27, 38, 54, 1)',
      },
      fontFamily: {
        'nunito': ['Nunito', 'sans-serif'],
      },
    },
  },
  plugins: [],
}



================================================
File: frontend/vite.config.js
================================================
import {defineConfig} from 'vite'
import preact from '@preact/preset-vite'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [preact()]
})


================================================
File: frontend/src/hooks/useOptimizedState.js
================================================
import { useState, useCallback, useMemo } from "preact/hooks";

// Optimized state hook that combines related states to reduce re-renders
export const useOptimizedState = () => {
    // Consolidated navigation state
    const [navigationState, setNavigationState] = useState({
        currentPath: '',
        directoryContents: null,
        isLoading: true,
        error: '',
        drives: []
    });

    // Consolidated UI state
    const [uiState, setUiState] = useState({
        showHiddenFiles: false,
        selectedFiles: new Set(),
        lastSelectedIndex: -1,
        isDragging: false,
        dragOverFolder: null
    });

    // Consolidated context menu state
    const [contextMenuState, setContextMenuState] = useState({
        main: { visible: false, x: 0, y: 0, files: [] },
        emptySpace: { visible: false, x: 0, y: 0 }
    });

    // Consolidated dialog state
    const [dialogState, setDialogState] = useState({
        isOpen: false,
        type: 'alert',
        title: '',
        message: '',
        defaultValue: '',
        onConfirm: () => {},
        onCancel: () => {}
    });

    // Memoized update functions to prevent unnecessary re-renders
    const updateNavigation = useCallback((updates) => {
        setNavigationState(prev => ({ ...prev, ...updates }));
    }, []);

    const updateUI = useCallback((updates) => {
        setUiState(prev => ({ ...prev, ...updates }));
    }, []);

    const updateContextMenu = useCallback((updates) => {
        setContextMenuState(prev => ({ ...prev, ...updates }));
    }, []);

    const updateDialog = useCallback((updates) => {
        setDialogState(prev => ({ ...prev, ...updates }));
    }, []);

    // Optimized clear selection
    const clearSelection = useCallback(() => {
        updateUI({
            selectedFiles: new Set(),
            lastSelectedIndex: -1
        });
    }, [updateUI]);

    // Optimized close context menus
    const closeContextMenus = useCallback(() => {
        setContextMenuState({
            main: { visible: false, x: 0, y: 0, files: [] },
            emptySpace: { visible: false, x: 0, y: 0 }
        });
    }, []);

    return {
        // States
        navigationState,
        uiState,
        contextMenuState,
        dialogState,
        
        // Update functions
        updateNavigation,
        updateUI,
        updateContextMenu,
        updateDialog,
        
        // Helper functions
        clearSelection,
        closeContextMenus
    };
}; 

================================================
File: frontend/src/hooks/useNavigation.js
================================================
import { useState, useCallback, useRef, useEffect } from "preact/hooks";
import { NavigateToPath } from "../../wailsjs/go/backend/App";
import { navCache, prefetcher } from "../services/NavigationService";

export function useNavigation(setError, setNavigationStats) {
    const [currentPath, setCurrentPath] = useState('');
    const [directoryContents, setDirectoryContents] = useState(null);
    const [isActuallyLoading, setIsActuallyLoading] = useState(true);
    const [showLoadingIndicator, setShowLoadingIndicator] = useState(false);
    
    // Performance tracking refs
    const navigationStartTime = useRef(null);
    const loadingTimeout = useRef(null);

    // Smart loading indicator management
    const showSmartLoadingIndicator = useCallback(() => {
        // Clear any existing timeout
        if (loadingTimeout.current) {
            clearTimeout(loadingTimeout.current);
        }
        
        // Only show loading after 150ms delay for perceived speed
        loadingTimeout.current = setTimeout(() => {
            if (isActuallyLoading) {
                setShowLoadingIndicator(true);
            }
        }, 150);
    }, [isActuallyLoading]);

    const hideLoadingIndicator = useCallback(() => {
        if (loadingTimeout.current) {
            clearTimeout(loadingTimeout.current);
            loadingTimeout.current = null;
        }
        setShowLoadingIndicator(false);
    }, []);

    // Prefetch sibling directories for fast navigation
    const prefetchSiblingDirectories = useCallback(async (path) => {
        try {
            const parentPath = path.includes('\\') ? path.split('\\').slice(0, -1).join('\\') : path.split('/').slice(0, -1).join('/');
            if (parentPath && parentPath !== path) {
                const cached = navCache.get(parentPath);
                if (cached) {
                    // Prefetch up to 5 sibling directories
                    const siblings = cached.directories.slice(0, 5).map(dir => dir.path);
                    prefetcher.prefetch(siblings);
                }
            }
        } catch (err) {
            console.log('Prefetch siblings failed:', err);
        }
    }, []);

    // Prefetch common navigation targets
    const prefetchNavigationTargets = useCallback(async (directoryData) => {
        try {
            const prefetchTargets = [];
            
            // Prefetch parent directory
            if (directoryData.parentPath) {
                prefetchTargets.push(directoryData.parentPath);
            }
            
            // Prefetch first few subdirectories (most likely to be accessed)
            const subDirs = directoryData.directories.slice(0, 3).map(dir => dir.path);
            prefetchTargets.push(...subDirs);
            
            prefetcher.prefetch(prefetchTargets);
        } catch (err) {
            console.log('Prefetch targets failed:', err);
        }
    }, []);

    // Ultra-fast navigation with intelligent caching and prefetching
    const navigateToPath = useCallback(async (path, source = 'user') => {
        console.log(`🧭 Navigation request: ${path} (${source})`);
        navigationStartTime.current = Date.now();
        
        try {
            setError('');
            
            // Check frontend cache first - INSTANT response
            const cached = navCache.get(path);
            if (cached) {
                setCurrentPath(cached.currentPath);
                setDirectoryContents(cached);
                hideLoadingIndicator();
                
                // Update stats
                setNavigationStats(prev => ({
                    totalNavigations: prev.totalNavigations + 1,
                    cacheHits: prev.cacheHits + 1,
                    averageTime: (prev.averageTime * prev.totalNavigations + (Date.now() - navigationStartTime.current)) / (prev.totalNavigations + 1)
                }));

                // Prefetch sibling directories and common navigation targets
                if (source === 'user') {
                    prefetchSiblingDirectories(path);
                }
                
                return;
            }

            // Show loading indicator with smart delay
            setIsActuallyLoading(true);
            showSmartLoadingIndicator();
            
            // Backend call with optimized timeout
            const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Navigation timeout')), 5000);
            });
            
            const navigationPromise = NavigateToPath(path);
            const response = await Promise.race([navigationPromise, timeoutPromise]);
            
            if (response && response.success) {
                // Cache the result for future use
                navCache.set(path, response.data);
                
                setCurrentPath(response.data.currentPath);
                setDirectoryContents(response.data);
                
                // Update performance stats
                const navigationTime = Date.now() - navigationStartTime.current;
                setNavigationStats(prev => ({
                    totalNavigations: prev.totalNavigations + 1,
                    cacheHits: prev.cacheHits,
                    averageTime: (prev.averageTime * prev.totalNavigations + navigationTime) / (prev.totalNavigations + 1)
                }));
                
                console.log(`✅ Navigation completed in ${navigationTime}ms: ${response.data.currentPath}`);
                
                // Prefetch likely navigation targets
                if (source === 'user') {
                    prefetchNavigationTargets(response.data);
                }
            } else {
                const errorMsg = response?.message || 'Unknown navigation error';
                setError(errorMsg);
                console.error('❌ Navigation failed:', errorMsg);
            }
        } catch (err) {
            console.error('❌ Navigation error:', err);
            setError('Failed to navigate: ' + err.message);
        } finally {
            setIsActuallyLoading(false);
            hideLoadingIndicator();
        }
    }, [setError, setNavigationStats, showSmartLoadingIndicator, hideLoadingIndicator, prefetchSiblingDirectories, prefetchNavigationTargets]);

    // Optimized navigate up
    const handleNavigateUp = useCallback(async () => {
        if (!currentPath) return;
        
        try {
            // For navigate up, we can often predict the parent path instantly
            const parentPath = currentPath.includes('\\') 
                ? currentPath.split('\\').slice(0, -1).join('\\')
                : currentPath.split('/').slice(0, -1).join('/');
                
            if (parentPath && parentPath !== currentPath) {
                await navigateToPath(parentPath, 'navigate-up');
            }
        } catch (err) {
            console.error('❌ Navigate up error:', err);
            setError('Failed to navigate up: ' + err.message);
        }
    }, [currentPath, navigateToPath, setError]);

    const handleRefresh = useCallback(() => {
        if (currentPath) {
            // Clear cache for current path to force refresh
            navCache.cache.delete(currentPath);
            navigateToPath(currentPath, 'refresh');
        }
    }, [currentPath, navigateToPath]);

    const clearCache = useCallback(() => {
        navCache.clear();
        console.log('🧹 Manual cache clear requested');
    }, []);

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            if (loadingTimeout.current) {
                clearTimeout(loadingTimeout.current);
            }
        };
    }, []);

    return {
        currentPath,
        directoryContents,
        isActuallyLoading,
        showLoadingIndicator,
        navigateToPath,
        handleNavigateUp,
        handleRefresh,
        clearCache
    };
} 

================================================
File: frontend/src/main.jsx
================================================
import {render} from 'preact';
import {App} from './app';
import './style.css';

render(<App/>, document.getElementById('app'));

================================================
File: frontend/src/hooks/usePerformanceMonitoring.js
================================================
import { useState, useEffect } from "preact/hooks";
import { GetCacheStats } from "../../wailsjs/go/backend/App";
import { navCache } from "../services/NavigationService";

export function usePerformanceMonitoring() {
    const [navigationStats, setNavigationStats] = useState({
        totalNavigations: 0,
        cacheHits: 0,
        averageTime: 0
    });

    // Performance monitoring
    useEffect(() => {
        const interval = setInterval(async () => {
            try {
                const [frontendStats, backendStats] = await Promise.all([
                    Promise.resolve(navCache.getStats()),
                    GetCacheStats()
                ]);
                console.log('📊 Performance Stats:', {
                    frontend: frontendStats,
                    backend: backendStats,
                    navigation: navigationStats
                });
            } catch (err) {
                console.log('Stats collection failed:', err);
            }
        }, 30000); // Every 30 seconds

        return () => clearInterval(interval);
    }, [navigationStats]);

    return {
        navigationStats,
        setNavigationStats
    };
} 

================================================
File: frontend/src/hooks/useSelection.js
================================================
import { useState, useCallback } from "preact/hooks";

export const useSelection = () => {
    const [selectedFiles, setSelectedFiles] = useState(new Set());
    const [lastSelectedIndex, setLastSelectedIndex] = useState(-1);

    const handleFileSelect = useCallback((fileIndex, isShiftKey, isCtrlKey) => {
        console.log('📋 File selection:', fileIndex, 'Shift:', isShiftKey, 'Ctrl:', isCtrlKey);
        
        setSelectedFiles(prevSelected => {
            const newSelected = new Set(prevSelected);
            
            if (isShiftKey && lastSelectedIndex !== -1) {
                // Range selection
                const start = Math.min(lastSelectedIndex, fileIndex);
                const end = Math.max(lastSelectedIndex, fileIndex);
                
                for (let i = start; i <= end; i++) {
                    newSelected.add(i);
                }
            } else if (isCtrlKey) {
                // Toggle selection
                if (newSelected.has(fileIndex)) {
                    newSelected.delete(fileIndex);
                } else {
                    newSelected.add(fileIndex);
                }
            } else {
                // Single selection
                newSelected.clear();
                newSelected.add(fileIndex);
            }
            
            return newSelected;
        });
        
        setLastSelectedIndex(fileIndex);
    }, [lastSelectedIndex]);

    const clearSelection = useCallback(() => {
        setSelectedFiles(new Set());
        setLastSelectedIndex(-1);
        console.log('📋 Cleared selection');
    }, []);

    const selectAll = useCallback((totalFiles) => {
        const allIndices = new Set();
        for (let i = 0; i < totalFiles; i++) {
            allIndices.add(i);
        }
        setSelectedFiles(allIndices);
        console.log('📋 Selected all files:', allIndices.size);
    }, []);

    const handleArrowNavigation = useCallback((direction, allFiles) => {
        if (allFiles.length === 0) return;
        
        let targetIndex;
        
        if (selectedFiles.size === 1) {
            // Move from current selection
            const currentIndex = Array.from(selectedFiles)[0];
            
            if (direction === 'up') {
                targetIndex = currentIndex > 0 ? currentIndex - 1 : allFiles.length - 1; // Wrap to bottom
            } else {
                targetIndex = currentIndex < allFiles.length - 1 ? currentIndex + 1 : 0; // Wrap to top
            }
        } else {
            // No selection or multiple selections - select first/last item
            if (direction === 'up') {
                targetIndex = allFiles.length - 1; // Select last item
            } else {
                targetIndex = 0; // Select first item
            }
        }
        
        console.log(`⬆️⬇️ Arrow navigation ${direction}: moving to index ${targetIndex} (${allFiles[targetIndex]?.name})`);
        
        // Select the target file
        setSelectedFiles(new Set([targetIndex]));
        setLastSelectedIndex(targetIndex);
        
        return targetIndex;
    }, [selectedFiles]);

    return {
        selectedFiles,
        lastSelectedIndex,
        handleFileSelect,
        clearSelection,
        selectAll,
        handleArrowNavigation
    };
}; 

================================================
File: frontend/src/ARCHITECTURE.md
================================================
# File Explorer Architecture

This document outlines the modular architecture of the Blueprint File Explorer after refactoring from a monolithic `App.jsx`.

## 📁 Project Structure

```
frontend/src/
├── app.jsx                    # Main App component (simplified)
├── services/
│   └── NavigationService.js   # Navigation cache and prefetching
├── hooks/
│   ├── index.js              # Hooks barrel export
│   ├── useNavigation.js      # Navigation logic and state
│   ├── useDialogs.js         # Dialog state management
│   ├── useContextMenus.js    # Context menu logic
│   ├── usePerformanceMonitoring.js # Performance tracking
│   ├── useKeyboardShortcuts.js     # Keyboard event handling
│   ├── useFileOperations.js  # File operations (existing)
│   ├── useSelection.js       # File selection (existing)
│   └── useClipboard.js       # Clipboard operations (existing)
├── components/               # UI components
└── utils/                   # Utility functions
```

## 🧩 Architecture Components

### Services Layer

#### `NavigationService.js`
- **NavigationCache**: LRU cache with TTL for instant navigation
- **NavigationPrefetcher**: Smart prefetching of likely navigation targets
- Singleton instances exported for global use

### Hooks Layer

#### `useNavigation.js`
**Responsibility**: All navigation-related logic
- Ultra-fast navigation with caching and prefetching
- Loading state management with smart delays
- Parent/child directory navigation
- Cache management and clearing

#### `useDialogs.js`
**Responsibility**: Dialog state and operations
- Dialog state management (open/close/type)
- Confirmation, prompt, and alert dialogs
- Callback handling for user actions

#### `useContextMenus.js`
**Responsibility**: Context menu logic
- File context menu state and positioning
- Empty space context menu state
- Context menu action handlers (copy, cut, rename, delete, hide)
- PowerShell integration

#### `usePerformanceMonitoring.js`
**Responsibility**: Performance tracking and stats
- Navigation performance metrics
- Cache hit rate monitoring
- Frontend/backend stats collection

#### `useKeyboardShortcuts.js`
**Responsibility**: Keyboard event handling
- All keyboard shortcuts (F5, Ctrl+C, arrows, etc.)
- Throttled event handling for performance
- Integration with other hook actions

### Main App Component

The refactored `App.jsx` is now focused on:
- UI rendering and layout
- Hook integration and coordination
- High-level application flow
- Component composition

## 🔄 Data Flow

```mermaid
graph TD
    A[App.jsx] --> B[useNavigation]
    A --> C[useDialogs]
    A --> D[useContextMenus]
    A --> E[usePerformanceMonitoring]
    A --> F[useKeyboardShortcuts]
    
    B --> G[NavigationService]
    G --> H[NavigationCache]
    G --> I[NavigationPrefetcher]
    
    D --> C
    F --> B
    F --> D
    
    J[User Interaction] --> A
    A --> K[UI Components]
```

## 📊 Benefits of Refactoring

### 🎯 Separation of Concerns
- Each hook has a single, well-defined responsibility
- Easier to understand and maintain individual features
- Reduced cognitive load when working on specific functionality

### 🔧 Improved Testability
- Individual hooks can be tested in isolation
- Mock dependencies more easily
- Better unit test coverage

### 🚀 Enhanced Reusability
- Hooks can be reused across different components
- Navigation logic can be used in other parts of the app
- Services can be imported independently

### 📈 Better Performance
- Optimized imports (barrel exports)
- Cleaner dependency tracking
- More efficient re-renders

### 🛠️ Easier Development
- Smaller files are easier to navigate
- Clear boundaries between features
- Simplified debugging and development

## 🔗 Hook Dependencies

```mermaid
graph LR
    A[useNavigation] --> B[NavigationService]
    C[useContextMenus] --> D[useDialogs]
    C --> E[useClipboard]
    F[useKeyboardShortcuts] --> A
    F --> C
    F --> G[useSelection]
    F --> E
```

## 🎨 8-bit Retro Style Guidelines

All components maintain the established 8-bit retro aesthetic:
- Bold, blocky visuals consistent with classic 8-bit design
- Clean and uncluttered layouts
- Zen minimalist approach
- No bright neon "hacker" green (#00ff00)
- Alternative retro color palette

## 🎭 UI State Management

### File Selection and Hover States
**Fixed Issue**: Selection state now properly takes precedence over hover state
- **Problem**: Hover colors were overriding selection colors in both file items and sidebar
- **Solution**: Updated CSS specificity using `:not(.selected)` and `:not(.active)` selectors
- **Result**: Selected file items and active sidebar items maintain their blue selection styling even when hovered
- **Enhancement**: Selected/active hover states provide subtle additional feedback without losing selection visual cues

**CSS Implementation**:
```css
/* Hover only applies to non-selected file items */
.file-item:hover:not(.selected) {
  background: var(--blueprint-surface-hover);
  border-color: var(--blueprint-border);
  transform: translateY(-1px);
}

/* Selected file state always visible */
.file-item.selected {
  background: var(--blueprint-primary);
  color: white;
  border-color: var(--blueprint-primary);
}

/* Enhanced feedback for selected file items on hover */
.file-item.selected:hover {
  background: var(--blueprint-primary);
  color: white;
  box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
  transform: translateY(-2px);
}

/* Hover only applies to non-active sidebar items */
.sidebar-item:hover:not(.active) {
  background: var(--blueprint-surface-hover);
  color: var(--blueprint-text);
  transform: translateX(2px);
}

/* Active sidebar state always visible */
.sidebar-item.active {
  background: var(--blueprint-primary);
  color: white;
}

/* Enhanced feedback for active sidebar items on hover */
.sidebar-item.active:hover {
  background: var(--blueprint-primary);
  color: white;
  box-shadow: 0 2px 6px rgba(59, 130, 246, 0.3);
  transform: translateX(1px);
}
```

## 🚦 Usage Examples

### Navigation
```javascript
const { navigateToPath, currentPath, directoryContents } = useNavigation(setError, setStats);
await navigateToPath('/some/path', 'user');
```

### Dialogs
```javascript
const { showDialog } = useDialogs();
showDialog('confirm', 'Delete File', 'Are you sure?', '', onConfirm);
```

### Context Menus
```javascript
const { handleContextMenu, contextMenu } = useContextMenus(/* deps */);
// handleContextMenu will be called from file items
```

This architecture promotes maintainability, testability, and future extensibility while preserving all the performance optimizations and features of the original implementation. 

================================================
File: go.mod
================================================
module testui

go 1.23

require github.com/wailsapp/wails/v2 v2.10.1

require (
	github.com/bep/debounce v1.2.1 // indirect
	github.com/go-ole/go-ole v1.3.0 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e // indirect
	github.com/labstack/echo/v4 v4.13.3 // indirect
	github.com/labstack/gommon v0.4.2 // indirect
	github.com/leaanthony/go-ansi-parser v1.6.1 // indirect
	github.com/leaanthony/gosod v1.0.4 // indirect
	github.com/leaanthony/slicer v1.6.0 // indirect
	github.com/leaanthony/u v1.1.1 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/samber/lo v1.49.1 // indirect
	github.com/tkrajina/go-reflector v0.5.8 // indirect
	github.com/valyala/bytebufferpool v1.0.0 // indirect
	github.com/valyala/fasttemplate v1.2.2 // indirect
	github.com/wailsapp/go-webview2 v1.0.19 // indirect
	github.com/wailsapp/mimetype v1.4.1 // indirect
	golang.org/x/crypto v0.33.0 // indirect
	golang.org/x/net v0.35.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.22.0 // indirect
)

// replace github.com/wailsapp/wails/v2 v2.10.1 => C:\Users\andrewzhuang\go\pkg\mod


================================================
File: frontend/src/utils/fileUtils.js
================================================
// Enhanced file type detection and icon mapping utilities with extensive emoji support

export const getFileType = (fileName, isDir) => {
    if (isDir) return 'folder';
    
    const ext = fileName.split('.').pop()?.toLowerCase();
    const baseName = fileName.toLowerCase();
    
    // Specific file mappings first (highest priority)
    const specificFiles = {
        'readme': 'readme',
        'readme.md': 'readme',
        'readme.txt': 'readme',
        'license': 'license',
        'license.md': 'license',
        'license.txt': 'license',
        'dockerfile': 'docker',
        'docker-compose.yml': 'docker',
        'docker-compose.yaml': 'docker',
        'makefile': 'build',
        'cmake.txt': 'build',
        'package.json': 'nodejs',
        'package-lock.json': 'nodejs',
        'yarn.lock': 'nodejs',
        'pom.xml': 'java',
        'build.gradle': 'java',
        'cargo.toml': 'rust',
        'go.mod': 'go',
        'requirements.txt': 'python',
        'pipfile': 'python',
        '.gitignore': 'git',
        '.gitmodules': 'git',
        '.env': 'config',
        '.env.local': 'config',
        '.env.example': 'config'
    };
    
    if (specificFiles[baseName]) return specificFiles[baseName];
    
    // Programming languages and scripts
    const codeTypes = {
        // Web technologies
        'js': 'javascript', 'mjs': 'javascript', 'cjs': 'javascript',
        'jsx': 'react', 'tsx': 'react',
        'ts': 'typescript',
        'html': 'html', 'htm': 'html',
        'css': 'css', 'scss': 'sass', 'sass': 'sass', 'less': 'css',
        'vue': 'vue', 'svelte': 'svelte',
        'php': 'php', 'phtml': 'php',
        
        // System languages
        'c': 'c', 'h': 'c',
        'cpp': 'cpp', 'cxx': 'cpp', 'cc': 'cpp', 'hpp': 'cpp',
        'cs': 'csharp', 'csx': 'csharp',
        'java': 'java', 'class': 'java', 'jar': 'java',
        'go': 'go',
        'rs': 'rust', 'rlib': 'rust',
        'swift': 'swift',
        'kt': 'kotlin', 'kts': 'kotlin',
        'dart': 'dart',
        
        // Scripting languages
        'py': 'python', 'pyw': 'python', 'pyc': 'python',
        'rb': 'ruby', 'rbw': 'ruby',
        'pl': 'perl', 'pm': 'perl',
        'lua': 'lua',
        'r': 'r', 'rdata': 'r',
        'jl': 'julia',
        
        // Shell scripts
        'sh': 'shell', 'bash': 'shell', 'zsh': 'shell', 'fish': 'shell',
        'ps1': 'powershell', 'psm1': 'powershell',
        'bat': 'batch', 'cmd': 'batch',
        
        // Assembly and low-level
        'asm': 'assembly', 's': 'assembly',
        
        // Database
        'sql': 'database', 'mysql': 'database', 'pgsql': 'database',
        'db': 'database', 'sqlite': 'database', 'sqlite3': 'database',
        
        // Configuration and data
        'json': 'json', 'jsonc': 'json',
        'xml': 'xml', 'xsd': 'xml', 'xsl': 'xml',
        'yaml': 'yaml', 'yml': 'yaml',
        'toml': 'config', 'ini': 'config', 'cfg': 'config', 'conf': 'config',
        'properties': 'config', 'env': 'config'
    };
    
    if (codeTypes[ext]) return codeTypes[ext];
    
    // Images
    const imageTypes = {
        'jpg': 'image', 'jpeg': 'image',
        'png': 'image',
        'gif': 'gif',
        'svg': 'vector',
        'bmp': 'image',
        'webp': 'image',
        'ico': 'icon',
        'tiff': 'image', 'tif': 'image',
        'raw': 'camera', 'cr2': 'camera', 'nef': 'camera', 'arw': 'camera',
        'psd': 'photoshop', 'psb': 'photoshop',
        'ai': 'illustrator',
        'sketch': 'design',
        'fig': 'figma',
        'xd': 'xd'
    };
    
    if (imageTypes[ext]) return imageTypes[ext];
    
    // Audio files
    const audioTypes = {
        'mp3': 'audio', 'm4a': 'audio', 'aac': 'audio',
        'wav': 'audio', 'flac': 'audio', 'ogg': 'audio',
        'wma': 'audio', 'aiff': 'audio',
        'midi': 'music', 'mid': 'music'
    };
    
    if (audioTypes[ext]) return audioTypes[ext];
    
    // Video files
    const videoTypes = {
        'mp4': 'video', 'm4v': 'video',
        'avi': 'video', 'mkv': 'video', 'mov': 'video',
        'wmv': 'video', 'flv': 'video', 'webm': 'video',
        '3gp': 'video', 'mpg': 'video', 'mpeg': 'video'
    };
    
    if (videoTypes[ext]) return videoTypes[ext];
    
    // Documents
    const documentTypes = {
        'pdf': 'pdf',
        'doc': 'word', 'docx': 'word',
        'xls': 'excel', 'xlsx': 'excel', 'csv': 'csv',
        'ppt': 'powerpoint', 'pptx': 'powerpoint',
        'odt': 'document', 'ods': 'document', 'odp': 'document',
        'rtf': 'document',
        'txt': 'text',
        'md': 'markdown', 'markdown': 'markdown',
        'tex': 'latex', 'bib': 'latex',
        'epub': 'ebook', 'mobi': 'ebook', 'azw': 'ebook'
    };
    
    if (documentTypes[ext]) return documentTypes[ext];
    
    // Archives
    const archiveTypes = {
        'zip': 'archive', 'rar': 'archive', '7z': 'archive',
        'tar': 'archive', 'gz': 'archive', 'bz2': 'archive',
        'xz': 'archive', 'lz': 'archive', 'lzma': 'archive',
        'cab': 'archive', 'iso': 'disc', 'dmg': 'disc',
        'pkg': 'package', 'deb': 'package', 'rpm': 'package'
    };
    
    if (archiveTypes[ext]) return archiveTypes[ext];
    
    // Executables
    const executableTypes = {
        'exe': 'executable', 'msi': 'installer', 'app': 'macos',
        'run': 'executable', 'bin': 'executable',
        'appimage': 'executable', 'snap': 'executable'
    };
    
    if (executableTypes[ext]) return executableTypes[ext];
    
    // Fonts
    const fontTypes = {
        'ttf': 'font', 'otf': 'font', 'woff': 'font', 'woff2': 'font',
        'eot': 'font', 'fon': 'font'
    };
    
    if (fontTypes[ext]) return fontTypes[ext];
    
    // 3D and CAD
    const threeDTypes = {
        'obj': '3d', 'fbx': '3d', 'dae': '3d', 'blend': 'blender',
        'max': '3d', '3ds': '3d', 'stl': '3d', 'ply': '3d',
        'dwg': 'cad', 'dxf': 'cad', 'step': 'cad', 'iges': 'cad'
    };
    
    if (threeDTypes[ext]) return threeDTypes[ext];
    
    // Default fallback
    return 'file';
};

export const getFileIcon = (fileName, isDir) => {
    if (isDir) {
        // Special folder icons
        const folderName = fileName.toLowerCase();
        const specialFolders = {
            'node_modules': '📦',
            '.git': '🔀',
            '.vscode': '🔵',
            '.idea': '💡',
            'dist': '📦',
            'build': '🔨',
            'src': '📂',
            'assets': '🎨',
            'images': '🖼️',
            'img': '🖼️',
            'css': '🎨',
            'js': '📜',
            'components': '🧩',
            'utils': '🔧',
            'config': '⚙️',
            'docs': '📚',
            'documentation': '📚',
            'test': '🧪',
            'tests': '🧪',
            '__pycache__': '🐍',
            'venv': '🐍',
            'env': '🌍',
            'bin': '⚙️',
            'lib': '📚',
            'include': '📂',
            'public': '🌐',
            'private': '🔒',
            'temp': '🗂️',
            'tmp': '🗂️',
            'cache': '💾',
            'log': '📝',
            'logs': '📝'
        };
        
        return specialFolders[folderName] || '📁';
    }
    
    const type = getFileType(fileName, false);
    
    const icons = {
        // Programming languages
        'javascript': '🟨',
        'typescript': '🔷',
        'react': '⚛️',
        'vue': '💚',
        'svelte': '🧡',
        'html': '🌐',
        'css': '🎨',
        'sass': '💅',
        'php': '🐘',
        'python': '🐍',
        'java': '☕',
        'csharp': '🔷',
        'cpp': '⚙️',
        'c': '🔧',
        'go': '🐹',
        'rust': '🦀',
        'swift': '🐦',
        'kotlin': '🟣',
        'dart': '🎯',
        'ruby': '💎',
        'perl': '🐪',
        'lua': '🌙',
        'r': '📊',
        'julia': '🔴',
        'shell': '🐚',
        'powershell': '💙',
        'batch': '⚫',
        'assembly': '🔩',
        
        // Data and config
        'json': '📋',
        'xml': '📄',
        'yaml': '📝',
        'database': '🗄️',
        'config': '⚙️',
        
        // Special files
        'readme': '📖',
        'license': '📜',
        'docker': '🐳',
        'build': '🔨',
        'nodejs': '💚',
        'git': '🔀',
        
        // Images
        'image': '🖼️',
        'gif': '🎞️',
        'vector': '🎨',
        'icon': '🔳',
        'camera': '📷',
        'photoshop': '🎨',
        'illustrator': '🎨',
        'design': '🎨',
        'figma': '🎨',
        'xd': '🎨',
        
        // Media
        'audio': '🎵',
        'music': '🎼',
        'video': '🎬',
        
        // Documents
        'pdf': '📕',
        'word': '📘',
        'excel': '📗',
        'csv': '📊',
        'powerpoint': '📙',
        'document': '📄',
        'text': '📝',
        'markdown': '📝',
        'latex': '📖',
        'ebook': '📚',
        
        // Archives and packages
        'archive': '📦',
        'package': '📦',
        'disc': '💿',
        
        // Executables
        'executable': '⚡',
        'installer': '📦',
        'macos': '🍎',
        
        // Fonts
        'font': '🔤',
        
        // 3D and design
        '3d': '🎲',
        'blender': '🎲',
        'cad': '📐',
        
        // Default
        'file': '📄',
        'folder': '📁'
    };
    
    return icons[type] || '📄';
};

// Filter function for hidden and system files
export const filterFiles = (files, showHiddenFiles) => {
    if (!files) return [];
    if (showHiddenFiles) return files;
    
    return files.filter(file => {
        // Most important: Check the isHidden property from the backend
        if (file.isHidden) return false;
        
        // Hide files that start with . (hidden files) - redundant but kept for safety
        if (file.name.startsWith('.')) return false;
        
        // Hide common Windows system files
        const systemFiles = [
            'NTUSER.DAT', 'ntuser.dat.LOG1', 'ntuser.dat.LOG2', 'ntuser.ini',
            'Application Data', 'Cookies', 'Local Settings', 'My Documents',
            'NetHood', 'PrintHood', 'Recent', 'SendTo', 'Start Menu', 'Templates'
        ];
        
        if (systemFiles.includes(file.name)) return false;
        
        // Hide files with system file extensions and patterns
        const hiddenPatterns = [
            /^NTUSER\.DAT/i,
            /\.TM\.blf$/i,
            /\.TMContainer.*\.regtrans-ms$/i,
            /^thumbs\.db$/i,
            /^desktop\.ini$/i
        ];
        
        return !hiddenPatterns.some(pattern => pattern.test(file.name));
    });
}; 

================================================
File: frontend/wailsjs/go/backend/App.d.ts
================================================
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Â MODIWL
// This file is automatically generated. DO NOT EDIT
import {backend} from '../models';

export function ClearCache():Promise<void>;

export function CopyFiles(arg1:Array<string>,arg2:string):Promise<boolean>;

export function CreateDirectory(arg1:string,arg2:string):Promise<backend.NavigationResponse>;

export function DeleteFiles(arg1:Array<string>):Promise<boolean>;

export function DeletePath(arg1:string):Promise<backend.NavigationResponse>;

export function ExecuteCommand(arg1:string,arg2:string):Promise<boolean>;

export function FileExists(arg1:string):Promise<boolean>;

export function FormatFileSize(arg1:number):Promise<string>;

export function GetAvailableTerminals():Promise<Array<string>>;

export function GetCacheStats():Promise<Record<string, any>>;

export function GetCurrentWorkingDirectory():Promise<string>;

export function GetDriveInfo():Promise<Array<Record<string, any>>>;

export function GetFileDetails(arg1:string):Promise<backend.FileInfo>;

export function GetHomeDirectory():Promise<string>;

export function GetQuickAccessPaths():Promise<Array<Record<string, any>>>;

export function GetSystemRoots():Promise<Array<string>>;

export function HealthCheck():Promise<Record<string, any>>;

export function HideFiles(arg1:Array<string>):Promise<boolean>;

export function IsHidden(arg1:string):Promise<boolean>;

export function ListDirectory(arg1:string):Promise<backend.NavigationResponse>;

export function MoveFiles(arg1:Array<string>,arg2:string):Promise<boolean>;

export function MoveFilesToRecycleBin(arg1:Array<string>):Promise<boolean>;

export function NavigateToPath(arg1:string):Promise<backend.NavigationResponse>;

export function NavigateUp(arg1:string):Promise<backend.NavigationResponse>;

export function OpenFile(arg1:string):Promise<boolean>;

export function OpenInSystemExplorer(arg1:string):Promise<boolean>;

export function OpenPowerShellHere(arg1:string):Promise<boolean>;

export function OpenTerminalHere(arg1:string):Promise<boolean>;

export function RenameFile(arg1:string,arg2:string):Promise<boolean>;

export function ValidatePath(arg1:string):Promise<boolean>;


================================================
File: frontend/src/utils/debounce.js
================================================
// Debounce utility to prevent excessive function calls
export function debounce(func, wait, immediate = false) {
    let timeout;
    
    return function executedFunction(...args) {
        const later = () => {
            timeout = null;
            if (!immediate) func.apply(this, args);
        };
        
        const callNow = immediate && !timeout;
        
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        
        if (callNow) func.apply(this, args);
    };
}

// Throttle utility for high-frequency events like scrolling
export function throttle(func, limit) {
    let inThrottle;
    
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

// Specialized debounce for navigation operations (super fast)
export const debouncedNavigate = debounce((navigateFunc, path) => {
    navigateFunc(path);
}, 50); // Much faster for responsive navigation

// Specialized throttle for scroll events  
export const throttledScroll = throttle((scrollFunc, event) => {
    scrollFunc(event);
}, 16); // ~60fps

// Specialized debounce for file operations
export const debouncedFileOperation = debounce((operationFunc, ...args) => {
    operationFunc(...args);
}, 75); // Slightly faster for better responsiveness 

================================================
File: go.sum
================================================
github.com/bep/debounce v1.2.1 h1:v67fRdBA9UQu2NhLFXrSg0Brw7CexQekrBwDMM8bzeY=
github.com/bep/debounce v1.2.1/go.mod h1:H8yggRPQKLUhUoqrJC1bO2xNya7vanpDl7xR3ISbCJ0=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/go-ole/go-ole v1.3.0 h1:Dt6ye7+vXGIKZ7Xtk4s6/xVdGDQynvom7xCFEdWr6uE=
github.com/go-ole/go-ole v1.3.0/go.mod h1:5LS6F96DhAwUc7C+1HLexzMXY1xGRSryjyPPKW6zv78=
github.com/godbus/dbus/v5 v5.1.0 h1:4KLkAxT3aOY8Li4FRJe/KvhoNFFxo0m6fNuFUO8QJUk=
github.com/godbus/dbus/v5 v5.1.0/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e h1:Q3+PugElBCf4PFpxhErSzU3/PY5sFL5Z6rfv4AbGAck=
github.com/jchv/go-winloader v0.0.0-20210711035445-715c2860da7e/go.mod h1:alcuEEnZsY1WQsagKhZDsoPCRoOijYqhZvPwLG0kzVs=
github.com/labstack/echo/v4 v4.13.3 h1:pwhpCPrTl5qry5HRdM5FwdXnhXSLSY+WE+YQSeCaafY=
github.com/labstack/echo/v4 v4.13.3/go.mod h1:o90YNEeQWjDozo584l7AwhJMHN0bOC4tAfg+Xox9q5g=
github.com/labstack/gommon v0.4.2 h1:F8qTUNXgG1+6WQmqoUWnz8WiEU60mXVVw0P4ht1WRA0=
github.com/labstack/gommon v0.4.2/go.mod h1:QlUFxVM+SNXhDL/Z7YhocGIBYOiwB0mXm1+1bAPHPyU=
github.com/leaanthony/debme v1.2.1 h1:9Tgwf+kjcrbMQ4WnPcEIUcQuIZYqdWftzZkBr+i/oOc=
github.com/leaanthony/debme v1.2.1/go.mod h1:3V+sCm5tYAgQymvSOfYQ5Xx2JCr+OXiD9Jkw3otUjiA=
github.com/leaanthony/go-ansi-parser v1.6.1 h1:xd8bzARK3dErqkPFtoF9F3/HgN8UQk0ed1YDKpEz01A=
github.com/leaanthony/go-ansi-parser v1.6.1/go.mod h1:+vva/2y4alzVmmIEpk9QDhA7vLC5zKDTRwfZGOp3IWU=
github.com/leaanthony/gosod v1.0.4 h1:YLAbVyd591MRffDgxUOU1NwLhT9T1/YiwjKZpkNFeaI=
github.com/leaanthony/gosod v1.0.4/go.mod h1:GKuIL0zzPj3O1SdWQOdgURSuhkF+Urizzxh26t9f1cw=
github.com/leaanthony/slicer v1.6.0 h1:1RFP5uiPJvT93TAHi+ipd3NACobkW53yUiBqZheE/Js=
github.com/leaanthony/slicer v1.6.0/go.mod h1:o/Iz29g7LN0GqH3aMjWAe90381nyZlDNquK+mtH2Fj8=
github.com/leaanthony/u v1.1.1 h1:TUFjwDGlNX+WuwVEzDqQwC2lOv0P4uhTQw7CMFdiK7M=
github.com/leaanthony/u v1.1.1/go.mod h1:9+o6hejoRljvZ3BzdYlVL0JYCwtnAsVuN9pVTQcaRfI=
github.com/matryer/is v1.4.0/go.mod h1:8I/i5uYgLzgsgEloJE1U6xx5HkBQpAZvepWuujKwMRU=
github.com/matryer/is v1.4.1 h1:55ehd8zaGABKLXQUe2awZ99BD/PTc2ls+KV/dXphgEQ=
github.com/matryer/is v1.4.1/go.mod h1:8I/i5uYgLzgsgEloJE1U6xx5HkBQpAZvepWuujKwMRU=
github.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=
github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c h1:+mdjkGKdHQG3305AYmdv1U2eRNDiU2ErMBj1gwrq8eQ=
github.com/pkg/browser v0.0.0-20240102092130-5ac0b6a4141c/go.mod h1:7rwL4CYBLnjLxUqIJNnCWiEdr3bn6IUYi15bNlnbCCU=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=
github.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=
github.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=
github.com/samber/lo v1.49.1 h1:4BIFyVfuQSEpluc7Fua+j1NolZHiEHEpaSEKdsH0tew=
github.com/samber/lo v1.49.1/go.mod h1:dO6KHFzUKXgP8LDhU0oI8d2hekjXnGOu0DB8Jecxd6o=
github.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=
github.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/tkrajina/go-reflector v0.5.8 h1:yPADHrwmUbMq4RGEyaOUpz2H90sRsETNVpjzo3DLVQQ=
github.com/tkrajina/go-reflector v0.5.8/go.mod h1:ECbqLgccecY5kPmPmXg1MrHW585yMcDkVl6IvJe64T4=
github.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=
github.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=
github.com/valyala/fasttemplate v1.2.2 h1:lxLXG0uE3Qnshl9QyaK6XJxMXlQZELvChBOCmQD0Loo=
github.com/valyala/fasttemplate v1.2.2/go.mod h1:KHLXt3tVN2HBp8eijSv/kGJopbvo7S+qRAEEKiv+SiQ=
github.com/wailsapp/go-webview2 v1.0.19 h1:7U3QcDj1PrBPaxJNCui2k1SkWml+Q5kvFUFyTImA6NU=
github.com/wailsapp/go-webview2 v1.0.19/go.mod h1:qJmWAmAmaniuKGZPWwne+uor3AHMB5PFhqiK0Bbj8kc=
github.com/wailsapp/mimetype v1.4.1 h1:pQN9ycO7uo4vsUUuPeHEYoUkLVkaRntMnHJxVwYhwHs=
github.com/wailsapp/mimetype v1.4.1/go.mod h1:9aV5k31bBOv5z6u+QP8TltzvNGJPmNJD4XlAL3U+j3o=
github.com/wailsapp/wails/v2 v2.10.1 h1:QWHvWMXII2nI/nXz77gpPG8P3ehl6zKe+u4su5BWIns=
github.com/wailsapp/wails/v2 v2.10.1/go.mod h1:zrebnFV6MQf9kx8HI4iAv63vsR5v67oS7GTEZ7Pz1TY=
golang.org/x/crypto v0.33.0 h1:IOBPskki6Lysi0lo9qQvbxiQ+FvsCC/YWOecCHAixus=
golang.org/x/crypto v0.33.0/go.mod h1:bVdXmD7IV/4GdElGPozy6U7lWdRXA4qyRVGJV57uQ5M=
golang.org/x/net v0.0.0-20210505024714-0287a6fb4125/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=
golang.org/x/net v0.35.0 h1:T5GQRQb2y08kTAByq9L4/bz8cipCdA8FbRTXewonqY8=
golang.org/x/net v0.35.0/go.mod h1:EglIi67kWsHKlRzzVMUD93VMSWGFOMSZgxFjparz1Qk=
golang.org/x/sys v0.0.0-20200810151505-1b9f1253b3ed/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.1.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=
golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.22.0 h1:bofq7m3/HAFvbF51jz3Q9wLg3jkvSPuiZu/pD1XwgtM=
golang.org/x/text v0.22.0/go.mod h1:YRoo4H8PVmsu+E3Ou7cqLVH8oXWIHVoX0jqUWALQhfY=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=


================================================
File: frontend/wailsjs/runtime/package.json
================================================
{
  "name": "@wailsapp/runtime",
  "version": "2.0.0",
  "description": "Wails Javascript runtime library",
  "main": "runtime.js",
  "types": "runtime.d.ts",
  "scripts": {
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/wailsapp/wails.git"
  },
  "keywords": [
    "Wails",
    "Javascript",
    "Go"
  ],
  "author": "Lea Anthony <lea.anthony@gmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/wailsapp/wails/issues"
  },
  "homepage": "https://github.com/wailsapp/wails#readme"
}


================================================
File: frontend/wailsjs/go/models.ts
================================================
export namespace backend {
	
	export class FileInfo {
	    name: string;
	    path: string;
	    isDir: boolean;
	    size: number;
	    // Go type: time
	    modTime: any;
	    permissions: string;
	    extension: string;
	    isHidden: boolean;
	
	    static createFrom(source: any = {}) {
	        return new FileInfo(source);
	    }
	
	    constructor(source: any = {}) {
	        if ('string' === typeof source) source = JSON.parse(source);
	        this.name = source["name"];
	        this.path = source["path"];
	        this.isDir = source["isDir"];
	        this.size = source["size"];
	        this.modTime = this.convertValues(source["modTime"], null);
	        this.permissions = source["permissions"];
	        this.extension = source["extension"];
	        this.isHidden = source["isHidden"];
	    }
	
		convertValues(a: any, classs: any, asMap: boolean = false): any {
		    if (!a) {
		        return a;
		    }
		    if (a.slice && a.map) {
		        return (a as any[]).map(elem => this.convertValues(elem, classs));
		    } else if ("object" === typeof a) {
		        if (asMap) {
		            for (const key of Object.keys(a)) {
		                a[key] = new classs(a[key]);
		            }
		            return a;
		        }
		        return new classs(a);
		    }
		    return a;
		}
	}
	export class DirectoryContents {
	    currentPath: string;
	    parentPath: string;
	    files: FileInfo[];
	    directories: FileInfo[];
	    totalFiles: number;
	    totalDirs: number;
	
	    static createFrom(source: any = {}) {
	        return new DirectoryContents(source);
	    }
	
	    constructor(source: any = {}) {
	        if ('string' === typeof source) source = JSON.parse(source);
	        this.currentPath = source["currentPath"];
	        this.parentPath = source["parentPath"];
	        this.files = this.convertValues(source["files"], FileInfo);
	        this.directories = this.convertValues(source["directories"], FileInfo);
	        this.totalFiles = source["totalFiles"];
	        this.totalDirs = source["totalDirs"];
	    }
	
		convertValues(a: any, classs: any, asMap: boolean = false): any {
		    if (!a) {
		        return a;
		    }
		    if (a.slice && a.map) {
		        return (a as any[]).map(elem => this.convertValues(elem, classs));
		    } else if ("object" === typeof a) {
		        if (asMap) {
		            for (const key of Object.keys(a)) {
		                a[key] = new classs(a[key]);
		            }
		            return a;
		        }
		        return new classs(a);
		    }
		    return a;
		}
	}
	
	export class NavigationResponse {
	    success: boolean;
	    message: string;
	    data: DirectoryContents;
	
	    static createFrom(source: any = {}) {
	        return new NavigationResponse(source);
	    }
	
	    constructor(source: any = {}) {
	        if ('string' === typeof source) source = JSON.parse(source);
	        this.success = source["success"];
	        this.message = source["message"];
	        this.data = this.convertValues(source["data"], DirectoryContents);
	    }
	
		convertValues(a: any, classs: any, asMap: boolean = false): any {
		    if (!a) {
		        return a;
		    }
		    if (a.slice && a.map) {
		        return (a as any[]).map(elem => this.convertValues(elem, classs));
		    } else if ("object" === typeof a) {
		        if (asMap) {
		            for (const key of Object.keys(a)) {
		                a[key] = new classs(a[key]);
		            }
		            return a;
		        }
		        return new classs(a);
		    }
		    return a;
		}
	}

}



================================================
File: frontend/src/services/NavigationService.js
================================================
// Frontend cache for ultra-fast navigation
export class NavigationCache {
    constructor(maxSize = 100, ttl = 10000) { // 10 second TTL, 100 entries max
        this.cache = new Map();
        this.accessOrder = new Map();
        this.maxSize = maxSize;
        this.ttl = ttl;
        this.hitCount = 0;
        this.missCount = 0;
    }

    get(path) {
        const entry = this.cache.get(path);
        if (!entry) {
            this.missCount++;
            return null;
        }

        // Check TTL
        if (Date.now() - entry.timestamp > this.ttl) {
            this.cache.delete(path);
            this.accessOrder.delete(path);
            this.missCount++;
            return null;
        }

        // Update access order for LRU
        this.accessOrder.set(path, Date.now());
        this.hitCount++;
        console.log(`⚡ Frontend cache HIT for: ${path} (${this.hitCount}/${this.hitCount + this.missCount} hit rate: ${(this.hitCount / (this.hitCount + this.missCount) * 100).toFixed(1)}%)`);
        return entry.data;
    }

    set(path, data) {
        // Remove oldest entries if cache is full
        if (this.cache.size >= this.maxSize) {
            const oldestPath = [...this.accessOrder.entries()]
                .sort(([,a], [,b]) => a - b)[0][0];
            this.cache.delete(oldestPath);
            this.accessOrder.delete(oldestPath);
        }

        this.cache.set(path, {
            data,
            timestamp: Date.now()
        });
        this.accessOrder.set(path, Date.now());
        console.log(`💾 Frontend cached: ${path} (${this.cache.size}/${this.maxSize} entries)`);
    }

    clear() {
        this.cache.clear();
        this.accessOrder.clear();
        console.log('🧹 Frontend cache cleared');
    }

    getStats() {
        return {
            entries: this.cache.size,
            hitRate: this.hitCount / (this.hitCount + this.missCount) * 100,
            hits: this.hitCount,
            misses: this.missCount
        };
    }
}

// Smart prefetching for likely navigation targets
export class NavigationPrefetcher {
    constructor() {
        this.prefetchQueue = new Set();
        this.isRunning = false;
    }

    async prefetch(paths) {
        if (this.isRunning) return;
        
        for (const path of paths) {
            if (this.cache && this.cache.get(path)) continue; // Already cached
            
            this.prefetchQueue.add(path);
        }

        if (this.prefetchQueue.size > 0) {
            this.processPrefetchQueue();
        }
    }

    async processPrefetchQueue() {
        if (this.isRunning || this.prefetchQueue.size === 0) return;
        
        this.isRunning = true;
        const path = [...this.prefetchQueue][0];
        this.prefetchQueue.delete(path);

        try {
            console.log(`🔮 Prefetching: ${path}`);
            const { NavigateToPath } = await import("../../wailsjs/go/backend/App");
            const response = await NavigateToPath(path);
            if (response && response.success && this.cache) {
                this.cache.set(path, response.data);
            }
        } catch (err) {
            console.log(`❌ Prefetch failed for ${path}:`, err);
        }

        this.isRunning = false;
        
        // Process next item with a small delay
        if (this.prefetchQueue.size > 0) {
            setTimeout(() => this.processPrefetchQueue(), 100);
        }
    }

    setCache(cache) {
        this.cache = cache;
    }
}

// Create singleton instances
export const navCache = new NavigationCache();
export const prefetcher = new NavigationPrefetcher();
prefetcher.setCache(navCache); 

================================================
File: frontend/src/components/Breadcrumb.jsx
================================================
import { memo, useMemo, useCallback } from "preact/compat";

// Memoized Breadcrumb component
const Breadcrumb = memo(({ currentPath, onNavigate }) => {
    const segments = useMemo(() => 
        currentPath.split(/[\/\\]/).filter(Boolean), 
        [currentPath]
    );
    
    const handleSegmentClick = useCallback((index) => {
        if (index === -1) {
            // Root click - navigate to first drive on Windows or root on Unix
            if (segments.length > 0 && segments[0].includes(':')) {
                // Windows - navigate to drive root
                onNavigate(segments[0] + '\\');
            } else {
                // Unix - navigate to root
                onNavigate('/');
            }
        } else {
            // Build path from segments
            const pathSegments = segments.slice(0, index + 1);
            let newPath;
            
            if (pathSegments[0].includes(':')) {
                // Windows path
                newPath = pathSegments.join('\\');
                if (!newPath.endsWith('\\') && index === 0) {
                    newPath += '\\';
                }
            } else {
                // Unix path
                newPath = '/' + pathSegments.join('/');
            }
            
            onNavigate(newPath);
        }
    }, [segments, onNavigate]);
    
    return (
        <div className="nav-breadcrumb custom-scrollbar">
            <span 
                className="nav-segment" 
                onClick={() => handleSegmentClick(-1)}
            >
                ROOT
            </span>
            {segments.map((segment, index) => (
                <span key={index}>
                    <span className="separator">/</span>
                    <span 
                        className={`nav-segment ${index === segments.length - 1 ? 'current' : ''}`}
                        onClick={() => handleSegmentClick(index)}
                    >
                        {segment}
                    </span>
                </span>
            ))}
        </div>
    );
});

export { Breadcrumb };
export default Breadcrumb; 

================================================
File: frontend/src/components/FastNavigation.css
================================================
/* Fast Navigation CSS Optimizations */

.file-list-container {
    position: relative;
    flex: 1;
    overflow: hidden;
    contain: layout style paint;
    /* Fix height calculation issues */
    min-height: 0;
}

.file-list {
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
    
    /* Optimize scrolling performance */
    scroll-behavior: smooth;
    overscroll-behavior: contain;
    
    /* GPU acceleration */
    transform: translateZ(0);
    will-change: scroll-position;
    
    /* Prevent horizontal scrollbar issues */
    max-width: 100%;
}

/* Instant loading feedback */
.loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(20, 30, 50, 0.8);
    backdrop-filter: blur(2px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    
    /* Instant appearance */
    animation: fadeInFast 0.1s ease-out;
}

@keyframes fadeInFast {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Responsive header elements */
.app-header {
    transition: background-color 0.1s ease;
}

.app-header.loading {
    background-color: rgba(30, 40, 60, 0.9);
}

/* Fast loading spinner */
.loading-spinner {
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-top: 2px solid var(--blueprint-accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    
    /* Smooth animation */
    transform-origin: center;
    will-change: transform;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Instant visual feedback for navigation */
.nav-segment, .sidebar-item {
    transition: all 0.1s ease;
    cursor: pointer;
}

.nav-segment:hover, .sidebar-item:hover:not(.active) {
    background-color: rgba(100, 150, 200, 0.1);
    transform: translateY(-1px);
}

.nav-segment:active, .sidebar-item:active:not(.active) {
    transform: translateY(0);
    background-color: rgba(100, 150, 200, 0.2);
}

/* Enhanced active sidebar item hover feedback */
.sidebar-item.active:hover {
    background-color: rgba(59, 130, 246, 1);
    transform: translateY(-1px);
}

.sidebar-item.active:active {
    background-color: rgba(59, 130, 246, 0.9);
    transform: translateY(0);
}

/* File item hover effects for instant feedback */
.file-item {
    transition: all 0.1s ease-out;
    cursor: pointer;
}

.file-item:hover:not(.selected) {
    background-color: rgba(100, 150, 200, 0.05);
    transform: translateX(2px);
}

.file-item:active:not(.selected) {
    background-color: rgba(100, 150, 200, 0.1);
    transform: translateX(0);
}

/* Selected state with instant feedback */
.file-item.selected {
    background-color: rgba(100, 150, 200, 0.2);
    border-left: 3px solid var(--blueprint-accent);
}

/* Enhanced selected state hover feedback */
.file-item.selected:hover {
    /* Maintain selection styling but add subtle enhancement */
    background-color: rgba(100, 150, 200, 0.3);
    border-left: 3px solid var(--blueprint-accent);
    transform: translateX(1px);
}

.file-item.selected:active {
    background-color: rgba(100, 150, 200, 0.2);
    border-left: 3px solid var(--blueprint-accent);
    transform: translateX(0);
}

/* Optimized breadcrumb transitions */
.nav-breadcrumb {
    /* Smooth scrolling for long paths */
    scroll-behavior: smooth;
    overflow-x: auto;
    overflow-y: hidden;
    white-space: nowrap;
}

/* Toolbar button responsiveness */
.toolbar-btn {
    transition: all 0.1s ease;
}

.toolbar-btn:hover:not(:disabled) {
    background-color: rgba(100, 150, 200, 0.1);
    transform: translateY(-1px);
}

.toolbar-btn:active:not(:disabled) {
    transform: translateY(0);
    background-color: rgba(100, 150, 200, 0.2);
}

.toolbar-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Context menu instant appearance */
.context-menu {
    animation: contextMenuAppear 0.1s ease-out;
    transform-origin: top left;
}

@keyframes contextMenuAppear {
    from {
        opacity: 0;
        transform: scale(0.9) translateY(-10px);
    }
    to {
        opacity: 1;
        transform: scale(1) translateY(0);
    }
}

/* Optimized status bar */
.status-bar {
    transition: all 0.1s ease;
}

/* Responsive error messages */
.error-message {
    animation: slideInFromTop 0.2s ease-out;
}

@keyframes slideInFromTop {
    from {
        opacity: 0;
        transform: translateY(-20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Optimized for reduced motion users */
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
    
    .loading-spinner {
        animation: none;
        border: 2px solid var(--blueprint-accent);
    }
} 

================================================
File: wails.json
================================================
{
  "$schema": "https://wails.io/schemas/config.v2.json",
  "name": "testui",
  "outputfilename": "testui",
  "frontend:install": "npm install",
  "frontend:build": "npm run build",
  "frontend:dev:watcher": "npm run dev",
  "frontend:dev:serverUrl": "auto",
  "author": {
    "name": "YourAverageDev",
    "email": "andrewzhuangyue@hotmail.com"
  }
}


================================================
File: frontend/wailsjs/runtime/runtime.d.ts
================================================
/*
 _       __      _ __
| |     / /___ _(_) /____
| | /| / / __ `/ / / ___/
| |/ |/ / /_/ / / (__  )
|__/|__/\__,_/_/_/____/
The electron alternative for Go
(c) Lea Anthony 2019-present
*/

export interface Position {
    x: number;
    y: number;
}

export interface Size {
    w: number;
    h: number;
}

export interface Screen {
    isCurrent: boolean;
    isPrimary: boolean;
    width : number
    height : number
}

// Environment information such as platform, buildtype, ...
export interface EnvironmentInfo {
    buildType: string;
    platform: string;
    arch: string;
}

// [EventsEmit](https://wails.io/docs/reference/runtime/events#eventsemit)
// emits the given event. Optional data may be passed with the event.
// This will trigger any event listeners.
export function EventsEmit(eventName: string, ...data: any): void;

// [EventsOn](https://wails.io/docs/reference/runtime/events#eventson) sets up a listener for the given event name.
export function EventsOn(eventName: string, callback: (...data: any) => void): () => void;

// [EventsOnMultiple](https://wails.io/docs/reference/runtime/events#eventsonmultiple)
// sets up a listener for the given event name, but will only trigger a given number times.
export function EventsOnMultiple(eventName: string, callback: (...data: any) => void, maxCallbacks: number): () => void;

// [EventsOnce](https://wails.io/docs/reference/runtime/events#eventsonce)
// sets up a listener for the given event name, but will only trigger once.
export function EventsOnce(eventName: string, callback: (...data: any) => void): () => void;

// [EventsOff](https://wails.io/docs/reference/runtime/events#eventsoff)
// unregisters the listener for the given event name.
export function EventsOff(eventName: string, ...additionalEventNames: string[]): void;

// [EventsOffAll](https://wails.io/docs/reference/runtime/events#eventsoffall)
// unregisters all listeners.
export function EventsOffAll(): void;

// [LogPrint](https://wails.io/docs/reference/runtime/log#logprint)
// logs the given message as a raw message
export function LogPrint(message: string): void;

// [LogTrace](https://wails.io/docs/reference/runtime/log#logtrace)
// logs the given message at the `trace` log level.
export function LogTrace(message: string): void;

// [LogDebug](https://wails.io/docs/reference/runtime/log#logdebug)
// logs the given message at the `debug` log level.
export function LogDebug(message: string): void;

// [LogError](https://wails.io/docs/reference/runtime/log#logerror)
// logs the given message at the `error` log level.
export function LogError(message: string): void;

// [LogFatal](https://wails.io/docs/reference/runtime/log#logfatal)
// logs the given message at the `fatal` log level.
// The application will quit after calling this method.
export function LogFatal(message: string): void;

// [LogInfo](https://wails.io/docs/reference/runtime/log#loginfo)
// logs the given message at the `info` log level.
export function LogInfo(message: string): void;

// [LogWarning](https://wails.io/docs/reference/runtime/log#logwarning)
// logs the given message at the `warning` log level.
export function LogWarning(message: string): void;

// [WindowReload](https://wails.io/docs/reference/runtime/window#windowreload)
// Forces a reload by the main application as well as connected browsers.
export function WindowReload(): void;

// [WindowReloadApp](https://wails.io/docs/reference/runtime/window#windowreloadapp)
// Reloads the application frontend.
export function WindowReloadApp(): void;

// [WindowSetAlwaysOnTop](https://wails.io/docs/reference/runtime/window#windowsetalwaysontop)
// Sets the window AlwaysOnTop or not on top.
export function WindowSetAlwaysOnTop(b: boolean): void;

// [WindowSetSystemDefaultTheme](https://wails.io/docs/next/reference/runtime/window#windowsetsystemdefaulttheme)
// *Windows only*
// Sets window theme to system default (dark/light).
export function WindowSetSystemDefaultTheme(): void;

// [WindowSetLightTheme](https://wails.io/docs/next/reference/runtime/window#windowsetlighttheme)
// *Windows only*
// Sets window to light theme.
export function WindowSetLightTheme(): void;

// [WindowSetDarkTheme](https://wails.io/docs/next/reference/runtime/window#windowsetdarktheme)
// *Windows only*
// Sets window to dark theme.
export function WindowSetDarkTheme(): void;

// [WindowCenter](https://wails.io/docs/reference/runtime/window#windowcenter)
// Centers the window on the monitor the window is currently on.
export function WindowCenter(): void;

// [WindowSetTitle](https://wails.io/docs/reference/runtime/window#windowsettitle)
// Sets the text in the window title bar.
export function WindowSetTitle(title: string): void;

// [WindowFullscreen](https://wails.io/docs/reference/runtime/window#windowfullscreen)
// Makes the window full screen.
export function WindowFullscreen(): void;

// [WindowUnfullscreen](https://wails.io/docs/reference/runtime/window#windowunfullscreen)
// Restores the previous window dimensions and position prior to full screen.
export function WindowUnfullscreen(): void;

// [WindowIsFullscreen](https://wails.io/docs/reference/runtime/window#windowisfullscreen)
// Returns the state of the window, i.e. whether the window is in full screen mode or not.
export function WindowIsFullscreen(): Promise<boolean>;

// [WindowSetSize](https://wails.io/docs/reference/runtime/window#windowsetsize)
// Sets the width and height of the window.
export function WindowSetSize(width: number, height: number): void;

// [WindowGetSize](https://wails.io/docs/reference/runtime/window#windowgetsize)
// Gets the width and height of the window.
export function WindowGetSize(): Promise<Size>;

// [WindowSetMaxSize](https://wails.io/docs/reference/runtime/window#windowsetmaxsize)
// Sets the maximum window size. Will resize the window if the window is currently larger than the given dimensions.
// Setting a size of 0,0 will disable this constraint.
export function WindowSetMaxSize(width: number, height: number): void;

// [WindowSetMinSize](https://wails.io/docs/reference/runtime/window#windowsetminsize)
// Sets the minimum window size. Will resize the window if the window is currently smaller than the given dimensions.
// Setting a size of 0,0 will disable this constraint.
export function WindowSetMinSize(width: number, height: number): void;

// [WindowSetPosition](https://wails.io/docs/reference/runtime/window#windowsetposition)
// Sets the window position relative to the monitor the window is currently on.
export function WindowSetPosition(x: number, y: number): void;

// [WindowGetPosition](https://wails.io/docs/reference/runtime/window#windowgetposition)
// Gets the window position relative to the monitor the window is currently on.
export function WindowGetPosition(): Promise<Position>;

// [WindowHide](https://wails.io/docs/reference/runtime/window#windowhide)
// Hides the window.
export function WindowHide(): void;

// [WindowShow](https://wails.io/docs/reference/runtime/window#windowshow)
// Shows the window, if it is currently hidden.
export function WindowShow(): void;

// [WindowMaximise](https://wails.io/docs/reference/runtime/window#windowmaximise)
// Maximises the window to fill the screen.
export function WindowMaximise(): void;

// [WindowToggleMaximise](https://wails.io/docs/reference/runtime/window#windowtogglemaximise)
// Toggles between Maximised and UnMaximised.
export function WindowToggleMaximise(): void;

// [WindowUnmaximise](https://wails.io/docs/reference/runtime/window#windowunmaximise)
// Restores the window to the dimensions and position prior to maximising.
export function WindowUnmaximise(): void;

// [WindowIsMaximised](https://wails.io/docs/reference/runtime/window#windowismaximised)
// Returns the state of the window, i.e. whether the window is maximised or not.
export function WindowIsMaximised(): Promise<boolean>;

// [WindowMinimise](https://wails.io/docs/reference/runtime/window#windowminimise)
// Minimises the window.
export function WindowMinimise(): void;

// [WindowUnminimise](https://wails.io/docs/reference/runtime/window#windowunminimise)
// Restores the window to the dimensions and position prior to minimising.
export function WindowUnminimise(): void;

// [WindowIsMinimised](https://wails.io/docs/reference/runtime/window#windowisminimised)
// Returns the state of the window, i.e. whether the window is minimised or not.
export function WindowIsMinimised(): Promise<boolean>;

// [WindowIsNormal](https://wails.io/docs/reference/runtime/window#windowisnormal)
// Returns the state of the window, i.e. whether the window is normal or not.
export function WindowIsNormal(): Promise<boolean>;

// [WindowSetBackgroundColour](https://wails.io/docs/reference/runtime/window#windowsetbackgroundcolour)
// Sets the background colour of the window to the given RGBA colour definition. This colour will show through for all transparent pixels.
export function WindowSetBackgroundColour(R: number, G: number, B: number, A: number): void;

// [ScreenGetAll](https://wails.io/docs/reference/runtime/window#screengetall)
// Gets the all screens. Call this anew each time you want to refresh data from the underlying windowing system.
export function ScreenGetAll(): Promise<Screen[]>;

// [BrowserOpenURL](https://wails.io/docs/reference/runtime/browser#browseropenurl)
// Opens the given URL in the system browser.
export function BrowserOpenURL(url: string): void;

// [Environment](https://wails.io/docs/reference/runtime/intro#environment)
// Returns information about the environment
export function Environment(): Promise<EnvironmentInfo>;

// [Quit](https://wails.io/docs/reference/runtime/intro#quit)
// Quits the application.
export function Quit(): void;

// [Hide](https://wails.io/docs/reference/runtime/intro#hide)
// Hides the application.
export function Hide(): void;

// [Show](https://wails.io/docs/reference/runtime/intro#show)
// Shows the application.
export function Show(): void;

// [ClipboardGetText](https://wails.io/docs/reference/runtime/clipboard#clipboardgettext)
// Returns the current text stored on clipboard
export function ClipboardGetText(): Promise<string>;

// [ClipboardSetText](https://wails.io/docs/reference/runtime/clipboard#clipboardsettext)
// Sets a text on the clipboard
export function ClipboardSetText(text: string): Promise<boolean>;

// [OnFileDrop](https://wails.io/docs/reference/runtime/draganddrop#onfiledrop)
// OnFileDrop listens to drag and drop events and calls the callback with the coordinates of the drop and an array of path strings.
export function OnFileDrop(callback: (x: number, y: number ,paths: string[]) => void, useDropTarget: boolean) :void

// [OnFileDropOff](https://wails.io/docs/reference/runtime/draganddrop#dragandddropoff)
// OnFileDropOff removes the drag and drop listeners and handlers.
export function OnFileDropOff() :void

// Check if the file path resolver is available
export function CanResolveFilePaths(): boolean;

// Resolves file paths for an array of files
export function ResolveFilePaths(files: File[]): void

================================================
File: frontend/src/utils/formatUtils.js
================================================
// Formatting utility functions

export const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
};

export const formatFileSize = (size) => {
    const units = ['B', 'KB', 'MB', 'GB', 'TB'];
    let unitIndex = 0;
    let fileSize = size;
    
    while (fileSize >= 1024 && unitIndex < units.length - 1) {
        fileSize /= 1024;
        unitIndex++;
    }
    
    return fileSize < 10 && unitIndex > 0 
        ? `${fileSize.toFixed(1)} ${units[unitIndex]}`
        : `${Math.round(fileSize)} ${units[unitIndex]}`;
}; 

================================================
File: frontend/wailsjs/runtime/runtime.js
================================================
/*
 _       __      _ __
| |     / /___ _(_) /____
| | /| / / __ `/ / / ___/
| |/ |/ / /_/ / / (__  )
|__/|__/\__,_/_/_/____/
The electron alternative for Go
(c) Lea Anthony 2019-present
*/

export function LogPrint(message) {
    window.runtime.LogPrint(message);
}

export function LogTrace(message) {
    window.runtime.LogTrace(message);
}

export function LogDebug(message) {
    window.runtime.LogDebug(message);
}

export function LogInfo(message) {
    window.runtime.LogInfo(message);
}

export function LogWarning(message) {
    window.runtime.LogWarning(message);
}

export function LogError(message) {
    window.runtime.LogError(message);
}

export function LogFatal(message) {
    window.runtime.LogFatal(message);
}

export function EventsOnMultiple(eventName, callback, maxCallbacks) {
    return window.runtime.EventsOnMultiple(eventName, callback, maxCallbacks);
}

export function EventsOn(eventName, callback) {
    return EventsOnMultiple(eventName, callback, -1);
}

export function EventsOff(eventName, ...additionalEventNames) {
    return window.runtime.EventsOff(eventName, ...additionalEventNames);
}

export function EventsOnce(eventName, callback) {
    return EventsOnMultiple(eventName, callback, 1);
}

export function EventsEmit(eventName) {
    let args = [eventName].slice.call(arguments);
    return window.runtime.EventsEmit.apply(null, args);
}

export function WindowReload() {
    window.runtime.WindowReload();
}

export function WindowReloadApp() {
    window.runtime.WindowReloadApp();
}

export function WindowSetAlwaysOnTop(b) {
    window.runtime.WindowSetAlwaysOnTop(b);
}

export function WindowSetSystemDefaultTheme() {
    window.runtime.WindowSetSystemDefaultTheme();
}

export function WindowSetLightTheme() {
    window.runtime.WindowSetLightTheme();
}

export function WindowSetDarkTheme() {
    window.runtime.WindowSetDarkTheme();
}

export function WindowCenter() {
    window.runtime.WindowCenter();
}

export function WindowSetTitle(title) {
    window.runtime.WindowSetTitle(title);
}

export function WindowFullscreen() {
    window.runtime.WindowFullscreen();
}

export function WindowUnfullscreen() {
    window.runtime.WindowUnfullscreen();
}

export function WindowIsFullscreen() {
    return window.runtime.WindowIsFullscreen();
}

export function WindowGetSize() {
    return window.runtime.WindowGetSize();
}

export function WindowSetSize(width, height) {
    window.runtime.WindowSetSize(width, height);
}

export function WindowSetMaxSize(width, height) {
    window.runtime.WindowSetMaxSize(width, height);
}

export function WindowSetMinSize(width, height) {
    window.runtime.WindowSetMinSize(width, height);
}

export function WindowSetPosition(x, y) {
    window.runtime.WindowSetPosition(x, y);
}

export function WindowGetPosition() {
    return window.runtime.WindowGetPosition();
}

export function WindowHide() {
    window.runtime.WindowHide();
}

export function WindowShow() {
    window.runtime.WindowShow();
}

export function WindowMaximise() {
    window.runtime.WindowMaximise();
}

export function WindowToggleMaximise() {
    window.runtime.WindowToggleMaximise();
}

export function WindowUnmaximise() {
    window.runtime.WindowUnmaximise();
}

export function WindowIsMaximised() {
    return window.runtime.WindowIsMaximised();
}

export function WindowMinimise() {
    window.runtime.WindowMinimise();
}

export function WindowUnminimise() {
    window.runtime.WindowUnminimise();
}

export function WindowSetBackgroundColour(R, G, B, A) {
    window.runtime.WindowSetBackgroundColour(R, G, B, A);
}

export function ScreenGetAll() {
    return window.runtime.ScreenGetAll();
}

export function WindowIsMinimised() {
    return window.runtime.WindowIsMinimised();
}

export function WindowIsNormal() {
    return window.runtime.WindowIsNormal();
}

export function BrowserOpenURL(url) {
    window.runtime.BrowserOpenURL(url);
}

export function Environment() {
    return window.runtime.Environment();
}

export function Quit() {
    window.runtime.Quit();
}

export function Hide() {
    window.runtime.Hide();
}

export function Show() {
    window.runtime.Show();
}

export function ClipboardGetText() {
    return window.runtime.ClipboardGetText();
}

export function ClipboardSetText(text) {
    return window.runtime.ClipboardSetText(text);
}

/**
 * Callback for OnFileDrop returns a slice of file path strings when a drop is finished.
 *
 * @export
 * @callback OnFileDropCallback
 * @param {number} x - x coordinate of the drop
 * @param {number} y - y coordinate of the drop
 * @param {string[]} paths - A list of file paths.
 */

/**
 * OnFileDrop listens to drag and drop events and calls the callback with the coordinates of the drop and an array of path strings.
 *
 * @export
 * @param {OnFileDropCallback} callback - Callback for OnFileDrop returns a slice of file path strings when a drop is finished.
 * @param {boolean} [useDropTarget=true] - Only call the callback when the drop finished on an element that has the drop target style. (--wails-drop-target)
 */
export function OnFileDrop(callback, useDropTarget) {
    return window.runtime.OnFileDrop(callback, useDropTarget);
}

/**
 * OnFileDropOff removes the drag and drop listeners and handlers.
 */
export function OnFileDropOff() {
    return window.runtime.OnFileDropOff();
}

export function CanResolveFilePaths() {
    return window.runtime.CanResolveFilePaths();
}

export function ResolveFilePaths(files) {
    return window.runtime.ResolveFilePaths(files);
}

================================================
File: main.go
================================================
package main

import (
	"embed"

	"github.com/wailsapp/wails/v2"
	"github.com/wailsapp/wails/v2/pkg/options"
	"github.com/wailsapp/wails/v2/pkg/options/assetserver"

	"testui/backend"
)

//go:embed all:frontend/dist
var assets embed.FS

func main() {
	// Create an instance of the app structure
	app := backend.NewApp()

	// Create application with options
	err := wails.Run(&options.App{
		Title:  "Blueprint File Explorer",
		Width:  1400,
		Height: 900,
		AssetServer: &assetserver.Options{
			Assets: assets,
		},
		BackgroundColour: &options.RGBA{R: 27, G: 38, B: 54, A: 1},
		OnStartup:        app.Startup,
		Bind: []interface{}{
			app,
		},
	})

	if err != nil {
		println("Error:", err.Error())
	}
}


================================================
File: frontend/wailsjs/go/backend/App.js
================================================
// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Â MODIWL
// This file is automatically generated. DO NOT EDIT

export function ClearCache() {
  return window['go']['backend']['App']['ClearCache']();
}

export function CopyFiles(arg1, arg2) {
  return window['go']['backend']['App']['CopyFiles'](arg1, arg2);
}

export function CreateDirectory(arg1, arg2) {
  return window['go']['backend']['App']['CreateDirectory'](arg1, arg2);
}

export function DeleteFiles(arg1) {
  return window['go']['backend']['App']['DeleteFiles'](arg1);
}

export function DeletePath(arg1) {
  return window['go']['backend']['App']['DeletePath'](arg1);
}

export function ExecuteCommand(arg1, arg2) {
  return window['go']['backend']['App']['ExecuteCommand'](arg1, arg2);
}

export function FileExists(arg1) {
  return window['go']['backend']['App']['FileExists'](arg1);
}

export function FormatFileSize(arg1) {
  return window['go']['backend']['App']['FormatFileSize'](arg1);
}

export function GetAvailableTerminals() {
  return window['go']['backend']['App']['GetAvailableTerminals']();
}

export function GetCacheStats() {
  return window['go']['backend']['App']['GetCacheStats']();
}

export function GetCurrentWorkingDirectory() {
  return window['go']['backend']['App']['GetCurrentWorkingDirectory']();
}

export function GetDriveInfo() {
  return window['go']['backend']['App']['GetDriveInfo']();
}

export function GetFileDetails(arg1) {
  return window['go']['backend']['App']['GetFileDetails'](arg1);
}

export function GetHomeDirectory() {
  return window['go']['backend']['App']['GetHomeDirectory']();
}

export function GetQuickAccessPaths() {
  return window['go']['backend']['App']['GetQuickAccessPaths']();
}

export function GetSystemRoots() {
  return window['go']['backend']['App']['GetSystemRoots']();
}

export function HealthCheck() {
  return window['go']['backend']['App']['HealthCheck']();
}

export function HideFiles(arg1) {
  return window['go']['backend']['App']['HideFiles'](arg1);
}

export function IsHidden(arg1) {
  return window['go']['backend']['App']['IsHidden'](arg1);
}

export function ListDirectory(arg1) {
  return window['go']['backend']['App']['ListDirectory'](arg1);
}

export function MoveFiles(arg1, arg2) {
  return window['go']['backend']['App']['MoveFiles'](arg1, arg2);
}

export function MoveFilesToRecycleBin(arg1) {
  return window['go']['backend']['App']['MoveFilesToRecycleBin'](arg1);
}

export function NavigateToPath(arg1) {
  return window['go']['backend']['App']['NavigateToPath'](arg1);
}

export function NavigateUp(arg1) {
  return window['go']['backend']['App']['NavigateUp'](arg1);
}

export function OpenFile(arg1) {
  return window['go']['backend']['App']['OpenFile'](arg1);
}

export function OpenInSystemExplorer(arg1) {
  return window['go']['backend']['App']['OpenInSystemExplorer'](arg1);
}

export function OpenPowerShellHere(arg1) {
  return window['go']['backend']['App']['OpenPowerShellHere'](arg1);
}

export function OpenTerminalHere(arg1) {
  return window['go']['backend']['App']['OpenTerminalHere'](arg1);
}

export function RenameFile(arg1, arg2) {
  return window['go']['backend']['App']['RenameFile'](arg1, arg2);
}

export function ValidatePath(arg1) {
  return window['go']['backend']['App']['ValidatePath'](arg1);
}


================================================
File: frontend/src/hooks/useDialogs.js
================================================
import { useState, useCallback } from "preact/hooks";

export function useDialogs() {
    const [dialog, setDialog] = useState({
        isOpen: false,
        type: 'alert',
        title: '',
        message: '',
        defaultValue: '',
        onConfirm: () => {},
        onCancel: () => {}
    });

    const showDialog = useCallback((type, title, message, defaultValue = '', onConfirm = () => {}, onCancel = () => {}) => {
        setDialog({
            isOpen: true,
            type,
            title,
            message,
            defaultValue,
            onConfirm: (value) => {
                setDialog(prev => ({ ...prev, isOpen: false }));
                onConfirm(value);
            },
            onCancel: () => {
                setDialog(prev => ({ ...prev, isOpen: false }));
                onCancel();
            }
        });
    }, []);

    const closeDialog = useCallback(() => {
        setDialog(prev => ({ ...prev, isOpen: false }));
    }, []);

    return {
        dialog,
        showDialog,
        closeDialog
    };
} 

